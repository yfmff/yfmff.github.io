<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<search>
  
  <entry>
    <title>Linux 进程</title>
    <url>/yfmff/yfmff.github.io.git/post/linux/linuxprocess/</url>
    <categories><category>linux</category>
    </categories>
    <tags>
    </tags>
    <content type="html"><![CDATA[
什么是进程 在说清楚进程这个概念前，可以试想下这样的场景：我从网上下载微信的安装包，点击安装在D盘的weichat文件夹，但是我并没有马上双击图标运行它，而打开任务管理器也看不到微信，此时微信只是占用了我的磁盘文件，没占用内存，CPU也不必给它分配时间片，现在的它和我自己写了个word文档没太大区别。这时，称wechat文件夹中的是一个程序，它和word文档的唯一区别是它能运行。而一旦我们双击微信图标让它运行，任务管理器就能看到它的身影了，而通过它进行收发消息需要CPU的帮助，占用了系统资源，此时，微信就是一个进程了。
通过以上场景，可以发现，程序是个资源，类似库存，而进程则是运行时才会产生：资源是进程的必要不充分条件。 程序执行后，相关资源就会被加载到内存中，每个运行的进程都会消耗系统资源，而系统为了方便管理，对每个进程都分配了专属的虚拟地址空间。
并行和并发 这两个词语经常能听见，但这个词差别很大。比如去做核酸，人比较多。如果是并行的话，一个地点有多个核酸亭，多个核酸亭同时运行，外人看来就是这几队的人在同时往前走，这叫并行。而如果一个地点虽然人多，但是只有一个核酸亭，但是人分别排了好几个队伍，核酸亭内的工作人员只能一个隔着一个的，检测一个A队的，再检测一个B队的，外人看来，这两个队的人仍然在往前走，和并行类似，这种情况叫并发。可见，并发是假的，如果把核酸亭的工作人员看作CPU，则是CPU不断切换时间片来达到并发效果，负载相较并行肯定要大的多，毕竟同样体质下，一个人怎么都比不过两个人的效率嘛。
进程命令 Linux上想查看当前有多少进程在运行，可使用PS aux命令，其中，a: 查看所有终端的信息，u: 查看用户相关的信息，x: 显示和终端无关的进程信息。
想要终结进程，则使用klll。kill命令可以发送某个信号到对应的进程，进程收到某些信号之后默认的处理动作就是退出进程，如果要给进程发送信号，可以先查看一下Linux提供了哪些标准信号。
1$ kill -l 2 1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 5) SIGTRAP 3 6) SIGABRT 7) SIGBUS 8) SIGFPE 9) SIGKILL 10) SIGUSR1 411) SIGSEGV 12) SIGUSR2 13) SIGPIPE 14) SIGALRM 15) SIGTERM 516) SIGSTKFLT 17) SIGCHLD 18) SIGCONT 19) SIGSTOP 20) SIGTSTP 621) SIGTTIN 22) SIGTTOU 23) SIGURG 24) SIGXCPU 25) SIGXFSZ 726) SIGVTALRM 27) SIGPROF 28) SIGWINCH 29) SIGIO 30) SIGPWR 831) SIGSYS 34) SIGRTMIN 35) SIGRTMIN+1 36) SIGRTMIN+2 37) SIGRTMIN+3 938) SIGRTMIN+4 39) SIGRTMIN+5 40) SIGRTMIN+6 41) SIGRTMIN+7 42) SIGRTMIN+8 1043) SIGRTMIN+9 44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13 1148) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12 1253) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9 56) SIGRTMAX-8 57) SIGRTMAX-7 1358) SIGRTMAX-6 59) SIGRTMAX-5 60) SIGRTMAX-4 61) SIGRTMAX-3 62) SIGRTMAX-2 1463) SIGRTMAX-1 64) SIGRTMAX 比如我想终结某个进程，可以这样写：
1kill -9 进程ID 2kill -SIGKILL 进程ID 创建进程 linux中进程ID是pid_t类型，本质上就是一个正整数。
1#include &lt;sys/types.h&gt; 2#include &lt;unistd.h&gt; 3 4// 获取当前进程ID 5pid_t getpid(void); 6 7//获取当前进程的父进程ID（PPID） 8pid_t getppid(void); 9 10// 创建一个进程，返回它的ID 11pid_t fork(void); fork() 用fork()可创建一个进程，看起来很简单。但是，这个函数并不像表面上这么简单==。我们启动一个程序，得到一个进程，如果在这个进程里调用fork，就像生孩子一样，从它里面又生出了一个进程，叫子进程。
每个进程都有独立的虚拟地址空间，而子进程是“生”出来的，那么其地址空间自然是从父进程那拷贝出来的，但是只是在拷贝完成的那一刻是一样的，之后就是孩子出去自立门户，个人各扫门前雪喽，个人的地址空间里的数据就各不相同了。 进程所占的地址空间分两个区：内核区和用户区：
1父进程 子进程 2-------- ------- 3内核区域 内核区域 4---------- -------- 5用户区内容： 用户区内容： 6 7环境变量 环境变量 8 栈 栈 9内存映射区 内存映射区 10堆 堆 11.bss .bss 12.data .data 13.text .text 相同点：
代码区：因为是父进程生下来的，姓氏一样，而代码就代表姓氏，父子进程的代码区内容相同。 全局数据区/堆区/内存映射区/栈区/环境变量/文件描述符表：父进程的这些家当，也被拷贝了一份。特别注意，文件描述表也被拷贝了，这意味着父进程能找到的文件，子进程也可以。 不同点
父子分家了，地址空间独立，互不影响，数据不会相互覆盖。 父子进程中代码虽然一样，但是不代表它们执行的进度一样。 进程启动之后进入就绪态，运行需要争抢CPU时间片而且可能执行不同的业务逻辑，这也是父子进程虽然代码一样，但是运行状态可能是不同的原因。 fork调用成功之后，会返回两个值，父子进程的返回值不同。因为父进程生了一个子进程出来，父进程本身就有一个ID，生的子进程也要给它一个ID啊。父进程返回的ID是个大于0的数，子进程返回的数是0，以此做区分。因此，我们需要根据fork的返回值来判断当前进程是谁。 举个例子：
1int main() 2{ 3 // 在父进程中创建子进程 4 pid_t pid = fork(); 5 printf(&#34;当前进程fork()的返回值: %d\n&#34;, pid); 6 if(pid &gt; 0) 7 { 8 // 父进程执行的逻辑 9 printf(&#34;我是父进程, pid = %d\n&#34;, getpid()); 10 } 11 else if(pid == 0) 12 { 13 // 子进程执行的逻辑 14 printf(&#34;我是子进程, pid = %d, 我爹是: %d\n&#34;, getpid(), getppid()); 15 } 16 else // pid == -1 17 { 18 // 创建子进程失败了 19 } 20 21 // 不加判断, 父子进程都会执行这个循环 22 for(int i=0; i&lt;5; ++i) 23 { 24 printf(&#34;%d\n&#34;, i); 25 } 26 27 return 0; 第21行为毛会父子都执行呢？这里要注意的是，子进程在哪个地方创建，它就拥有了父进程的所有代码，在它创建完成时它就开始执行了，上例来说就是，它在第4行创建，它就从第5行开始运行了，和父进程无关了。换句话说就是相当于你双开了微信。 为了加深理解，可以做个简单例子：在一个父进程里循环创建3个子进程，最后得到4个进程。正确代码是：1// 需要在上边的程序中控制不让子进程, 再创建子进程即可 2// process_loop.c 3#include &lt;stdio.h&gt; 4#include &lt;stdlib.h&gt; 5#include &lt;unistd.h&gt; 6#include &lt;string.h&gt; 7 8int main() 9{ 10 pid_t pid; 11 // 在循环中创建子进程 12 for(int i=0; i&lt;3; ++i) 13 { 14 pid = fork(); 15 if(pid == 0) // 必须加，不然子进程也会执行 16 { 17 // 不让子进程执行循环, 直接跳出 18 break; 19 } 20 } 21 printf(&#34;当前进程pid: %d\n&#34;, getpid()); 22 23 return 0; 24} execl 和 execlp 一般不会直接在主进程调用这些函数，而是创建一个进程来执行，这样就可以和主进程隔离。有时我们会通过现在运行的程序打开另一个程序，比如我在浏览器里想下载视频，点击链接就会自动打开迅雷。这时，可用exec系列函数。函数原型如下：
1#include &lt;unistd.h&gt; 2 3extern char **environ; 4int execl(const char *path, const char *arg, ... 5 /* (char *) NULL */); 6int execlp(const char *file, const char *arg, ... 7 /* (char *) NULL */); 8int execle(const char *path, const char *arg, ... 9 /*, (char *) NULL, char * const envp[] */); 10int execv(const char *path, char *const argv[]); 11int execvp(const char *file, char *const argv[]); 12int execvpe(const char *file, char *const argv[], 13 char *const envp[]); 这些函数执行成功后不会返回，因为调用进程的实体，包括代码段，数据段和堆栈等都已经被新的内容取代（也就是说用户区数据基本全部被替换掉了），只留下进程 ID 等一些表面上的信息仍保持原样,调用失败了，它们才会返回一个 -1，从原程序的调用点接着往下执行。换句话说，就是预先创建一个进程，然后把这个进程的位置、资源全让出来给新的进程。execl 可用于执行任意一个可执行程序，函数需要通过指定的文件路径才能找到这个可执行程序。
1#include &lt;unistd.h&gt; 2// 变参函数 3int execl(const char *path, const char *arg, ...); 其中： path: 要启动的可执行程序的路径，推荐使用绝对路径。 arg：ps aux 查看进程的时候，启动的进程的名字，可以随意指定，一般和要启动的可执行程序名相同。 &hellip;：参数列表，最后以null结尾。 返回值：执行成功则没有返回值，执行失败返回-1；
execlp() 常用于执行已经设置了环境变量的可执行程序，函数中的p就是path，也是说这个函数会自动搜索系统的环境变量PATH，因此使用这个函数执行可执行程序不需要指定路径，只需要指定出名字即可。
1// p == path 2int execlp(const char *file, const char *arg, ...); 其中： file：程序的名字（没有在环境变量PATH中，可执行程序需要指定绝对路径）。 arg/&hellip;/返回值：同上。
控制进程 结束进程 在进程的任何位置调用exit(int status)或者_exit(int status)函数都可以退出当前进程，status为进程退出时返回的退出码。
孤儿进程 父进程创建子进程后先退出了，独留子进程在人间，成了孤儿。linux当检测到这个进程是个孤儿时，会有一个固定的进程来认养它。 这时为什么呢？子进程会拷贝父进程的家当，当它自己退出后，用户区的资源自己可以释放，但是内核区的资源它无权释放，只能由父进程释放。系统通过给他指定个干爹来做这件事，防止资源浪费。僵尸进程 有的人活着，但它已经死了，但有的人死了，他永远活着。这是很出名的格言，但是，如果操作系统中出现死了的线程还占着资源的情况的话，就比较麻烦了。 僵尸进程不能将它看成是一个正常的进程，这个进程已经死亡了，用户区资源已经被释放了，只是还占用着一些内核资源（PCB）我们创建个僵尸进程：
1int main() 2{ 3 pid_t pid; 4 // 创建子进程 5 for(int i=0; i&lt;5; ++i) 6 { 7 pid = fork(); 8 if(pid == 0) 9 { 10 break; 11 } 12 } 13 14 // 父进程 15 if(pid &gt; 0) 16 { 17 // 需要保证父进程一直在运行 18 // 一直运行不退出, 并且也做回收, 就会出现僵尸进程 19 while(1) 20 { 21 printf(&#34;我是父进程, pid=%d\n&#34;, getpid()); 22 sleep(1); 23 } 24 } 25 else if(pid == 0) 26 { 27 // 子进程, 执行这句代码之后, 子进程退出了 28 printf(&#34;我是子进程, pid=%d, 父进程ID: %d\n&#34;, getpid(), getppid()); 29 } 30 return 0; 31} 消灭僵尸进程的方法是，杀死这个僵尸进程的父进程，这样僵尸进程的资源就被系统回收了。通过 kill -9 僵尸进程PID 的方式是不能消灭僵尸进程的，这个命令只对活着的进程有效！回收进程 wait 这是个阻塞函数，如果没有子进程退出，函数会一直阻塞等待，当检测到子进程退出了，该函数阻塞解除回收子进程资源。这个函数被调用一次，只能回收一个子进程的资源，如果有多个子进程需要资源回收，函数需要被调用多次。原型如下：
1// man 2 wait 2#include &lt;sys/wait.h&gt; 3 4pid_t wait(int *status); 其中：
status:传出参数，通过传递出的信息判断回收的进程是怎么退出的，如不需要则可以指定为 NULL。
类型 含义 WIFEXITED(status) 返回 1, 进程是正常退出的 WEXITSTATUS(status) 得到进程退出时候的状态码，相当于return后边的数值，或者exit()函数的参数 WIFSIGNALED(status) 返回 1, 进程是被信号杀死了 WTERMSIG(status) 获得进程是被哪个信号杀死的，会得到信号的编号 返回值： 成功：返回进程ID 失败：返回-1 举例：
1// wait 函数回收子进程资源 2#include &lt;sys/wait.h&gt; 3 4int main() 5{ 6 pid_t pid; 7 // 创建子进程 8 for(int i=0; i&lt;5; ++i) 9 { 10 pid = fork(); 11 if(pid == 0) 12 { 13 break; 14 } 15 } 16 17 // 父进程 18 if(pid &gt; 0) 19 { 20 // 需要保证父进程一直在运行 21 while(1) 22 { 23 // 回收子进程的资源 24 // 子进程由多个, 需要循环回收子进程资源 25 pid_t ret = wait(NULL); 26 if(ret &gt; 0) 27 { 28 printf(&#34;成功回收了子进程资源, 子进程PID: %d\n&#34;, ret); 29 } 30 else 31 { 32 printf(&#34;回收失败, 或者是已经没有子进程了...\n&#34;); 33 break; 34 } 35 printf(&#34;我是父进程, pid=%d\n&#34;, getpid()); 36 } 37 } 38 else if(pid == 0) 39 { 40 // 子进程, 执行这句代码之后, 子进程退出了 41 printf(&#34;我是子进程, pid=%d, 父进程ID: %d\n&#34;, getpid(), getppid()); 42 } 43 return 0; 44} waitpid waitpid可以看做wait的升级版，通过该函数可以控制回收子进程资源的方式是阻塞还是非阻塞，另外还可以通过该函数进行精准打击，可以精确指定回收某个或者某一类或者是全部子进程资源。原型如下：
1// man 2 waitpid 2#include &lt;sys/wait.h&gt; 3// 这个函数可以设置阻塞, 也可以设置为非阻塞 4// 这个函数可以指定回收哪些子进程的资源 5pid_t waitpid(pid_t pid, int *status, int options); 其中： pid 含义 -1 回收所有的子进程资源 大于0 指定回收某一个进程的资源，pid是要回收的子进程的进程ID 0 回收当前进程组的所有子进程ID 小于-1 其绝对值代表进程组ID，表示要回收这个进程组的所有子进程资源 status：和wait一样。
options：控制函数是阻塞还是非阻塞，0: 函数是行为是阻塞的，WNOHANG: 函数是行为是非阻塞的。
返回值：
如果函数是非阻塞的，并且子进程还在运行，返回0。
成功：得到子进程的进程ID。
失败: -1（没有子进程资源可以回收了，函数如果是阻塞的，阻塞会解除，直接返回 - 1或回收子进程资源的时候出现了异常）
示例：通过 waitpid() 阻塞回收多个子进程资源
1// 和wait() 行为一样, 阻塞 2#include &lt;sys/wait.h&gt; 3 4int main() 5{ 6 pid_t pid; 7 // 创建子进程 8 for(int i=0; i&lt;5; ++i) 9 { 10 pid = fork(); 11 if(pid == 0) 12 { 13 break; 14 } 15 } 16 17 // 父进程 18 if(pid &gt; 0) 19 { 20 // 需要保证父进程一直在运行 21 while(1) 22 { 23 // 回收子进程的资源 24 // 子进程由多个, 需要循环回收子进程资源 25 int status; 26 pid_t ret = waitpid(-1, &amp;status, 0); // == wait(NULL); 27 if(ret &gt; 0) 28 { 29 printf(&#34;成功回收了子进程资源, 子进程PID: %d\n&#34;, ret); 30 // 判断进程是不是正常退出 31 if(WIFEXITED(status)) 32 { 33 printf(&#34;子进程退出时候的状态码: %d\n&#34;, WEXITSTATUS(status)); 34 } 35 if(WIFSIGNALED(status)) 36 { 37 printf(&#34;子进程是被这个信号杀死的: %d\n&#34;, WTERMSIG(status)); 38 } 39 } 40 else 41 { 42 printf(&#34;回收失败, 或者是已经没有子进程了...\n&#34;); 43 break; 44 } 45 printf(&#34;我是父进程, pid=%d\n&#34;, getpid()); 46 } 47 } 48 else if(pid == 0) 49 { 50 // 子进程, 执行这句代码之后, 子进程退出了 51 printf(&#34;===我是子进程, pid=%d, 父进程ID: %d\n&#34;, getpid(), getppid()); 52 } 53 return 0; 54} 示例:通过 waitpid() 非阻塞回收多个子进程资源
1// 非阻塞处理 2#include &lt;sys/wait.h&gt; 3 4int main() 5{ 6 pid_t pid; 7 // 创建子进程 8 for(int i=0; i&lt;5; ++i) 9 { 10 pid = fork(); 11 if(pid == 0) 12 { 13 break; 14 } 15 } 16 17 // 父进程 18 if(pid &gt; 0) 19 { 20 // 需要保证父进程一直在运行 21 while(1) 22 { 23 // 回收子进程的资源 24 // 子进程由多个, 需要循环回收子进程资源 25 // 子进程退出了就回收, 26 // 没退出就不回收, 返回0 27 int status; 28 pid_t ret = waitpid(-1, &amp;status, WNOHANG); // 非阻塞 29 if(ret &gt; 0) 30 { 31 printf(&#34;成功回收了子进程资源, 子进程PID: %d\n&#34;, ret); 32 // 判断进程是不是正常退出 33 if(WIFEXITED(status)) 34 { 35 printf(&#34;子进程退出时候的状态码: %d\n&#34;, WEXITSTATUS(status)); 36 } 37 if(WIFSIGNALED(status)) 38 { 39 printf(&#34;子进程是被这个信号杀死的: %d\n&#34;, WTERMSIG(status)); 40 } 41 } 42 else if(ret == 0) 43 { 44 printf(&#34;子进程还没有退出, 不做任何处理...\n&#34;); 45 } 46 else 47 { 48 printf(&#34;回收失败, 或者是已经没有子进程了...\n&#34;); 49 break; 50 } 51 printf(&#34;我是父进程, pid=%d\n&#34;, getpid()); 52 } 53 } 54 else if(pid == 0) 55 { 56 // 子进程, 执行这句代码之后, 子进程退出了 57 printf(&#34;===我是子进程, pid=%d, 父进程ID: %d\n&#34;, getpid(), getppid()); 58 } 59 return 0; 60} ]]></content>
  </entry>
  
  <entry>
    <title>博客迁移踩坑记</title>
    <url>/yfmff/yfmff.github.io.git/post/others/moveblog/</url>
    <categories>
    </categories>
    <tags>
    </tags>
    <content type="html"><![CDATA[ 之前博客是采用hexo+github来搭建的，这两年比较忙也没写多少文章，才40多篇，就已经感觉到hexo生成博客速度有点慢了，每次改动都需要重新生成才能看到更改的对不对，太麻烦，再加上github日常抽风连不上，考虑迁移。而hugo采用go语言编写，生成博客速度奇快（官网说的是全球最快。。。），并且可以在更改配置或者文章时实时显示结果，省去手动生成的步骤，简直懒狗福音！为了长远考虑，这个周末花了半天时间将博客重新部署，采用hugo+gitee的方式，开启新的篇章！
安装hugo 安装hugo要比安装hexo简单太多了。hexo因为需要nodejs支持，还需要安装nodejs以及相关支持模块，配置较复杂；而hugo下载后就是一个exe文件，此外几乎不需要其他模块支持了。
应用主题 hugo有一点不是太好，就是没有默认主题。刚下载好hugo时，以为像hexo一样，执行hexo cl &amp;&amp; hexo g &amp;&amp; hexo s相似的命令hugo server就能本地开启demo显示，结果，打开浏览器什么都没有！网上查资料才发现hugo本身是不带默认主题的，需要自行下载主题使用。。。
之前hexo博客使用的主题是一个大佬做的名为butterfly的主题，奈何这个主题没有hugo版本的，选了半天，决定采用NextT这个主题，主要是看起来简洁舒服。作者的gitee。教程很详细。
搭建的时候，直接打开cmd，切换到e盘，然后执行hugo new site 你的站点名（假设是blog）。执行完后会在E盘下生成名为blog的文件夹，文件夹内部hugo初始化生成了一些文件，不要删除。根据作者教程，直接采用引用的方式，cmd中cd到blog文件夹，执行以下代码：
1$ git submodule add https://gitee.com/hugo-next/hugo-theme-next.git 2$ cp themes/hugo-theme-next/exampleSite/config.yaml . 3$ mv config.toml config.toml.backup theme文件夹下就会出现下载的主题，并且blog文件夹下也会新增一个名为config.yaml的文件，至此，主题应用结束（真的超级简单有没有！！！作者NB！）。
配置个性化 接下来是hugo新手使用NextT主题几乎都会踩的坑。。。
为毛我的本地示例点击关于、归档等功能都不能弹出页面？ 如图，themes/hugo-theme-next/exampleSite文件夹中有content这个文件夹，为了界面上关于、归档等功能可用，需要自行将该文件夹下archeves和about.md复制到blog根目录下同名文件夹中，这样界面上关于、归档就可用了。同理，配合config.yaml，还可以自定义自己的页面。 生成文件夹名称大小写问题 这个问题在hexo搭载博客时也遇到了，比如，我之前有文章标签是Qt，但是在生成博客后，public/tags文件夹下，生成的文件夹名称是qt？？？ 此时，需要将根目录和public下的 .git/config 中的 ignorecase 改成 false，然后全部重新生成再部署。。。不知道git为毛默认改大小写不算更改。。。 文章中插入图片 hugo静态文件都放在static文件夹下，换句话说，这个文件是图片文件夹的根目录 /。当然，theme文件夹下的static文件夹下的图片也是一样。 hexo可以通过一个简单命令hexo -d就直接部署到仓库，但是hugo不行。通过命令hugo -D(注意：D一定要大写)，会在博客根目录生成public文件夹，这个文件夹里的内容就是我们要传到仓库中的内容。接下来在此文件夹下执行以下代码就行了： 代码 效果 git init 初始化 git remote add origin 仓库地址 和远程仓库建立关联 git add * 将全部文件加入修改 git commit -m &ldquo;注释&rdquo; 添加到本地暂存区 git push -u origin master 提交到仓库 ]]></content>
  </entry>
  
  <entry>
    <title>Linux文件描述符</title>
    <url>/yfmff/yfmff.github.io.git/post/linux/linuxfiledescrib/</url>
    <categories><category>linux</category>
    </categories>
    <tags>
    </tags>
    <content type="html"><![CDATA[
文件描述符含义 Linux中，一切皆文件。那么，程序怎么知道打开了哪个文件呢？方法是使用文件描述符（简称fd）。当进程打开一个现有文件或者创建一个新文件时，内核会向该进程返回一个文件描述符，用于对应打开/新建文件。这些fd保存在内核为每个进程维护的一个文件描述符表中。 文件描述符这个概念只适应于Linux、unix这样的操作系统。标准C库的文件IO函数使用的文件指针FILE * 在Linux中也需要通过文件描述符的辅助才能完成读写操作。FILE其实是一个结构体，其内部有一个成员就是文件描述符。
文件描述符表 当一个进程启动，内核就会为进程维护一个对应的虚拟地址空间，这个虚拟地址空间分两个大部分，在内核区有专门用于进程管理的模块。Linux的进程控制块PCB，本质就是一个叫做task_struct，里面有管理进程所需要的各种信息，其中一个结构体叫做file，就是文件描述符表，里面有个整形索引表，用于存储fd。此表索引从0开始。
1struct task_struct //PCB 2{ 3 ... 4 struct file{} //文件描述符表 5 ... 6} 可打开的最大文件数 每一个进程对应的文件描述符表能够存储的打开的文件数是有限制的，默认为1024个，这个默认值是可以修改的，支持打开的最大文件数据取决于操作系统的硬件配置。 默认分配的fd 当一个进程被启动之后，内核PCB的文件描述符表中就 已经分配 了三个文件描述符，这三个文件描述符对应的都是当前启动这个进程的终端文件（Linux中一切皆文件，终端就是一个设备文件，在 /dev 目录中） STDIN_FILENO：标准输入，可以通过这个文件描述符将数据输入到终端文件中，宏值为 0。 STDOUT_FILENO：标准输出，可以通过这个文件描述符将数据通过终端输出出来，宏值为 1。 STDERR_FILENO：标准错误，可以通过这个文件描述符将错误信息通过终端输出出来，宏值为 2。 三个默认分配的文件描述符是可以通过 close() 函数关闭掉，但是关闭之后当前进程也就不能和当前终端进行输入或者输出的信息交互了。 给新打开的文件分配文件描述符 因为进程启动之后，文件描述符表中的 0,1,2 就被分配出去了，因此从 3 开始分配。 在进程中每打开一个文件，就会给这个文件分配一个新的文件描述符。 进程中不同的文件描述符打开的磁盘文件可能是同一个。 打开的新文件会关联文件描述符表中最小的没有被占用的文件描述符。文件描述符的创建和使用 每个系统都有自己的专属函数，我们习惯称其为系统函数。系统函数并不是内核函数，因为内核函数是不允许用户使用的，系统函数就充当了二者之间的桥梁，这样用户就可以间接的完成某些内核操作了。
在 Linux 系统中必须要使用系统提供的IO函数才能基于这些文件描述符完成对相关文件的读写操作。这些Linux系统IO函数和标准C库的IO函数使用方法类似，函数名称也类似。
open 1#include &lt;sys/types.h&gt; 2#include &lt;sys/stat.h&gt; 3#include &lt;fcntl.h&gt; 4 5/* 6open是一个系统函数, 只能在linux系统中使用, windows不支持 7fopen是标准c库函数, 一般都可以跨平台使用, 可以这样理解: 8	- 在linux中 fopen底层封装了Linux的系统API open 9	- 在window中, fopen底层封装的是 window 的 api 10*/ 11// 打开一个已经存在的磁盘文件 12int open(const char *pathname, int flags); 13// 打开磁盘文件, 如果文件不存在, 就会自动创建 14int open(const char *pathname, int flags, mode_t mode); 其中，flags是使用什么方式打开指定的文件，这个参数对应一些宏值： O_RDONLY: 以只读方式打开文件 O_WRONLY: 以只写方式打开文件 O_RDWR: 以读写方式打开文件 O_APPEND: 新数据追加到文件尾部，不会覆盖文件的原来内容 O_CREAT: 如果文件不存在，创建该文件，如果文件存在什么也不做 O_EXCL: 检测文件是否存在，必须要和 O_CREAT 一起使用，不能单独使用: O_CREAT | O_EXCL mode是在创建新文件的时候才需要指定这个参数的值，用于指定新文件的权限，这是一个八进制的整数（最大值为：0777），创建的新文件对应的最终实际权限，计算公式: (mode &amp; ~umask)。 假设 mode 参数的值为 0777, 通过计算得到的文件权限为 0775。
1# umask(文件掩码): 002(八进制) = 000000010 (二进制) 2# ~umask(掩码取反): ~000000010 (二进制) = 111111101 (二进制) 3# 参数mode指定的权限为: 0777(八进制) = 111111111(二进制) 4# 计算公式: mode &amp; ~umask 5 111111111 6 &amp; 111111101 7 ------------------ 8 111111101 二进制 9 ------------------ 10 mod=0775 八进制 返回值 成功：返回内核分配的文件描述符，这个值被记录在内核的文件描述符表中，这是一个大于 0 的整数。 失败：返回-1。
close 1#include &lt;unistd.h&gt; 2// 函数参数: fd 是文件描述符，是 open () 函数的返回值 3// 函数返回值：函数调用成功返回值 0, 调用失败返回 -1 4int close(int fd); read 1#include &lt;unistd.h&gt; 2ssize_t read(int fd, void *buf, size_t count); 参数 fd: 文件描述符，open()函数的返回值，通过这个参数定位打开的磁盘文件 buf: 是一个传出参数，指向一块有效的内存，用于存储从文件中读出的数据 传出参数：类似于返回值，将变量地址传递给函数，函数调用完毕，地址中就有数据了 count: buf指针指向的内存的大小，指定可以存储的最大字节数 返回值 大于 0: 从文件中读出的字节数，读文件成功 等于 0: 代表文件读完了，读文件成功 -1: 读文件失败了
write 1#include &lt;unistd.h&gt; 2ssize_t write(int fd, const void *buf, size_t count); 参数 fd: 文件描述符，open () 函数的返回值，通过这个参数定位打开的磁盘文件 buf: 指向一块有效的内存地址，里边有要写入到磁盘文件中的数据 count: 要往磁盘文件中写入的字节数，一般情况下就是 buf 字符串的长度，strlen (buf) 返回值 大于 0: 成功写入到磁盘文件中的字节数 -1: 写文件失败了
lseek 系统函数 lseek 的功能是比较强大的，我们既可以通过这个函数移动文件指针，也可以通过这个函数进行文件的拓展。这个函数的原型如下:1#include &lt;sys/types.h&gt; 2#include &lt;unistd.h&gt; 3 4off_t lseek(int fd, off_t offset, int whence); 参数 fd: 文件描述符，open () 函数的返回值，通过这个参数定位打开的磁盘文件 offset: 偏移量，需要和第三个参数配合使用 whence: 通过这个参数指定函数实现什么样的功能
SEEK_SET: 从文件头部开始偏移 offset 个字节 SEEK_CUR: 从当前文件指针的位置向后偏移 offset 个字节 SEEK_END: 从文件尾部向后偏移 offset 个字节 返回值 成功：文件指针从头部开始计算总的偏移量 失败: -1
移动文件指针 通过对 lseek 函数第三个参数的设置，经常使用该函数实现如下几个功能， 如下所示：1// 文件指针移动到文件头部 2lseek(fd, 0, SEEK_SET); 3 4// 得到当前文件指针的位置 5lseek(fd, 0, SEEK_CUR); 6 7// 得到文件总大小 8lseek(fd, 0, SEEK_END); 假设使用一个下载软件进行一个大文件下载，但是磁盘很紧张，如果不能马上将文件下载到本地，磁盘空间就可能被其他文件占用了，导致下载软件下载的文件无处存放。那么这个文件怎么解决呢？
我们可以在开始下载的时候先进行文件拓展，将一些字符写入到目标文件中，让拓展的文件和即将被下载的文件一样大，这样磁盘空间就被成功抢到手，软件就可以慢悠悠的下载对应的文件了 使用 lseek 函数进行文件拓展必须要满足一下条件：
文件指针必须要偏移到文件尾部之后， 多出来的就需要被填充的部分。 文件拓展之后，必须要使用 write() 函数进行一次写操作（写什么都可以，没有字节数要求）。
举例:
1// lseek.c 2// 拓展文件大小 3#include &lt;stdio.h&gt; 4#include &lt;fcntl.h&gt; 5#include &lt;unistd.h&gt; 6 7int main() 8{ 9 int fd = open(&#34;hello.txt&#34;, O_RDWR); 10 if(fd == -1) 11 { 12 perror(&#34;open&#34;); 13 return -1; 14 } 15 16 // 文件拓展, 一共增加了 1001 个字节 17 lseek(fd, 1000, SEEK_END); 18 write(fd, &#34; &#34;, 1); 19 20 close(fd); 21 return 0; 22} truncate/ftruncate truncate/ftruncate这两个函数的功能是一样的，可以对文件进行拓展也可以截断文件。使用这两个函数拓展文件比使用 lseek 要简单。这两个函数的函数原型如下：
1// 拓展文件或截断文件 2#include &lt;unistd.h&gt; 3#include &lt;sys/types.h&gt; 4 5int truncate(const char *path, off_t length); 6	- 7int ftruncate(int fd, off_t length); ]]></content>
  </entry>
  
  <entry>
    <title>QSortFilterProxyModel</title>
    <url>/yfmff/yfmff.github.io.git/post/qt/qtproxy/</url>
    <categories><category>qt</category>
    </categories>
    <tags>
      <tag>qt-Model-View</tag>
    </tags>
    <content type="html"><![CDATA[简介 QsortFilterProxyModel类用来为model和view之间提供强大的排序和过滤支持。如它的名字一般，它本身是一个模型，用于排序和筛选。但是它本身不保存任何数据。它的一个基本用法如下：
1QTreeView *treeView = new QTreeView; 2MyItemModel *sourceModel = new MyItemModel(this); 3QSortFilterProxyModel *proxyModel = new QSortFilterProxyModel(this); 4proxyModel-&gt;setSourceModel(sourceModel); //将model放入代理中 5treeView-&gt;setModel(proxyModel); //在视图中安装代理 自定义排序 自定义排序需要子类化QsortFilterProxyModel,然后重写lessThan()。 如果重写了lessThan(),那么就不会再调用model的sort方法了.以下是一个例子：
1bool SortFilterProxyModel::lessThan(const QModelIndex &amp;source_left, const QModelIndex &amp;source_right) const 2{ 3 //通过当前视图中的index位置获取model中实际的数据 4 QVariant leftData = sourceModel()-&gt;data(source_left); 5 QVariant rightData = sourceModel()-&gt;data(source_right); 6 switch ( source_left.column() ) 7 { 8 case 0 : //序号,需要判断数字 9 case 3 : //信号ID,需要判断数字 10 return leftData.toInt() &lt; rightData.toInt(); 11 break; 12 default : //其它,只判断字符串 13 return leftData.toString() &lt; rightData.toString(); 14 break; 15 } 16 17 return true; 18} 除了排序外，QSortFilterProxyModel还可以用来隐藏与某个过滤器不匹配的项。使用QRegExp对象指定筛选器，并将筛选器应用于给定列的每个项的filterRole() （默认情况下为Qt::DisplayRole）。QRegExp对象可用于匹配正则表达式、通配符模式或固定字符串。
过滤 QSortFilterProxyModel提供了丰富的函数用于过滤，我们可以根据需要选择。
方法1 使用setFilterKeyColumn() 过滤列。 通过void QsortFilterProxyModel::setFilterRegExp(const QRegExp &amp;regExp) 来设置 FilterProxyModel 的过滤器. 通过QsortFilterProxyModel::setFilterKeyColumn(int) 来过滤某一列。 要更改大小写匹配,可以通过 QsortFilterProxyModel::sortCaseSensitivity() 来设置。 示例代码：
1QTableView *view = new QTableView; 2MyItemModel *sourceModel = new MyItemModel(this); 3QSortFilterProxyModel *proxyModel = new QSortFilterProxyModel(this); 4proxyModel-&gt;setSourceModel(sourceModel); //将model放入代理中 5view-&gt;setModel(proxyModel); //在视图中安装代理 6 7QRegExp regExp(&#34;^(-?\\d+)(\\.\\d+)?$&#34;, Qt::CaseSensitive, QRegExp::RegExp); 8//通过^(-?\d+)(\.\d+)?$来匹配整数 9proxyModel-&gt;setFilterRegExp(regExp); //安装过滤器 10 11proxyModel-&gt;setFilterKeyColumn(0); 12proxyModel-&gt;setFilterKeyColumn(2); //将第一列和第三列同时是整数的数据显示出来. 这样只能&quot;与方式&quot;显示model,要第一列和第三列公共是整数的才能显示出来,不能实现&quot;或方式&quot;显示。方法2 以实现&quot;只要第一列有整数或者第三列有整数的都显示出来&quot;为例,首先需要子类化QsortFilterProxyModel类,然后重写filterAcceptsRow() 或者 filterAcceptsColumn() 函数. 由于筛选第一列和第三列,列号是明确的,而行号是未知的, 所以我们只重写filterAcceptsRow()函数。 示例代码：
1bool SortFilterProxyModel::filterAcceptsRow(int source_row, const QModelIndex &amp;source_parent) const 2{ //获取model中实际的数据 3 QString dataColumn1 = sourceModel()-&gt;index(source_row, 0, source_parent).data(Qt::DisplayRole).toString(); 4 QString dataColumn3 = sourceModel()-&gt;index(source_row, 2, source_parent).data(Qt::DisplayRole).toString(); 5 if(dataColumn1.contains(this-&gt;filterRegExp())) 6 { 7 return true; 8 } 9 else if(dataColumn3.contains(this-&gt;filterRegExp())) 10 { 11 return true; 12 } 13 return false; 14} 然后创建SortFilterProxyModel类时,只需要安装过滤器即可:
1SortFilterProxyModel *proxyModel = new SortFilterProxyModel(); 2proxyModel-&gt;setSourceModel(sourceModel); //将model放入代理中 3treeView-&gt;setModel(proxyModel); //在视图中安装代理 4proxyModel-&gt;setFilterRegExp(&#34;^(-?\\d+)(\\.\\d+)?$&#34;); //安装过滤器 每当过滤格式改变,则 setFilterRegExp() 重新更新过滤器即可。 如果过滤方式改变了,比如从过滤第1列变成了过滤第2列,需要调用 invalidateFilter() 函数,使之前的过滤失效,激活当前过滤。]]></content>
  </entry>
  
  <entry>
    <title>Qt 正则表达式</title>
    <url>/yfmff/yfmff.github.io.git/post/qt/qtregexp/</url>
    <categories><category>qt</category>
    </categories>
    <tags>
      <tag>qt-Model-View</tag>
    </tags>
    <content type="html"><![CDATA[QRegExp Qt5.0之前版本，正则表达式是QRegExp。构造函数如下：
1QRegExp::QRegExp(const QString &amp;pattern, Qt::CaseSensitivity cs = Qt::CaseSensitive, QRegExp::PatternSyntax syntax); 其中QRegExp::PatternSyntax syntax用于解释模式含义的语法,默认选择QRegExp::RegExp。
QRegExp::RegExp 常见元字符:
. 匹配除换行符以外的任意字符 \w 匹配字母或数字或下划线或汉字 \s 匹配任意的空白符 \d 匹配数字 \b 匹配单词的开始或结束 ^ 匹配字符串的开始 $ 匹配字符串的结束 [] 匹配括号内输入的任意字符. 例如[123],只要是1, 2 ,3,12,23都满足 () 表示一个集合,用于提取匹配的字符串,表达式中有几个()就有几个相应的匹配字符串。 限定重复元字符:
* 重复零次或更多次 例如, 1*2可以为任意数量个1(甚至没有), 后面跟一个2 + 重复一次或更多次 例如, 1+2必须为一个或多个1, 后跟一个2 ? 重复零次或一次 例如,-?1 必须为1,或者-1 {n} 重复n次 例如 1?2可以为2或12 {n,} 重复n次或更多次 {n,m} 重复n到m次 反义元字符：
\W 匹配任意不是字母，数字，下划线，汉字的字符 \S 匹配任意不是空白符的字符 \D 匹配任意非数字的字符 \B 匹配不是单词开头或结束的位置 [^x] 匹配除了x以外的任意字符 [^aeiou] 匹配除了aeiou这几个字母以外的任意字符 如果想查找元字符本身的话，就得使用\来取消这些字符的特殊意义,比如: deerchao\.cn匹配deerchao.cn使用示例：
1^\d{5,12}$ // 匹配数字(比如qq号),必须为5位到12位数字 2 3&#34;^-?\d+$&#34;　//匹配整数,可以为负数 4 5&#34;^(-?\d+)(\.\d+)?$&#34;　//匹配浮点数 6&#34;^\d+$&#34;　//匹配非负整数 7 8&#34;^\d+(\.\d+)?$&#34;　//匹配非负整数 9 10&#34;^[A-Za-z]+$&#34; //匹配大小写英文字母 QRegExp::Wildcard 通配符只有 ？、* 、[] 三种。
? 匹配任意单个字符,和 RegExp的&quot;.&ldquo;相同 * 匹配任意一个字符序列. 和RegExp的 .* 相同 [] 匹配一个定义的字符集合. 例如, [a-zA-Z.]可以匹配 a到z之间任意一个字符和. [^a]匹配出小写a以外的字符. QRegExp::FixedString 这意味着要匹配的模式被解释为普通字符串，即特殊字符（例如反斜杠）不被转义使用示例 1/*只能匹配整数,\\d表示转义字符，C++用\\来表示\ */ 2 QRegExp regx(&#34;^-?\\d+$&#34;); 3 QValidator *validator = new QRegExpValidator(regx, this ); 4 ui-&gt;lineEdit-&gt;setValidator( validator ); //设置lineEdit只能输入数字 5 6 QStringList list; 7 list&lt;&lt;&#34;123&#34;; 8 list&lt;&lt;&#34;123A456&#34;; 9 list&lt;&lt;&#34;555a&#34;; 10 list&lt;&lt;&#34;89d&#34;; 11 list&lt;&lt;&#34;3695x&#34;; 12 list&lt;&lt;&#34;69&#34;; 13 list&lt;&lt;&#34;78.9&#34;; 14 15 foreach(QString s, list.filter(regx)){ //匹配字符串list 16 qDebug()&lt;&lt;s; //过滤数字,只打印123、69 17 } 18 19 20 //检索str时 21 QString str = &#34;-123&#34;; 22 qDebug()&lt;&lt;str.contains(regx); //返回true 23 24 QRegExp regx2(&#34;-?\\d+&#34;); 25 str = &#34;number : -123xx&#34;; 26 qDebug()&lt;&lt;str.indexOf(regx2); //&#34;-123&#34;的位置在索引9上, QRegExp的缺点就是匹配到起始索引后,无法得到终点索引. QRegularExpression QRegularExpression是Qt 5.0引进的，修复了很多bug，提高了效率，使用时建议使用QRegularExpression。使用时,只需要构造QRegularExpression类,然后通过match函数来匹配目标字符串即可,match函数如下所示:
1QRegularExpressionMatch match(const QString &amp;subject, //被匹配的目标字符串 2 int offset = 0, //匹配的字符串起始位置 3 MatchType matchType = NormalMatch, //匹配类型 4 MatchOptions matchOptions = NoMatchOption) const;// 匹配选项 QRegularExpressionMatch类,常用函数如下所示:
1bool hasMatch() : 判断是否匹配 2QString captured(int nth = 0) : 获取匹配到的第nth个集合段. 3int capturedStart(int nth = 0) : 获取匹配到的第nth个集合段的起始索引 4int capturedLength(int nth = 0) ：获取匹配到的第nth个集合段的长度 5int capturedEnd(int nth = 0) : 获取匹配到的第nth个集合段的终点索引 示例
1bool hasMatch() : 判断是否匹配 2QString captured(int nth = 0) : 获取匹配到的第nth个集合段. 3int capturedStart(int nth = 0) : 获取匹配到的第nth个集合段的起始索引 4int capturedLength(int nth = 0) ：获取匹配到的第nth个集合段的长度 5int capturedEnd(int nth = 0) : 获取匹配到的第nth个集合段的终点索引 打印结果：
1index= 0 ,str= &#34;1999/12/11&#34; ,offset: 4 14 2 3index= 1 ,str= &#34;1999&#34; ,offset: 4 8 4 5index= 2 ,str= &#34;12&#34; ,offset: 9 11 6 7index= 3 ,str= &#34;11&#34; ,offset: 12 14 因为() 表示一个集合,所以除了匹配(\d+)/(\d+)/(\d+)外,还会再次匹配3个圆括号里的内容,所以就有4个captured
]]></content>
  </entry>
  
  <entry>
    <title>Qt 模型-视图：自定义视图</title>
    <url>/yfmff/yfmff.github.io.git/post/qt/qtcusview/</url>
    <categories><category>qt</category>
    </categories>
    <tags>
      <tag>qt-Model-View</tag>
    </tags>
    <content type="html"><![CDATA[
Qt常见视图类：QAbstractItemView、QListView、QTableView、QTreeView，但是这些类较为基础，当我们需要实现一些额外功能时，可自定义视图。
自定义视图的基本原则 视图需要自行绘制，通常在paintEvent() 函数内完成，所以除了必须实现的纯虚函数外，paintEvent() 也应重新实现。另外若需要对单元格进行重新绘制、更新滚动条等，还需要重新实现resizeEvent() 函数。 自定义视图需要完成显示的单元格的大小和位置的计算、单元格轮廓线的绘制、滚动的计算、对单元格的选择作出处理、若有必要还需要绘制标头。 另外需要记住的是视图就是一个QFrame ，也就是说直接使用show() 显示视图，那么视图只是一个什么也没有的窗口而已，窗口中的内容需要由程序员设计，也就是说你也可以完全不继承QAbstractItemView类，而子类化QFrame类来实现视图中内容的绘制，当然这样会失去对QAbstractItemView类中由Qt已实现的内部函数的使用。 QAbstractItemView中函数：
1virtual void setSelection(const QRect &amp;rect, QItemSelectionModel::SelectionFlags flags); 将选择标flags应用于矩形rect中的项目，或者rect触及的项目。在实现自己的视图时，该函数应该调用selectionModel()-&gt;select(selection,flag)，其中selection要么是空的QModelIndex，要么是包含在rect中的所有项目的QItemSelection。
1virtual QRect visualRect(const QModelIndex &amp;index) const; 返回由索引index所指项目占用视口上的矩形（包括位置和大小），若项目显示在多个区域，则该函数应返回包含索引的主区域，而部署索引可能包含、触及或者导致绘图的完整区域。
1virtual bool isIndexHidden(const QModelIndex &amp;index) const; 若索引index所指的项目隐藏在视图中，则返回true。
1virtual QModelIndex moveCursor(QAbstractItemView::CursorAction cursorAction, Qt::KeyboardModifiers modifiers); 根据cursorAction和键盘修饰符modifiers，返回指向视图中的下一个对象的模型索引。枚举cursorAction见下表：
QAbstractItemView::CursorAction 含义 QAbstractItemView::MoveUp 移动至当前项目上方的项目 QAbstractItemView::MoveDown 移动至当前项目下方的项目 QAbstractItemView::MoveLeft 移动至当前项目左侧的项目 QAbstractItemView::MoveRight 移动至当前项目右侧的项目 QAbstractItemView::MoveHome 移动至左上角的项目 QAbstractItemView::MoveEnd 移动至右下角的项目 QAbstractItemView::MovePageUp 在当前项目上方移动一页 QAbstractItemView::MovePageDown 在当前项目下方移动一页 QAbstractItemView::MoveNext 移动至当前项目之后的项目 QAbstractItemView::MovePrevious 移动至当前项目之前的项目 实例 使用paintEvent() 函数完成由visualRect() 函数返回的矩形的轮廓线及其数据项的绘制，其中数据项调用委托绘制。
1#include &lt;QApplication&gt; 2#include&lt;QAbstractItemView&gt; 3#include&lt;QPainter&gt; 4#include&lt;QStandardItemModel&gt; 5#include&lt;QLabel&gt; 6 7class myview :public QAbstractItemView 8{ 9public: 10 // 以下函数用于计算项目所需占据的矩形 11 virtual QRect visualRect(const QModelIndex &amp;index) const 12 { 13 // 矩形大小是110*33 14 return QRect(index.column()*110,index.row()*33+20,110,33); 15 } 16 17 // 以下函数返回鼠标光标位置的项目索引 18 virtual QModelIndex indexAt(const QPoint &amp;point) const 19 { 20 // 参数point包含了坐标信息（视图） 21 int r=(point.y()-20)/33; 22 int c=(point.x())/110; 23 return model()-&gt;index(r,c); 24 } 25 26 // 以下两个函数用于处理对项目的选中，当选择视图中的项目时，Qt会调用 27 virtual void setSelection(const QRect &amp;rect, QItemSelectionModel::SelectionFlags flags) 28 { 29 int r=(rect.y()-20)/33; 30 int c=(rect.x())/110; 31 selectionModel()-&gt;select(model()-&gt;index(r,c),flags); 32 } 33 34 virtual QRegion visualRegionForSelection(const QItemSelection &amp;selection) const 35 { 36 // 用于计算索引被选择的项目所占据的区域 37 return QRegion(); 38 } 39 40 // 以下函数用于计算视图的滚动 41 int horizontalOffset() const {return 0;} 42 43 int verticalOffset() const {return 0;} 44 45 void scrollTo(const QModelIndex&amp; index,ScrollHint hint=EnsureVisible){} 46 47 // 以下函数用于处理键盘按键 48 virtual QModelIndex moveCursor(QAbstractItemView::CursorAction cursorAction, Qt::KeyboardModifiers modifiers) 49 { 50 return QModelIndex(); 51 } 52 53 // 以下函数用于绘制视图外观，必须实现，否则什么都不会显示 54 void paintEvent(QPaintEvent *event) 55 { 56 QPainter pt(viewport()); 57 // 使用 QAbstractItemView::viewoptions()获取需要绘制的图形信息 58 QStyleOptionViewItem po=viewOptions(); 59 // 循环遍历模型大小 60 for(int r=0;r&lt;model()-&gt;rowCount();++r) 61 { 62 for(int c=0;c&lt;model()-&gt;columnCount();++c) 63 { 64 QModelIndex i=model()-&gt;index(r,c); 65 QRect rect=visualRect(i); // 获取索引i所指项目的矩形 66 po.rect=visualRect(i); 67 68 // 处理项目被选择的情形 69 if(selectionModel()-&gt;isSelected(i)) 70 { 71 po.state |= QStyle::State_Selected; 72 } 73 74 //使用代理绘制数据项，可使用自定义的代理（如果已经添加） 75 itemDelegate()-&gt;paint(&amp;pt,po,i); 76 77 // 以下代码用于绘制项目的轮廓线 78 pt.save(); 79 pt.setPen(QPen(QColor(111,1,1))); 80 pt.drawLine(rect.bottomLeft(),rect.bottomRight()); 81 pt.drawLine(rect.bottomRight(),rect.topRight()); 82 pt.restore(); 83 } 84 } 85 } 86}; 87 88 89class B:public QWidget 90{ 91 Q_OBJECT 92public: 93 QStandardItemModel* d; 94 myview* pv; 95 B(QWidget* p=0):QWidget(p) 96 { 97 d=new QStandardItemModel(3,3); 98 pv= new myview; 99 100 d-&gt;setData(d-&gt;index(0,0),&#34;AAA&#34;); 101 d-&gt;setData(d-&gt;index(0,1),&#34;ASA&#34;); 102 d-&gt;setData(d-&gt;index(1,0),&#34;BAA&#34;); 103 d-&gt;setData(d-&gt;index(1,1),&#34;BBB&#34;); 104 d-&gt;setData(d-&gt;index(1,2),&#34;ACB&#34;); 105 d-&gt;setData(d-&gt;index(2,0),&#34;CCC&#34;); 106 107 QLabel* pp=new QLabel(&#34;111&#34;,pv); 108 pp-&gt;setAutoFillBackground(true); 109 pp-&gt;resize(110,20); 110 111 QLabel* pp1=new QLabel(&#34;222&#34;,pv); 112 pp-&gt;setAutoFillBackground(true); 113 pp-&gt;resize(110,20); 114 pp1-&gt;move(111,0); 115 116 QLabel* pp2=new QLabel(&#34;333&#34;,pv); 117 pp-&gt;setAutoFillBackground(true); 118 pp-&gt;resize(110,20); 119 pp2-&gt;move(222,0); 120 pv-&gt;setModel(d); 121 pv-&gt;resize(333,222); 122 pv-&gt;show(); 123 } 124 125}; 126 127int main(int argc, char *argv[]) 128{ 129 QApplication a(argc, argv); 130 B w; 131 return a.exec(); 132} 效果图： ]]></content>
  </entry>
  
  <entry>
    <title>Qt 模型-视图：自定义委托</title>
    <url>/yfmff/yfmff.github.io.git/post/qt/qtdelegate/</url>
    <categories><category>qt</category>
    </categories>
    <tags>
      <tag>qt-Model-View</tag>
    </tags>
    <content type="html"><![CDATA[
QAbstractItemDelegate基本原理 QAbstractItemDelegate继承自QObject，Qt中委托用于显示视图中的单个项目，并处理模型数据的编辑。QAbstractDelegate的子类QItemDelegate和QStyleItemDelegate是Qt提供的对QAbstractDelegate类的默认实现。
若需要以自定义方式渲染项目，则必须重新实现paint()和sizeHint()函数。可使用如下两种方法实现自定义的编辑： 1)、创建一个编辑器部件，并将其设置为项目的编辑器，此方法必须重新实现 createEditor() 函数，并使用 setEditorData() 函数从模型中获取数据用于编辑器，使用 setModelData() 把编辑器的内容写入模型中。 2)、重新实现 editorEvent() 函数，直接处理用户事件。QAbstractItemDelegate类中的函数 QAbstractItemDelegate 类中的函数都是虚函数，这些函数的参数都附带有必要的信息，比如对于 paint() 函数的index参数，就是表示需要绘制的模型的索引，且index.data() 函数包含有来自模型的数据。在重新实现这些虚函数时，应合理使用这些参数所附带的信息。函数： 1// 若要提供自定义的渲染，则必须重新实现此函数。 2// 使用**Painter**和外观**option**来渲染索引**index**指定的项。若重新实现此函数，还必须重新实现**sizeHint()**。 3virtual void paint(QPainter *painter, const QStyleOptionViewItem &amp;option, const QModelIndex &amp;index) const； 4virtual QSize sizeHint(const QStyleOptionViewItem &amp;option, const QModelIndex &amp;index) const; 5 6// 返回用于编辑索引index所指数据项的编辑器。 7//index包含正在使用的模型的信息。parent表示编辑器的父部件，项目选项由option指定。默认实现返回0。 8virtual QWidget *createEditor(QWidget *parent, const QStyleOptionViewItem &amp;option, const QModelIndex &amp;index) const; 9 10// 设置编辑器数据 11virtual void setEditorData(QWidget *editor, const QModelIndex &amp;index) const; 12 13// 将编辑器数据写到模型中 14virtual void setModelData(QWidget *editor, QAbstractItemModel *model, const QModelIndex &amp;index) const; 15 16// 根据option中的矩形，更新索引index所指项目的编辑器的几何尺寸，该函数决定编辑器在视图中的位置和大小。 17virtual void updateEditorGeometry(QWidget *editor, const QStyleOptionViewItem &amp;option, const QModelIndex &amp;index) const; 18 19// 当编辑器editor不再需要编辑索引index所指的数据项且应该被销毁时调用。该函数用于销毁editor。 20virtual void destroyEditor(QWidget *editor, const QModelIndex &amp;index) const; 21 22// 在开始编辑项时会调用，event为触发的事件，model、index分别是这个被编辑项目的模型和索引，option为渲染项目的选项。 23// 即使鼠标事件没有开始编辑该项目，也UI被发送给editorEvent，比如在当前项按下鼠标右键试图打开右键菜单，默认返回false 24virtual bool editorEvent(QEvent *event, QAbstractItemModel *model, const QStyleOptionViewItem &amp;option, const QModelIndex &amp;index); 25 26// 发生帮助事件时会调用该函数，若委托处理此事件则返回true。 27// 对于成功处理的QEvennt::ToolTip和QEvent::WhatsThis事件，根据系统配置显示相关窗口。 28virtual bool helpEvent(QHelpEvent *event, QAbstractItemView *view, const QStyleOptionViewItem &amp;option, const QModelIndex &amp;index); 信号 1// 当编辑器editor编辑完成后并将其写回模型时，必须发送此信号。 2void commitData(QWidget *editor); 3 4// 当索引的index的sizeHint()变化时，必须发送此信号，视图自动连接此信号，并重新布局。 5void sizeHintChanged(const QModelIndex &amp;index); 6 7void closeEditor(QWidget *editor, QAbstractItemDelegate::EndEditHint hint = NoHint); closeEditor：用户使用编辑器editor完成编辑时，发送此信号。hint为委托提供了编辑完成后影响模型和视图行为的方式，可以指示组件接下来执行什么操作，比如hint为EditNextItem，则 视图应使用委托打开下一个项目的编辑器。枚举EndEditHint值见下表。QAbstractItemDelegate::EndEditHint 含义 QAbstractItemDelegate::NoHint 什么都不做 QAbstractItemDelegate::EditNextItem 在下一个项上打开编辑器 QAbstractItemDelegate::EditPreviousItem 在上一个项上打开编辑器 AbstractItemDelegate::SubmitModelCache 若模型缓存数据，则把数据写入底层数据存储 QAbstractItemDelegate::RevertModelCache 若模型缓存数据，则放弃缓存数据并将其替换为底层存储中的数据 QStyleOptionViewItem QStyleOptionViewItem类继承自QStyleOption。
基本原理 Qt内置的部件的外观几乎都是由QStyle类的成员函数进行绘制的，使用这些函数绘制部件时需要向函数提供一些所需绘制图形元素的信息，而这些信息是由QStyleOption类及其子类进行描述的，QStyleOption类的不同子类描述了不同图形元素所需的信息，比如QStyleOptionButton描述了绘制按钮所需的有关信息等。因此模型/视图结构中的QStyleOptionViewItem类描述了绘制数据项所需的有关信息。
QStyleOptionViewItem成员变量 项目的装饰（decoration）通常指的是图标，与Qt::DecorationRole对应变量 含义 QBrush backgroundBrush 绘制项背景 Qt::CheckState checkState 被选中为true Qt::Alignment decorationAlignment 项的对齐方式，默认左对齐 QStyleOptionViewItem::Position decorationPosition 项目装饰位置，默认左对齐 QSize decorationSize 默认装饰大小 Qt::Alignment displayAlignment 项显示值的对齐方式 QStyleOptionViewItem::ViewItemFeatures features 描述项目特征 QFont font 项的字体 QIcon icon 绘制在项的图标 QModelIndex index 需要绘制的模型的索引 bool showDecorationSelected 项被选中是否突出显示装饰 QString text 在项目中绘制的文本 Qt::TextElideMode textElideMode 当项显示的文本太长时，省略号出现的位置 QStyleOptionViewItem::ViewItemPosition viewItemPosition 项目相对于其他项的位置 QStyleOptionViewItem::PositionQStyleOptionViewItem::Position 含义 QStyleOptionViewItem::Left 文本左侧 QStyleOptionViewItem::Right 文本右侧 QStyleOptionViewItem::Top 文本上侧 QStyleOptionViewItem::Bottom 文本底侧 QStyleOptionViewItem::ViewItemFeaturesQStyleOptionViewItem::ViewItemFeatures 含义 QStyleOptionViewItem::None 正常的项 QStyleOptionViewItem::WrapText 项中文本可以换行 QStyleOptionViewItem::Alternate 项渲染方式 QStyleOptionViewItem::HasCheckIndicator 项具有可选标志符（checkbox） QStyleOptionViewItem::HasDisplay 项具有Qt::DisplayRole QStyleOptionViewItem::HasDecoration 项具有Qt::DecorationRole QStyleOptionViewItem::ViewItemPositionQStyleOptionViewItem::ViewItemPosition 含义 QStyleOptionViewItem::Invalid 未知，忽略 QStyleOptionViewItem::Beginning 项目位于行的开头 QStyleOptionViewItem::Middle 项目位于行的中间 QStyleOptionViewItem::End 项目位于行的结尾 QStyleOptionViewItem::OnlyOne 项目唯一（改行只有这一个） 除以上成员变量外，从QStyleOption继承而来的成员变量对项目的绘制也有影响，其中有两个比较重要，如下：
1QRect rect;// 表示项目的区域 2 3// 绘制控件时的样式状态，state用于指示控件是否启用 4// 是否被选择等状态 5QStyle::State state; 实例1 mydelegate实现
1#include &#34;mydelegate.h&#34; 2#include&lt;QApplication&gt; 3 4mydelegate::mydelegate(QObject *parent) : QAbstractItemDelegate(parent){} 5QSize mydelegate::sizeHint(const QStyleOptionViewItem &amp;option, const QModelIndex &amp;index) const{return QSize(0,0);} 6 7void mydelegate::paint(QPainter *painter, const QStyleOptionViewItem &amp;p1, const QModelIndex &amp;index) const 8{ 9 // 为第一行第一列的项目绘制一个进度条 10 if(index.row() == 1 &amp;&amp; index.column() ==1) 11 { 12 int i=index.data().toInt(); 13 QStyleOptionProgressBar p; 14 p.rect = p1.rect; 15 p.minimum=0; 16 p.maximum=100; 17 p.progress=i; 18 p.text=QString::number(i)+&#34;%&#34;; 19 p.textVisible=true; 20 21 // 使用QStyle::drawControl函数绘制进度条 22 QApplication::style()-&gt;drawControl(QStyle::CE_ProgressBar,&amp;p,painter); 23 } 24 else if(index.row() == 2 &amp;&amp; index.column() ==1) // 第2行第一列的项目 25 { 26 QStyleOptionViewItem p; 27 p.index=index; 28 p.rect=p1.rect; 29 30 // 显示图标，需要设置 31 p.features=QStyleOptionViewItem::HasDecoration|QStyleOptionViewItem::HasDisplay; 32 p.decorationSize=QSize(55,55); 33 p.icon=index.data().value&lt;QIcon&gt;(); 34 35 p.state =p1.state; 36 p.showDecorationSelected=true; 37 p.displayAlignment=Qt::AlignLeft; 38 p.text=index.data().toString(); 39 QApplication::style()-&gt;drawControl(QStyle::CE_ItemViewItem,&amp;p,painter); 40 } 41 else if(index.row() == 2 &amp;&amp; index.column() ==0)// 第2行第0列的项目(绘制于其他地方) 42 { 43 QStyleOptionViewItem p; 44 p.features=QStyleOptionViewItem::HasDisplay|QStyleOptionViewItem::HasCheckIndicator; 45 p.rect=QRect(199,144,111,44); 46 p.state=p1.state; 47 p.showDecorationSelected=true; 48 p.text=index.data().toString(); 49 p.backgroundBrush=QBrush(QColor(1,111,1)); 50 QFont f; 51 f.setPixelSize(22); 52 p.font=f; 53 p.displayAlignment=Qt::AlignLeft|Qt::AlignCenter; 54 QApplication::style()-&gt;drawControl(QStyle::CE_ItemViewItem,&amp;p,painter); 55 } 56 else 57 { 58 // 其他项目 59 QStyleOptionViewItem p; 60 p.features=QStyleOptionViewItem::HasDisplay; 61 p.index=index; 62 p.rect=p1.rect; 63 p.state=p1.state; 64 p.showDecorationSelected=true; 65 p.text=index.data().toString(); 66 QApplication::style()-&gt;drawControl(QStyle::CE_ItemViewItem,&amp;p,painter); 67 } 68} mywindow头文件
1#ifndef MYWINDOW_H 2#define MYWINDOW_H 3 4#include &lt;QWidget&gt; 5#include&lt;QStandardItemModel&gt; 6#include&lt;QTableView&gt; 7#include&#34;mydelegate.h&#34; 8 9class mywindow : public QWidget 10{ 11 Q_OBJECT 12public: 13 explicit mywindow(QWidget *parent = nullptr); 14 15public: 16 QStandardItemModel* d; 17 QTableView* pv2; 18 mydelegate* pt; 19signals: 20 21}; 22 23#endif // MYWINDOW_H mywindow实现
1#include &#34;mywindow.h&#34; 2 3mywindow::mywindow(QWidget *parent) : QWidget(parent) 4{ 5 pv2=new QTableView(this); 6 pv2-&gt;move(22,22); 7 pv2-&gt;resize(333,222); 8 d=new QStandardItemModel(3,3,this); 9 10 // 添加数据 11 d-&gt;setData(d-&gt;index(0,0,QModelIndex()),&#34;111&#34;,Qt::DisplayRole); 12 d-&gt;setData(d-&gt;index(1,0,QModelIndex()),222); 13 d-&gt;setData(d-&gt;index(1,1,QModelIndex()),33); 14 d-&gt;setData(d-&gt;index(2,0,QModelIndex()),&#34;xxxx&#34;); 15 d-&gt;setData(d-&gt;index(2,1,QModelIndex()),QIcon(&#34;F:/1i.png&#34;),Qt::DecorationRole); 16 d-&gt;setData(d-&gt;index(2,1,QModelIndex()),11); 17 d-&gt;setData(d-&gt;index(2,1,QModelIndex()),11,Qt::ToolTipRole); 18 d-&gt;setData(d-&gt;index(2,2,QModelIndex()),333); 19 pv2-&gt;setModel(d); 20 21 pt=new mydelegate(this); 22 pv2-&gt;setItemDelegate(pt); 23} main.cpp
1#include &#34;widget.h&#34; 2 3#include &lt;QApplication&gt; 4#include&lt;mywindow.h&gt; 5 6int main(int argc, char *argv[]) 7{ 8 QApplication a(argc, argv); 9 mywindow w; 10 w.resize(444,355); 11 w.show(); 12 return a.exec(); 13} 效果如下： 实例2 只需要将下列代码，复制到mydelegate头文件和cpp文件中即可。 mydelegate头文件
1 virtual void destroyEditor(QWidget *editor, const QModelIndex &amp;index) const; 2 3 virtual void updateEditorGeometry(QWidget *editor, const QStyleOptionViewItem &amp;option, const QModelIndex &amp;index) const; 4 5 virtual void setModelData(QWidget *editor, QAbstractItemModel *model, const QModelIndex &amp;index) const; 6 7 virtual void setEditorData(QWidget *editor, const QModelIndex &amp;index) const; 8 9 virtual QWidget *createEditor(QWidget *parent, const QStyleOptionViewItem &amp;option, const QModelIndex &amp;index) const; mydelegate实现
1// 可以不实现，使用默认的也可以 2void mydelegate::destroyEditor(QWidget *editor, const QModelIndex &amp;index) const 3{ 4 delete editor; 5} 6 7// 设置编辑器的几何尺寸 8void mydelegate::updateEditorGeometry(QWidget *editor, const QStyleOptionViewItem &amp;option, const QModelIndex &amp;index) const 9{ 10 editor-&gt;setGeometry(option.rect); 11} 12 13// 重新setModelData将编辑器的数据写回模型 14void mydelegate::setModelData(QWidget *editor, QAbstractItemModel *model, const QModelIndex &amp;index) const 15{ 16 if(index.data().type()==QMetaType::QString||index.data().isNull()) 17 { 18 model-&gt;setData(index,((QLineEdit*)editor)-&gt;text()); 19 } 20 else 21 { 22 model-&gt;setData(index,((QSpinBox*)editor)-&gt;value()); 23 } 24} 25 26// 重写setEditorData以将单元格数据读入编辑器中 27void mydelegate::setEditorData(QWidget *editor, const QModelIndex &amp;index) const 28{ 29 if(index.data().type()==QMetaType::QString|| index.data().isNull()) 30 { 31 ((QLineEdit*)editor)-&gt;setText(index.data().toString()); 32 } 33 else 34 { 35 ((QSpinBox*)editor)-&gt;setValue(index.data().toInt()); 36 } 37} 38 39// 重新实现createEditor以便为每个单元格创建各自的编辑器 40QWidget *mydelegate::createEditor(QWidget *parent, const QStyleOptionViewItem &amp;option, const QModelIndex &amp;index) const 41{ 42 // 使用自定义的编辑器 43 QLineEdit* pe=new QLineEdit(parent); 44 QSpinBox* ps=new QSpinBox(parent); 45 pe-&gt;setObjectName(&#34;EEE&#34;); 46 ps-&gt;setObjectName(&#34;sss&#34;); 47 48 // 如果单元格的数据是文本或者无效数据，则使用pe编辑器进行编辑 49 if(index.data().type()==QMetaType::QString || index.data().isNull()) 50 { 51 pe-&gt;setFocusPolicy(Qt::TabFocus); 52 return pe; 53 } 54 else 55 { 56 ps-&gt;setMaximum(1000); 57 return ps;; 58 } 59} 实现的效果： ]]></content>
  </entry>
  
  <entry>
    <title>Qt 模型-视图：自定义模型</title>
    <url>/yfmff/yfmff.github.io.git/post/qt/qtcusmod/</url>
    <categories><category>qt</category>
    </categories>
    <tags>
      <tag>qt-Model-View</tag>
    </tags>
    <content type="html"><![CDATA[
Qt提供了常用的模型：QStringListModel、QStandardItemModel、QFileSystemModel、QSqlQueryModel等，但是这些模型只能满足基础的使用需要，有时项目上需要实现额外的功能点，此时就需要自定义模型。
通过Qt帮助文档可知，想要自定义模型，至少需要实现5个纯虚函数：index(), parent(),rowCount(), columnCount(),data()。如果你想通过表格更改原始数据，你还要实现：setData()。以下对常用函数进行解释：
index() 1virtual QModelIndex index(int row, int column, constQModelIndex &amp;parent = QModelIndex()) const; 该函数用于为模型中的每个数据项创建索引，创建索引需要使用createIndex() 函数，对于表格结构，只需向createIndex(row,column) 函数传递当前数据项所在的行号、列号及使用的数据的指针即可；对于列表结构，则列号始终为0，其余同表格结构；对于树形结构，需要向该函数传递当前数据项位于父索引中的行号、列号及使用的数据的指针。parent() 1virtual QModelIndex parent(const QModelIndex &amp;index) const; (父模型索引)的设计：因为表格结构中的所有单元格都属于同一个父索引之下，所以可把所有单元格都视为顶级节点，因此他们的父索引可以以无效模型索引作为父索引，因此parent()可以返回一个无效模型索引；对于列表结构的模型，同样只需返回一个无效模型索引即可；对树形结构模型，此步骤比较复杂，可以通过获取当前节点的父节点及其行号和列号，然后使用createIndex() 创建该父节点的索引。row/columnCount() 行数和列数的设计：比如对于3行4列的表格结构，columnCout()应返回4，rowCount()应返回3；对于列表结构，则因为列表只需要1列，所以columncout()应总是返回1，rowCount()返回该列表的行数；对于树形结构模型，则更复杂，需要根据当前父节点的情况进行判断，以返回该父节点拥有的列数和行数。data() 1virtual QVariant data(const QModelIndex &amp;index, int role = Qt::DisplayRole) const; 函数的返回值决定了视图上应显示的数据，也就是说在界面上用户看到的数据是由该函数返回的，若返回不当的值，则数据无法正常显示在视图上。data()函数会被视图类调用多次，视图每次都会向data传递一个不同的role(角色)参数值，然后视图根据data返回的值，设置该role的数据， 因此在设计data函数的返回值时，需要根据role的不同值返回不同的数据，以使视图正确的显示。如果没有需要返回的值，应该返回无效的QVarient，为不是返回0.setData() 1virtual bool setData(const QModelIndex &amp;index, const QVariant &amp;value, int role = Qt::EditRole) 设置索引index所引用数据项的值为value，其角色为role。设置成功则需要发送**dataChanged()**信号并返回True，否则返回False。 如果模型是可编辑的，则必须重新实现此函数。补充 QAbstractItemModel是所有模型类的基类，其常用函数：
1virtual Qt::ItemFlags flags(const QModelIndex &amp;index) const 返回索引index的数据项的标志组合，默认是Qt::ItemIsEnabled|Qt::ItemIsSelectable,重新实现该函数可控制数据项的属性（比如是否可选中，拖动等）。Qt::ItemFlag枚举见下表。Qt::ItemFlag 含义 Qt::NoItemFlags 无属性 Qt::ItemIsSelectable 可被选择 Qt::ItemIsEditable 可被编辑 Qt::ItemIsDragEnabled 可拖动 Qt::ItemIsDropEnabled 可被丢弃 Qt::ItemIsUserCheckable 可被用户选中或取消选中（checkbox） Qt::ItemIsEnabled 数据项启用（可显示），禁用（不显示） Qt::ItemIsAutoTristate 三态，该数据项的状态取决于子项的状态 Qt::ItemIsTristate 弃用 Qt::ItemNeverHasChildren 数据从来没有子项 Qt::ItemIsUserTristate 用户可循环改变三种状态 未完待续。。。
]]></content>
  </entry>
  
  <entry>
    <title>Qt 模型-视图：基本原理</title>
    <url>/yfmff/yfmff.github.io.git/post/qt/qtmodleview/</url>
    <categories><category>qt</category>
    </categories>
    <tags>
      <tag>qt-Model-View</tag>
    </tags>
    <content type="html"><![CDATA[
简介 Qt将视图和控制器组合在一起，从而形成模型/视图结构。模型直接与数据进行通信，并为视图和委托提供访问数据的接口。为了对用户的输入进行灵活的处理，Qt引入了委托Delegate(或代理)的概念，委托其实就是把用户输入的数据委托给Qt的某个部件处理，比如委托QSpinBox部件来处理用户输入的整数等。另外，委托还会绘制(或渲染)视图中的个别数据项。模型、视图、委托之间的通信使用Qt的信号和槽机制来完成。
基本运作逻辑是：源数据由模型 (Model) 读取，然后在视图 (View) 组件上显示和编辑，在界面上编辑修改的数据又通过模型保存到源数据。Model/View结构将数据模型和用户界面分离开来，分别用不同的实现，是一种显示和编辑数据的有效结构，在处理大型数据时尤其明显。Qt对模型/视图结构的具体实现 模型 Qt使用抽象类QAbstractItemModel来描述模型，所有的模型都是通过子类化该抽像类而实现的。Qt实现了一些标准的现成模型，下面是简介： QStringListModel：用于存储QString项目的列表。 QStandardItemModel：该模型可以被当作列表模型、表格模型、树模型来使用。 QFileSystemModel：该模型提供本地文件系统中的文件和目录信息，模型本身没有任何的数据项目。 QSqlQueryModel、QSqlTableModel、QSqlRelationalTableModel与数据库有关。视图 Qt使用抽象类QAbstractItemView来描述视图，所有的视图都是通过子类化该抽像类而实现的。Qt实现了一些标准的现成视图，比如QListView(列表视图)，QTableView(表格视图)，QTreeView(树视图)等。委托 Qt使用抽象类QAbstractItemDelegate来描述委托，Qt实现了两个委托类，QStyledItemDelegate和QItemDelegate，这两个委托之中只能使用其中一个，其区别在于QItemDelegate总是使用一种默认的样式绘制数据项，而QStyledItemDelegate使用当前的样式来绘制数据项，通常使用的是QStyledItemDelegate。Qt默认使用QStyledItemDelegate。定位模型中的数据与模型索引 模型的结构 在Qt中，无论数据被存储为何种数据结构，模型总是以层次结构(即树形结构)来表示数据，视图按照此约定来访问模型中的数据，若数据是列表(list)或表格(tab)结构的数据，则可以把其看作是只含有顶层节点，不含任何子节点的树形结构。也就是说，我们在子类化QAbstractItemModel来自定义自已的模型结构时，始终应以树形结构为出发点，来组织自已的模型结构。模型索引(简称索引) Qt使用模型索引来使数据的表示和访问相分离，视图和委托使用索引来访问模型中的数据项，因此，只有模型知道怎样获取数据。 模型索引不像普通索引仅使用一个数字就能描述，模型索引需要使用3个属性进行描述：行号、列号、父模型索引。虽然模型索引使用行号、列号来定位数据项，但这并不意味着，数据是存储在数组或表格结构中的，使用行号、列号只是允许模型与视图、代理进行通信的一种约定。之所以需要父模型索引，是因为Qt的模型都是以层次结构(树形结构)组织的，Qt具体实现时，顶级数据项的父模型索引，使用“无效模型索引”来表示。 模型索引包含一个指向创建它们的模型的指针，当使用多个模型时，可避免混淆。Qt对模型索引的实现 Qt使用QModelIndex类实现模型索引，该类提供的索引是一个临时索引，因为模型可能会随时重新组织其内部结构(即数据项可能随时发生变化，比如删除、增加新数据项等)，因此模型索引可能会变得无效，所以模型索引不需要也不应被存储，若需要对数据项进行长时间的引用，应使用QPersistentModelIndex类创建一个持久模型索引。 使用模型索引引用模型中数据项的方法是使用QAbstractItemModel::index() 函数。 无效模型索引使用零参数的QModelIndex类的构造函数创建，即QModelIndex() 就表示创建了一个无效模型索引。数据的角色与数据的类型 同一个类型的数据可以作为不同的角色(或作用)来使用，比如对于字符串&quot;AAA&quot;，可把该字符串以文本的形式显示在视图的相应位置上，也可把该字符串作为工具提示使用，还可把该字符串作为what’s this的帮助提示等。由此可见，数据的角色，决定了该数据在视图中的显示方式，角色不同，显示方式也不同。 数据项与数据元素：位于同一个位置的数据项，并不仅仅只有一个数据元素，本文把组成数据项的数据称为数据元素，每个数据元素都有其自身的角色，比如一个数据项可能会同时含有图标数据元素(角色为Qt::DecorationRole)、文本数据元素(角色为Qt::DisplayRole)、工具提示数据元素(角色为Qt::ToolTipRole)等。因为数据项由多个数据元素组成，因此把数据项使用一个单独的类来管理是比较方便的，比如对于QStandardItemModel模型的数据项，就使用了类QStandardItem来专门管理其数据项。
Qt::ItemDataRole 含义 Qt::DisplayRole 数据以文本形式显示（QString） Qt::DecorationRole 数据以图形形式显示（QColor、QIcon、QPixmap） Qt::EditRole 数据可以编辑（QString） Qt::ToolTipRole 数据作为工具提示（QString） Qt::StatusTipRole 数据作为状态提示（QString） Qt::WhatsThisRole 数据作为WhatsThisRole帮助文档（QString） Qt::SizeHintRole 数据项的大小提示（QSize） Qt::FontRole 使用默认委托时渲染数据项的字体（QFont） Qt::TextAlignmentRole 使用默认委托时渲染数据项的文本对齐方式（Qt::Alignment） Qt::BackgroundRole 使用默认委托时渲染数据项的背景画刷（QBrush） Qt::BackgroundColorRole 弃用 Qt::ForegroundRole 使用默认委托时渲染数据项的前景色画刷（QBrush） Qt::TextColorRole 弃用 Qt::CheckStateRole 数据项的选中状态（Qt::CheckState枚举） Qt::InitialSortOrderRole 标题视图的初始排序顺序（升序或者降序）（Qt::SortOrder） 选择视图中的数据项(选择模型) 对视图内项目的选择Qt使用QItemSelectionModel 类(选择模型)来实现。所有的标准视图都有自已默认的选择模型。视图可以使用QAbstractItemView::selectionModel() 函数和QAbstractItemView::setSelectionModel() 来获取和设置选择模型。通常不需要对选择模型进行设置。
]]></content>
  </entry>
  
  <entry>
    <title>Qt智能指针</title>
    <url>/yfmff/yfmff.github.io.git/post/qt/qtsmartptr/</url>
    <categories><category>qt</category>
    </categories>
    <tags>
    </tags>
    <content type="html"><![CDATA[Qt原生支持C++的智能指针，还自己定义了Qt专用的智能指针。Qt中智能指针有QPointer、QSharedPointer、QScopedPointer、QWeakPointer、QSharedDataPointer、QScopedArrayPointer。
QPointer QPointer是个被保护的指针，QPointer ，行为和常规的指针 T* 类似。当其指向的对象（T必须是QObject及其派生的类对象）被销毁时，它会被自动置NULL，但是它本身析构时不回自动销毁所保护的对象。当你需要保存其他人所拥有的QObject对象的指针时，这点非常有用。
1QPointer&lt;QLabel&gt; label = new QLabel; 2 label-&gt;setText(&#34;&amp;Status:&#34;); 3 ... 4 if (label) 5 label-&gt;show(); 如果在 &hellip; 部分你将该对象delete掉了，label会自动置NULL，而不会是一个悬挂的野指针。常用方法 1void clear() // 清空 2 3T *data() const // 取出原始指针，不要删除 4 5bool isNull() const 6 7void swap(QPointer&lt;T&gt; &amp;other) 8 9T *operator T *() const 10 11T &amp;operator*() const 12 13T *operator-&gt;() const 14 15QPointer&lt;T&gt; &amp;operator=(T *p) QSharedPointer QSharedPointer 类似C++中的std::shared_ptr 共享指针。QSharedPointer可从普通指针、另一个QSharedPointer对象创建，也可通过将QWeakPointer对象提升为强引用创建。
QSharedPointer是线程安全的，即使有多个线程同时修改QSharedPointer对象也不需要加锁。虽然它是线程安全的，但是它指向的内存区域可不一定是线程安全的。所以多个线程同时修改QSharedPointer指向的数据时还要应该考虑加锁的。通常一个给定的QSharedPointer或QWeakPointer对象不能被多个线程在没有同步的情况下同时访问。常用方法 1QSharedPointer(const QWeakPointer&lt;T&gt; &amp;other) // 用弱指针构造 2 3QSharedPointer(const QSharedPointer&lt;T&gt; &amp;other) // 用其他共享指针构造，增加引用计数 4 5QSharedPointer(std::nullptr_t, Deleter d) // 构造出空的共享指针 6 7QSharedPointer(std::nullptr_t) // 构造出空的共享指针 8 9QSharedPointer(X *ptr, Deleter d) // 用普通指针构造，指定删除器 10 11QSharedPointer(X *ptr) // 用普通指针构造 12 13QSharedPointer() 14 15QSharedPointer&lt;T&gt; &amp;operator=(const QWeakPointer&lt;T&gt; &amp;other) 16 17QSharedPointer&lt;T&gt; &amp;operator=(const QSharedPointer&lt;T&gt; &amp;other) 18 19~QSharedPointer() 20 21void clear() //清除这个QSharedPointer对象，删除它可能对该指针的引用。如果这是最后一个引用，那么指针本身将被删除。 22 23QSharedPointer&lt;X&gt; constCast() const //将该指针的类型进行const_cast转换为X，并返回共享该引用的QSharedPointer。此函数可用于向上和向下类型转换，但对于向上类型转换更有用。 24 25T *data() const //返回此对象所引用的指针的值，不可删除这个函数返回的指针 26 27// 执行从该指针的类型到X的动态转换，并返回一个共享引用的QSharedPointer。如果这个函数被用于向上转换，那么QSharedPointer将执行dynamic_cast，这意味着如果QSharedPointer指向的对象不是X类型，那么返回的对象将是空的。 28// 特别说明：模板类型X必须具有与该对象的模板相同的const和volatile限定符，否则强制转换将失败。如果需要删除这些限定符，需使用constCast()。 29QSharedPointer&lt;X&gt; dynamicCast() const 30 31// ​ 执行从该指针的类型到X的静态转换，并返回一个共享该引用的QSharedPointer。此函数可用于向上和向下类型转换，但对于向上类型转换更有用。 32//​ 注意：模板类型X必须具有与该对象的模板相同的const和volatile限定符，否则强制转换将失败。如果需要删除这些限定符，请使用constCast()，这一点和dynamicCast（）一样。 33QSharedPointer&lt;X&gt; staticCast() const 34 35T *get() const // 和data类似 36 37bool isNull() const 38 39//​ 从该指针的类型执行qobject_cast()到X，并返回共享该引用的QSharedPointer。如果这个函数被用于向上转换，那么QSharedPointer将执行qobject_cast，这意味着如果QSharedPointer指向的对象不是X类型，那么返回的对象将是空的 40QSharedPointer&lt;X&gt; objectCast() const 41 42void reset() 43 44void reset(T *t) //将QSharedPointer对象重置为指向t。 45 46void reset(T *t, Deleter deleter) //将QSharedPointer对象重置为指向t。 47 48void swap(QSharedPointer&lt;T&gt; &amp;other) 49 50QWeakPointer&lt;T&gt; toWeakRef() const 51 52bool operator bool() const 53 54bool operator!() const 55 56T &amp;operator*() const 57 58T *operator-&gt;() const QScopedPointer QScopedPointer类似于C++ 11中的std::uniqueptr。当内存数据只在一处被使用，用完就可以安全的释放时就可以使用QScopedPointer。 ​QScopedPointer只是持有一个指向堆分配对象的指针，并在其析构函数中删除它。当一个对象需要分配和删除堆时，这个类很有用，但仅此而已。QScopedPointer是轻量级的，它不使用额外的结构或引用计数。注意：因为拷贝构造和赋值操作私有的，它不能用作容器的元素。
常用方法 1// 构造函数 2QScopedPointer(T *p = ...) 3~QScopedPointer() 4 5// 取出原始指针，不可删除 6T *take() 7T *data() const 8T *get() const 9 10// 状态相关 11bool isNull() const 12void reset(T *other = ...) 13void swap(QScopedPointer&lt;T, Cleanup&gt; &amp;other) 14 15// 运算符 16bool operator bool() const 17bool operator!() const 18T &amp;operator*() const 19T *operator-&gt;() const QWeakPointer ​QWeakPointer类似C++ 11中的弱指针。它不能用于直接解引用指针，但可以用于验证指针是否在另一个上下文中被删除。它是为配合QSharedPointer而引入的一种智能指针，它更像是 QSharedPointer 的一个助手(因为它不具有普通指针的行为，没有重载operator*和-&gt;)。它的最大作用在于协助QSharedPointer工作，像一个旁观者一样来观测资源的使用情况。
​QWeakPointer对象只能通过QSharedPointer赋值来创建。QWeakPointer没有提供自动强制转换操作符来防止错误的发生。即使QWeakPointer跟踪一个指针，它也不应该被视为指针本身，因为它不能保证所指向的对象仍然有效。​因此，要访问QWeakPointer正在跟踪的指针，必须首先将其提升为QSharedPointer，并验证结果对象是否为空。常用方法 1// 构造 2QWeakPointer(const QSharedPointer&lt;T&gt; &amp;other) 3QWeakPointer(const QWeakPointer&lt;T&gt; &amp;other) 4QWeakPointer() 5 6QWeakPointer&lt;T&gt; &amp;operator=(const QSharedPointer&lt;T&gt; &amp;other) 7QWeakPointer&lt;T&gt; &amp;operator=(const QWeakPointer&lt;T&gt; &amp;other) 8~QWeakPointer() 9 10void clear() 11bool isNull() const 12 13// 提升至QSharedPointer，增加引用计数 14QSharedPointer&lt;T&gt; lock() const 15QSharedPointer&lt;T&gt; toStrongRef() const 16 17void swap(QWeakPointer&lt;T&gt; &amp;other) 18bool operator bool() const 19bool operator!() const QSharedDataPointer QSharedDataPointer​ 这个类帮我们实现数据的隐式共享。它持有一个指向共享数据的指针(即，从QSharedData派生的类)。它通过放置在QSharedData基类中的内部引用计数来实现这一点。因此，这个类可以根据对被保护的数据的访问类型进行分离:如果是非const访问，它会自动创建一个副本以完成操作。
QScopedArrayPointer ​如果我们指向的内存数据是一个数组，这时可以用 QScopedArrayPointer。QScopedArrayPointer 与 QScopedPointer 类似，用于简单的场景。 例如：
1void func() 2{ 3 QScopedArrayPointer&lt;int&gt; myarr (new int[10]); 4 myarr[2]=42; 5 ... 6 return; // 出作用域后会析构myarr 7} ]]></content>
  </entry>
  
  <entry>
    <title>Qt中d指针和q指针</title>
    <url>/yfmff/yfmff.github.io.git/post/qt/qtdqptr/</url>
    <categories><category>qt</category>
    </categories>
    <tags>
    </tags>
    <content type="html"><![CDATA[
Qt大量使用d指针和q指针，这里简单记录下用法以及原理。
d指针 d指针的作用 d指针的作用有：隐藏接口具体实现，提高程序编译速度，最大程度实现程序的二进制兼容。
二进制兼容指的是：
二进制兼容动态库：在老版本的动态库上运行新的应用程序，在不经过编译的情况下，能够在新版本的动态库下运行；在需要编译的情况下不需要修改源码。 要想使得dll能达到二进制兼容，对于类中对象/结构/数据都应该保持不变，如果类中的对象或者数据进行了改动，就会影响对象的数据结构，从而导致数据在数据模型中发生变化，程序使用新版本编译后会导致崩溃。 为了使得增加项后不对数据模型的大小产生影响，方法1.预先分配若干保留空间， 后续添加数据均使用保留空间（使用位域定义：int n:20 设置该变量预先占用几个bit空间） 方法2.将预分配保留空间类型由“常规变量”-&gt;‘对象指针’。 使用方式 Q_DECLARE_PRIVATE(class) + Q_D(class)配合使用： Q_DECLARE_PRIVATE(class) 的具体实现
1template &lt;typename T&gt; inline T *qGetPtrHelper(T *ptr) { return ptr; } 2template &lt;typename Ptr&gt; inline auto qGetPtrHelper(Ptr &amp;ptr) -&gt; decltype(ptr.operator-&gt;()) { return ptr.operator-&gt;(); } 3 4#define Q_DECLARE_PRIVATE(Class) \ 5 inline Class##Private* d_func() \ 6 { Q_CAST_IGNORE_ALIGN(return reinterpret_cast&lt;Class##Private *&gt;(qGetPtrHelper(d_ptr));) } \ 7 8 inline const Class##Private* d_func() const \ 9 { Q_CAST_IGNORE_ALIGN(return reinterpret_cast&lt;const Class##Private *&gt;(qGetPtrHelper(d_ptr));) } \ 10 11 friend class Class##Private; 可见Q_DECLARE_PRIVATE会将传入的类名称后添加Private，构造出一个新的类并将其作为友元，通过d_func() 指向这个私有的实现类。 Q_D宏：
1#define Q_D(Class) Class##Private * const d = d_func() 可见，Q_D宏只作用于当前函数的作用域，在每个函数的第一行使用，Q_D定义了一个class##Private的指针，指向d_func，因此可通过Q_D访问d指针。d指针需要手动释放。 Q_DECLARE_PRIVATE和Q_D配合使用是为了更方便的获取d指针，d指针指向的是私有实现类：class##Private。q指针 q指针的作用 配合d指针，实现d指针的作用。
使用方式 Q_DECLARE_PUBLIC(class)和Q_Q(class)两个宏配合使用。 Q_DECLARE_PUBLIC(class) 的实现：
1#define Q_DECLARE_PUBLIC(Class) \ 2 inline Class* q_func() { return static_cast&lt;Class *&gt;(q_ptr); } \ 3 inline const Class* q_func() const { return static_cast&lt;const Class *&gt;(q_ptr); } \ 4 friend class Class; 可见，Q_DECLARE_PUBLIC创建了两个内联函数并添加一个友元类。 Q_DECLARE_PUBLIC 创建了q_func（） 并使其指向相对父类，并将相对父类声明为友元类。
Q_Q宏：
1#define Q_Q(Class) Class * const q = q_func() Q_Q作用于当前函数作用域，在函数第一行使用。 Q_Q定义了一个名为q的指向q_func的指针（是相对父类的指针），使用Q_Q可以访问q指针。
Q_DECLARE_PUBLIC和Q_Q配合使用是为了方便获得q指针，q指针指向相对父类本身。实例 Q_DECLARE_PRIVATE和Q_DECLARE_PUBLIC分别定义了d_func和p_func，分别用来在class和class##private中获取彼此的指针。1class objectPrivate 2{ 3 Q_DECLARE_PUBLIC(Qobject); 4 5public: 6 objectPrivate(Object* parent):q_ptr(parent){} 7 8 void pFunction() 9 { 10 Q_Q(object); 11 q-&gt;Function(&#34;hello&#34;); // 调用相对父类的接口 12 } 13 14// 注意：不可在私有实现类中释放相对父类的q指针 15private: 16 object* const q_ptr; 17} 18 19 20class object // 相对父类 21{ 22public: 23 explicit object(QObjet* parent):d_ptr(new objectPrivate(this)){} 24 25 ~object() 26 { 27 Q_D(object); 28 delete d; 29 } 30 31protected: 32 void Function(const std::string&amp;) 33 { 34 Q_D(object); 35 d-&gt;pFunction();// 调用私有实现类的相关函数 36 } 37 38private: 39 objectPrivate* const d_ptr; 40 Q_DECLARE_PRIVATE(object); 41 Q_DISABLE_COPY(object);// 在相对父类没有定义拷贝函数时，禁止私有实现类调用相对父类的拷贝构造函数 42} ]]></content>
  </entry>
  
  <entry>
    <title>Linux—makefile</title>
    <url>/yfmff/yfmff.github.io.git/post/linux/linuxmakefile/</url>
    <categories><category>linux</category>
    </categories>
    <tags>
    </tags>
    <content type="html"><![CDATA[当项目中文件很多时，一个一个采用g++或者gcc语法来编译是非常不方便的，这种情况下我们需要借助项目构造工具 make 帮助我们完成这个艰巨的任务。 make 是一个命令工具，是一个解释 makefile 中指令的命令工具，一般来说，大多数的 IDE 都有这个命令。 make 工具在构造项目的时候需要加载一个叫做 makefile 的文件，makefile 定义了整个工程的编译规则，它定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为 makefile 就像一个 Shell 脚本一样，其中也可以执行操作系统的命令。 makefile 带来的好处就是 ——“自动化编译”，一旦写好，只需要一个 make 命令，整个工程完全自动编译，极大的提高了软件开发的效率。 makefile 文件有两种命名方式 makefile 和 Makefile，构建项目的时候在哪个目录下执行构建命令 make 这个目录下的 makefile 文件就会别加载，因此在一个项目中可以有多个 makefile 文件，分别位于不同的项目目录中。规则 基本格式是：
1# 每条规则的语法格式: 2# 目标：就是想要生成的目标文件：依赖（源材料） 3# 执行的命令 4 5target1,target2...: depend1, depend2, ... 6	command 7	...... 8	...... 注意：command前一定记得加tab空格; 举例：
1# 举例: 有源文件 a.c b.c c.c head.h, 需要生成可执行程序 app 2################# 例1 ################# 3app:a.c b.c c.c 4	gcc a.c b.c c.c -o app 5 6################# 例2 ################# 7# 有多个目标, 多个依赖, 多个命令 8app,app1:a.c b.c c.c d.c 9	gcc a.c b.c -o app 10	gcc c.c d.c -o app1 11	12################# 例3 #################	13# 规则之间的嵌套 14app:a.o b.o c.o 15	gcc a.o b.o c.o -o app 16# a.o 是第一条规则中的依赖 17a.o:a.c 18	gcc -c a.c 19# b.o 是第一条规则中的依赖 20b.o:b.c 21	gcc -c b.c 22# c.o 是第一条规则中的依赖 23c.o:c.c 24	gcc -c c.c 工作原理 规则的执行 在调用 make 命令编译程序的时候，make 会首先找到 Makefile 文件中的第 1 个规则，分析并执行相关的动作。但是需要注意的是，好多时候要执行的动作（命令）中使用的依赖是不存在的，如果使用的依赖不存在，这个动作也就不会被执行。
对应的解决方案是先将需要的依赖生成出来，我们就可以在 makefile 中添加新的规则，将不存在的依赖作为这个新的规则中的目标，当这条新的规则对应的命令执行完毕，对应的目标就被生成了，同时另一条规则中需要的依赖也就存在了。
这样，makefile 中的某一条规则在需要的时候，就会被其他的规则调用，直到 makefile 中的第一条规则中的所有的依赖全部被生成，第一条规则中的命令就可以基于这些依赖生成对应的目标，make 的任务也就完成了。
1# makefile 2# 规则之间的嵌套 3# 规则1 4app:a.o b.o c.o 5	gcc a.o b.o c.o -o app 6# 规则2 7a.o:a.c 8	gcc -c a.c 9# 规则3 10b.o:b.c 11	gcc -c b.c 12# 规则4 13c.o:c.c 14	gcc -c c.c 在这个例子中，如果执行 make 命令就会根据这个 makefile 中的 4 条规则编译这三个源文件。在解析第一条规则的时候发现里边的三个依赖都是不存在的，因此规则对应的命令也就不能被执行。
当依赖不存在的时候，make 就是查找其他的规则，看哪一条规则是用来生成需要的这个依赖的，找到之后就会执行这条规则中的命令。因此规则 2， 规则 3， 规则 4 里的命令会相继被执行，当规则 1 中依赖全部被生成之后对应的命令也就被执行了，因此规则 1 的目标被生成，make 工作结束。
如果想要执行 makefile 中非第一条规则对应的命令，那么就不能直接 make, 需要将那条规则的目标也写到 make 的后边，比如只需要执行规则 3 中的命令，就需要: make b.o。
时间戳 make 命令执行的时候会根据文件的时间戳判定是否执行 makefile 文件中相关规则中的命令。 目标是通过依赖生成的，因此正常情况下：目标时间戳 &gt; 所有依赖的时间戳 , 如果执行 make 命令的时候检测到规则中的目标和依赖满足这个条件，那么规则中的命令就不会被执行。 当依赖文件被更新了，文件时间戳也会随之被更新，这时候 目标时间戳 &lt; 某些依赖的时间戳 , 在这种情况下目标文件会通过规则中的命令被重新生成。 如果规则中的目标对应的文件根本就不存在， 那么规则中的命令肯定会被执行。
变量 使用 Makefile 进行规则定义的时候，为了写起来更加灵活，我们可以在里边使用变量。makefile 中的变量分为三种：自定义变量，预定义变量和自动变量。
自定义变量 1# 创建 2# 错误, 只创建了变量名, 没有赋值 3变量名 4# 正确, 创建一个变量名并且给其赋值 5变量名=变量值 6 7# 使用这个变量 8$(自定义的变量名) 9 10# 举例 11# 这是一个规则，普通写法 12calc:add.o div.o main.o mult.o sub.o 13 gcc add.o div.o main.o mult.o sub.o -o calc 14 15# 这是一个规则，里边使用了自定义变量 16obj=add.o div.o main.o mult.o sub.o 17target=calc 18$(target):$(obj) 19 gcc $(obj) -o $(target) 自动变量 Makefile 中的变量除了用户自定义变量和预定义变量外，还有一类自动变量。Makefile 中的规则语句中经常会出现目标文件和依赖文件，自动变量用来代表这些规则中的目标文件和依赖文件，并且它们只能在规则的命令中使用。
变量 含义 $* 表示目标文件的名称，不包含目标文件的扩展名 $+ 表示所有的依赖文件，这些依赖文件之间以空格分开，按照出现的先后为顺序，其中可能 包含重复的依赖文件 $&lt; 表示依赖项中第一个依赖文件的名称 $? 依赖项中，所有比目标文件时间戳晚的依赖文件，依赖文件之间以空格分开 $@ 表示目标文件的名称，包含文件扩展名 $^ 依赖项中，所有不重复的依赖文件，这些文件之间以空格分开 函数 makefile 中有很多函数并且所有的函数都是有返回值的。makefile 中函数的格式和 C/C++ 中函数也不同，其写法是这样的： $(函数名 参数1, 参数2, 参数3, &hellip;)，主要目的是让我们能够快速方便的得到函数的返回值。
这里记录两个 makefile 中使用频率比较高的函数：wildcard 和 patsubst。
wildcard 这个函数的主要作用是获取指定目录下指定类型的文件名，其返回值是以空格分割的、指定目录下的所有符合条件的文件名列表。函数原型如下：
1# 该函数的参数只有一个, 但是这个参数可以分成若干个部分, 通过空格间隔 2$(wildcard PATTERN...) 3	参数:	指定某个目录, 搜索这个路径下指定类型的文件，比如： *.c PATTERN 指的是某个或多个目录下的对应的某种类型的文件，比如当前目录下的.c 文件可以写成 *.c，可以指定多个目录，每个路径之间使用空格间隔。 函数返回值：得到的若干个文件的文件列表， 文件名之间使用空格间隔。 函数使用举例:
1# 使用举例: 分别搜索三个不同目录下的 .c 格式的源文件 2src = $(wildcard /home/robin/a/*.c /home/robin/b/*.c *.c) # *.c == ./*.c 3# 返回值: 得到一个大的字符串, 里边有若干个满足条件的文件名, 文件名之间使用空格间隔 4/home/robin/a/a.c /home/robin/a/b.c /home/robin/b/c.c /home/robin/b/d.c e.c f.c patsubst 这个函数的功能是按照指定的模式替换指定的文件名的后缀，函数原型如下:
1# 有三个参数, 参数之间使用 逗号间隔 2$(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;) pattern: 这是一个模式字符串，需要指定出要被替换的文件名中的后缀是什么，文件名和路径不需要关心，因此使用 % 表示即可 [通配符是 %]，在通配符后边指定出要被替换的后缀，比如: %.c, 意味着 .c 的后缀要被替换掉。 replacement: 这是一个模式字符串，指定参数 pattern 中的后缀最终要被替换为什么，还是使用 % 来表示参数 pattern 中文件的路径和名字，在通配符 % 后边指定出新的后缀名，比如: %.o 这表示原来的后缀被替换为 .o text: 该参数中存储这要被替换的原始数据。 函数返回被替换过后的字符串。 函数使用举例:
1src = a.cpp b.cpp c.cpp e.cpp 2# 把变量 src 中的所有文件名的后缀从 .cpp 替换为 .o 3obj = $(patsubst %.cpp, %.o, $(src)) 4# obj 的值为: a.o b.o c.o e.o ]]></content>
  </entry>
  
  <entry>
    <title>Linux静态库和动态库</title>
    <url>/yfmff/yfmff.github.io.git/post/linux/linuxlib/</url>
    <categories><category>linux</category>
    </categories>
    <tags>
    </tags>
    <content type="html"><![CDATA[静态库 在Linux中，静态库以lib为前缀，以 .a为后缀，中间的名字可自定义，如：libmylib.a。
生成静态库 生成静态库需要用到ar打包工具。首先，将源文件生成后缀为 .o的文件，再通过ar 工具打包成静态库。ar工具打包时需要用到3个参数：
c 创建一个库，不管库是否存在，都将创建。 s 创建目标文件索引，这在创建较大的库时能加快时间。 r 在库中插入模块 (替换)。默认新的成员添加在库的结尾处，如果模块名已经在库中存在，则替换同名的模块。 生成静态链接库的具体步骤如下:
1# 需要将源文件进行汇编，得到 .o 文件，需要使用参数 -c 2# -c 参数位置没有要求 3$ gcc 源文件(*.c) -c	4 5# 将得到的 .o 进行打包，得到静态库 6$ ar rcs 静态库的名字(libxxx.a) 原材料(*.o) 7 8# 发布静态库 9	1. 提供头文件 **.h 10	2. 提供制作出来的静态库 libxxx.a 使用静态库 当我们得到了一个可用的静态库之后，需要将其放到一个目录中，然后根据得到的头文件编写测试代码，对静态库中的函数进行调用。在编译的时将静态库的路径和名字都指定出来： -L: 指定库所在的目录 (相对或者绝对路径) -l: 指定库的名字，需要掐头 (lib) 去尾 (.a) 剩下的才是需要的静态库的名字
动态库 动态链接库是程序运行时加载的库，当动态链接库正确部署之后，运行的多个程序可以使用同一个加载到内存中的动态库，因此在Linux中动态链接库也可称之为共享库。linux中，动态库以lib开头，以 .so作为后缀，中间名称自己定义，比如：libmyfunc.so。
生成动态库 生成动态链接库是直接使用gcc 命令并且需要添加 -fPIC(-fpic) 以及 -shared参数。 -fPIC 或 -fpic 参数的作用是使得 gcc 生成的代码是与位置无关的，也就是使用相对位置。 -shared参数的作用是告诉编译器生成一个动态链接库 生成动态链接库的具体步骤如下:
1# 将源文件进行汇编操作，需要使用参数 -c, 还需要添加额外参数 -fpic /-fPIC 2# 得到若干个 .o文件 3$ gcc 源文件(*.c) -c -fpic 4 5# 将得到的.o 文件打包成动态库，还是使用 gcc, 使用参数 -shared 指定生成动态库 (位置没有要求) 6$ gcc -shared 与位置无关的目标文件(*.o) -o 动态库(libxxx.so) 7 8# 发布 9 1. 提供头文件: xxx.h 10 2. 提供动态库: libxxx.so 使用动态库 当我们得到了一个可用的动态库之后，需要将其放到一个目录中，然后根据得到的头文件编写测试代码，对动态库中的函数进行调用。和使用静态库一样，在编译的时候需要指定库相关的信息: 库的路径 -L 和 库的名字 -l
动态库无法加载的原因 工作原理 对于静态库而言，在程序编译的最后一个阶段也就是链接阶段，提供的静态库会被打包到可执行程序中。当可执行程序被执行，静态库中的代码也会一并被加载到内存中，因此不会出现静态库找不到无法被加载的问题。 对于动态库，在程序编译的最后一个阶段也就是链接阶段，在gcc命令中虽然指定了库路径 (使用参数 -L ), 但是这个路径并没有记录到可执行程序中，只是检查了这个路径下的库文件是否存在。同样对应的动态库文件也没有被打包到可执行程序中，只是在可执行程序中记录了库的名字。可执行程序被执行起来之后，程序执行的时候会先检测需要的动态库是否可以被加载，加载不到就会提示错误信息，当动态库中的函数在程序中被调用了, 这个时候动态库才加载到内存，如果不被调用就不加载。动态库的检测和内存加载操作都是由动态连接器来完成的。 动态链接器 动态链接器是一个独立于应用程序的进程，属于操作系统，当用户的程序需要加载动态库的时候动态连接器就开始工作了，很显然动态连接器根本就不知道用户通过 gcc 编译程序的时候通过参数 -L 指定的路径。那么动态链接器是如何搜索某一个动态库的呢，在它内部有一个默认的搜索顺序，按照优先级从高到低的顺序分别是：
可执行文件内部的 DT_RPATH 段 系统的环境变量 LD_LIBRARY_PATH 系统动态库的缓存文件 /etc/ld.so.cache 存储动态库 / 静态库的系统目录 /lib/, /usr/lib 等 按照以上四个顺序，依次搜索，找到之后结束遍历，最终还是没找到，动态连接器就会提示动态库找不到的错误信息。
解决方案 方案 1: 将库路径添加到环境变量LD_LIBRARY_PATH 中 找到相关的配置文件:用户级别: ~/.bashrc —&gt; 设置对当前用户有效,系统级别: /etc/profile —&gt; 设置对所有用户有效。 打开文件，在文件最后添加这样一句话：export LIBRARY_PATH=$LIBRARY_PATH:动态库的绝对路径 方案2： 更新 /etc/ld.so.cache 文件 找到动态库所在的绝对路径（不包括库的名字）比如：/home/robin/Library/ 使用 vim 修改 /etc/ld.so.conf 这个文件，将上边的路径添加到文件中 (独自占一行) 1# 1. 打开文件 2$ sudo vim /etc/ld.so.conf 3 4# 2. 添加动态库路径, 并保存退出 更新 /etc/ld.so.conf 中的数据到 /etc/ld.so.cache 中
1# 必须使用管理员权限执行这个命令 2$ sudo ldconfig 方案3: 拷贝动态库文件到系统库目录 /lib/ 或者 /usr/lib 中 (或者将库的软链接文件放进去) 1# 库拷贝 2sudo cp /xxx/xxx/libxxx.so /usr/lib 3 4# 创建软连接 5sudo ln -s /xxx/xxx/libxxx.so /usr/lib/libxxx.so ]]></content>
  </entry>
  
  <entry>
    <title>协程</title>
    <url>/yfmff/yfmff.github.io.git/post/cpp/routine/</url>
    <categories><category>cpp</category>
    </categories>
    <tags>
    </tags>
    <content type="html"><![CDATA[什么是协程 协程,英文名 是coroutine,点击查看官方定义，C++ 20已经支持，它是一种能够暂停和恢复执行的 函数。一个协程中必须要有co_wait、co_yield、或者co_return关键字（主函数是不能是协程的）。其返回类型需要有个可被公开访问的内部类型promise_type(可以是using/typedef而来)。
未完待续。。。。。。
]]></content>
  </entry>
  
  <entry>
    <title>gcc</title>
    <url>/yfmff/yfmff.github.io.git/post/linux/linuxgcc/</url>
    <categories><category>linux</category>
    </categories>
    <tags>
    </tags>
    <content type="html"><![CDATA[gcc是Linux下的编译工具集，不仅能编译C/C++ 语言，其他例如Objective-C、Pascal、Fortran、Java、Ada等语言均能进行编译。gcc在可以根据不同的硬件平台进行编译，即能进行交叉编译，在A平台上编译B平台的程序，支持常见的X86、ARM、PowerPC、mips等，以及Linux、Windows等软件平台。
安装 1# 安装软件必须要有管理员权限 2# ubuntu 3$ sudo apt update # 更新本地的软件下载列表, 得到最新的下载地址 4$ sudo apt install gcc g++	# 通过下载列表中提供的地址下载安装包, 并安装 5 6# centos 7$ sudo yum update # 更新本地的软件下载列表, 得到最新的下载地址 8$ sudo yum install gcc g++	# 通过下载列表中提供的地址下载安装包, 并安装 9 10# 查看 gcc 版本 11$ gcc -v 12$ gcc --version 13 14# 查看 g++ 版本 15$ g++ -v 16$ g++ --version gcc 工作流程 gcc编译器对程序的编译分为4个阶段：预处理（预编译）、编译和优化、汇编和链接。gcc的编译器可以将这4个步骤合并成一个。 预处理阶段：调用预处理器来展开头文件 、宏替换 、去掉注释行，输出还是文本文件。 编译阶段：调用编译器对文件进行编译，最终得到一个汇编文件。 汇编阶段:调用汇编器对文件进行汇编，最终得到一个二进制文件。 链接阶段：调用链接器对程序需要调用的库进行链接，最终得到一个可执行的二进制文件文件后缀 说明 gcc参数 .c 源文件 —— .i 预处理后的 C 文件 -E .s 编译之后得到的汇编语言的源文件 -S .o 汇编后得到的二进制文件 -c 在Linux下使用gcc编译器编译单个文件十分简单，直接使用gcc命令后面加上要编译的C语言的源文件，gcc会自动生成文件名为a.out的可执行文件（也可以通过参数 -o指定生成的文件名）。
gcc 常用参数 编译可选项 含义 -E 预处理指定的源文件，不进行编译 -S 编译指定的源文件，但是不进行汇编 -c 编译、汇编指定的源文件，但是不进行链接 -o [file1] [file2] / [file2] -o [file1] 将文件 file2 编译成文件 file1 -I directory (大写的 i) 指定 include 包含文件的搜索目录 -g 在编译的时候，生成调试信息，该程序可以被调试器调试 -D 在程序编译的时候，指定一个宏 -w 不生成任何警告信息，不建议使用，有些时候警告就是错误 -l 在程序编译的时候，指定使用的库 -L 指定编译的时候，搜索的库的路径。 -fPIC/fpic 生成与位置无关的代码 -shared 生成共享目标文件。通常用在建立共享库时指定 -std 指定 C 方言，如:-std=c99，gcc 默认的方言是 GNU C -Wall 生成所有警告信息 -On n 的取值范围：0~3。编译器的优化选项的 4 个级别，-O0 表示没有优化，-O1 为缺省值，-O3 优化级别最高 gcc和g++区别 在代码的编译阶段 后缀为 .c的，gcc把它当作是C程序，而g++当作是C++ 程序。 后缀为 .cpp的，两者都会认为是C++程序，C++的语法规则更加严谨一些。 g++会调用gcc，对于C++代码，两者是等价的，也就是说gcc和g++都可以编译C/C++代码。 在链接阶段 gcc和g++都可以自动链接到标准C库。 g++可以自动链接到标准C++库，gcc如果要链接到标准C++ 库需要加参数 -lstdc++。 关于 __cplusplus 宏的定义 g++会自动定义 __cplusplus宏，但是这个不影响它去编译C程序。 gcc需要根据文件后缀判断是否需要定义 __cplusplus宏（规则参考第一条）。 ]]></content>
  </entry>
  
  <entry>
    <title>innosetup笔记</title>
    <url>/yfmff/yfmff.github.io.git/post/others/innosetup/</url>
    <categories>
    </categories>
    <tags>
      <tag>inno-setup</tag>
    </tags>
    <content type="html"><![CDATA[
很惭愧，做了两年开发了，结果还没学过怎么打包软件。今天就inno setup常用的操作进行总结，以备不时之需。
基本概念 inno setup是一款开源的、免费的、安装包制作软件，其是用Delphi写成，支持pascal脚本，分为Ansi和Unicode版本。通过编写后缀是 .iss的脚本文件，便可编译出可执行的安装包。点击访问inno setup官网。下图展示了一个示例脚本部分截图。 脚本格式 Inno Setup脚本含有很多区段（上图中 [Setup]就是一个字段），每个字段控制了安装过程中一些功能。各个段中都有一些相关的 条目，比如 [Setup]字段中就含有类似AppId、AppName 类似的条目，控制了软件的 id、软件名 等属性。在相关条目 前面添加 ; 可以注释此字段，使得该字段在打包时使用默认值。Inno Setup支持 #include 指令，比如当你的脚本里函数太多，文件太长时，可以将部分函数提出来做成单独的 myfunc.iss 文件，然后在主文件中 #include myfunc.iss 便可随意使用myfunc.iss中的函数。如果想在 [code] 段使用这些常量，比如想用 userdesktop，可这样写：{userdesktop}。可在文件头定义自己的常量： #define MYVAL 10，用时可在 {#MYVAL} 来取出数据。
常用常量 Inno Setup中提供了一些常用常量，而脚本中的条目大部分都可以嵌入常量。这些预定义的字符被包围在 {} 中。安装程序执行时会对这些常量进行翻译。 字符 { 视作为常量开始。如果你想将它作为实际字符使用，你必须使用两个连续的 { 字符。(对于 } 则不需要两个。)
常量 含义 app 用户在安装向导中的选择目标位置页面中选定的应用程序目录。 sys 系统的System32目录。 syswow64 在64-位Windows中，系统的SysWOW64目录，通常为 &ldquo;C:\WINDOWS\SysWOW64&rdquo;。这是32-位系统文件所在的实际目录。32-位系统文件不驻留在单独的 SysWOW64 目录中，因此如果在此处使用，此常量将解析为与 {sys} 相同的目录。除非特别需要获取 32-位系统文件所在实际目录的名称，否则不要使用此常量。在某些 {sys} 的地方随意使用 {syswow64} 可能会导致问题。 src 安装程序文件所在目录。 sd 系统驱动器。Windows系统被安装的驱动器。一般来说是 C:。该目录常量等同于SystemDrive环境变量。 commonpf 系统的Program Files目录的路径。{pf}等于 {pf32}，除非安装程序运行于64-位安装模式，在这种情况下它等于 {pf64} commonpf32/64 32-位程序文件。系统的32-位Program Files目录路径。一般来说它在32-位Windows是C:\Program Files，在64-位Windows中是 C:\Program Files(x86)。 commoncf/32 32-位Windows是 C:\Program Files\Common Files，在 64-位Windows中是 C:\Program Files(x86)\Common Files。 tmp 用于安装程序或卸载程序的临时目录。这不是用户的TEMP环境变量值。它是在安装程序启动后在用户临时目录中创建的子目录(如名为C:\WINDOWS\TEMP\IS-xxxxx.tmp)。目录中的所有文件和子目录在安装程序或卸载程序退出时删除。在安装时，这主要用于提取在 [Run] 区段运行、但安装后不再需要的文件 group 开始菜单文件夹路径 localappdata 当前用户的本地(非Roaming)应用程序数据文件夹的路径。 userappdata和commonappdata AppData文件夹路径。 usercf 当前用户的路径是Common Files目录。 userdesktop和commondesktop 桌面文件夹的路径。 userdocs和commondocs 我的文档(My Documents)文件夹路径。 userpf 当前用户的路径是Program Files目录。 userprograms和commonprograms 开始菜单上程序文件夹的路径。 log 日志文件名称，如果logging未启用则返回一个空字串。 Pascal脚本 我们的很多自定义功能几乎都是在[code]段实现的。Inno setup常用事件函数如下：
// 安装事件函数function InitializeSetup(): Boolean;在安装程序初始化期间调用。返回 False 以中止 Setup，否则返回 True。procedure InitializeWizard();在启动时使用该事件函数来改变向导或向导页面。你不能在它被触发时使用 InitializeSetup 事件函数，因为向导窗体尚不存在。procedure DeinitializeSetup();仅在安装程序终止前调用。注意这个函数在即使用户在任何内容安装之前退出安装程序时也会调用。procedure CurStepChanged(CurStep: TSetupStep);你可以用这个事件函数执行你自己的预安装和安装后任务。TSetupStep 值：ssInstall, ssPostInstall, ssDone在实际安装开始之前用 CurStep=ssInstall 调用，或在实际安装完成之后用 CurStep=ssPostInstall 调用，或在安装程序终止之前和安装完成之后用 CurStep=ssDone 调用。procedure CurInstallProgressChanged(CurProgress, MaxProgress: Integer);在安装程序提取文件、创建快捷方式、创建 INI 条目和创建注册表条目时，你可以使用该事件函数来监测进程。function ShouldSkipPage(PageID: Integer): Boolean;向导调用这个事件函数确定是否在所有页面或不在一个特殊页面(用 PageID 指定)显示。如果返回 True，将跳过该页面；如果你返回 False，该页面被显示。注意：这个事件函数不被 wpWelcome、wpPreparing 和 wpInstalling 页面调用，还有安装程序已经确定要跳过的页面也不会调用(例如，没有包含组件安装程序的 wpSelectComponents)。procedure CurPageChanged(CurPageID: Integer);在新向导页面(用 CurPageID 指定)显示后调用。function NeedRestart(): Boolean;返回 True 告诉安装程序提示用户在安装结束时重新启动系统，False 则反之。function PrepareToInstall(var NeedsRestart: Boolean): String;你可以使用该事件函数来监测并安装丢失的先决条件和/或关闭任何有关被更新的应用程序。返回非空字串以指示安装程序停止在准备安装向导页面，将返回的字串显示为错误消息。如果需要重新启动，请将 NeedsRestart 设置为 True（并返回非空字串）。如果以这种方式停止安装程序，它将使用安装程序退出代码中所述的专用退出代码退出。在这种情况下，不会使用由 /RESTARTEXITCODE= 命令行参数设置的任何自定义退出代码。如果 CloseApplications 设置为 yes，则在安装程序对正在使用的文件检查前，该事件函数被调用。仅当安装程序尚未确定无法继续时才会调用此函数，因为 [Files] 和 [InstallDelete] 区段中指定的一个或多个文件已队列（通过某些其他安装），以便在下次重新启动时进行替换或删除。// 卸载事件函数function InitializeUninstall(): Boolean;返回 False 中止卸载，True 则反之。procedure InitializeUninstallProgressForm();使用该事件函数对进度窗体在启动时进行更改。你不能使用 InitializeUninstall 事件函数，因为在它被触发时该进度窗体尚不存在。procedure DeinitializeUninstall();procedure CurUninstallStepChanged(CurUninstallStep: TUninstallStep);function UninstallNeedRestart(): Boolean;返回 True 以指示卸载程序在成功卸载结束时，提示用户重新启动系统，False 则反之。 常见需求 启用日志 [Setup]SetupLogging=yes[code]procedure CurStepChanged(CurStep: TSetupStep);varlogfilepathname, logfilename, newfilepathname: string;beginlogfilepathname := ExpandConstant(&#39;{log}&#39;);logfilename := ExtractFileName(logfilepathname);newfilepathname := ExpandConstant(&#39;{app}&#39;) + logfilename;FileCopy(logfilepathname, newfilepathname, false); // 拷贝下，方便查看end; 判断程序有没有在运行 方法1 [code]// function IsModuleLoaded to call at install time// added also setuponly flagfunction IsModuleLoaded(modulename: String ): Boolean;external &#39;IsModuleLoaded@files:psvince.dll stdcall setuponly&#39;;// 传入Myappexenamefunction IsAppRunning(const FileName : string): Boolean;varFSWbemLocator: Variant;FWMIService : Variant;FWbemObjectSet: Variant;beginResult := false;tryFSWbemLocator := CreateOleObject(&#39;WBEMScripting.SWBEMLocator&#39;);FWMIService := FSWbemLocator.ConnectServer(&#39;&#39;, &#39;root\CIMV2&#39;, &#39;&#39;, &#39;&#39;);FWbemObjectSet := FWMIService.ExecQuery(Format(&#39;SELECT Name FROM Win32_Process Where Name=&#34;%s&#34;&#39;,[FileName]));Result := (FWbemObjectSet.Count &gt; 0);FWbemObjectSet := Unassigned;FWMIService := Unassigned;FSWbemLocator := Unassigned;except// 这些代码不要也可以，就可以不加载IsModuleLoadedif (IsModuleLoaded(FileName)) thenbeginResult := false;endelsebeginResult := true;endend;end; 方法2 通过库psvince.dll的IsModuleLoaded接口来判断程序进程（名称）是否在运行，只能判断，不能结束进程，需要将psvince.dll拷贝到inno setup安装目录下，还需要拷贝到要打包程序的同级目录下。 [Files]Source: compiler:psvince.dll; Flags: dontcopy noencryption[code]// 安装时判断客户端是否正在运行function IsModuleLoaded(modulename: String ): Boolean;external &#39;IsModuleLoaded@files:psvince.dll stdcall setuponly&#39;;function InitializeSetup(): Boolean;varIsRunning: boolean;name:String;notice:String;beginResult :=true; //安装程序继续name := &#39;程序.exe&#39;;IsRunning:= IsModuleLoaded(name);if IsRunning thenbeginnotice := GetRunningNotice(&#39;&#39;);Msgbox(notice, mbConfirmation, MB_OK);Result :=false; //安装程序退出end;end; 方法3 通过库IsTask.dll的RunTask接口来判断程序进程（名称）是否在运行，使用接口KillTask结束进程,这样就不但能判断，还能结束进程，需要将ISTask.dll拷贝到inno setup安装目录下，还需要拷贝到要打包程序的同级目录下。 [Files]Source: compiler:ISTask.dll; Flags: dontcopy noencryption[code]// 安装时判断客户端是否正在运行function RunTask(FileName: string; bFullpath: Boolean): Boolean;external &#39;RunTask@files:ISTask.dll stdcall delayload setuponly&#39;;function KillTask(ExeFileName: string): Integer;external &#39;KillTask@files:ISTask.dll stdcall delayload setuponly&#39;;function InitializeSetup(): Boolean;varname:String;notice:String;beginResult:= true;name := &#39;&#39;程序.exe&#39;;if RunTask(name, false) thenbeginnotice := GetRunningNotice(&#39;&#39;);if MsgBox(notice, mbConfirmation, MB_YESNO) = IDYES thenbeginKillTask(name);endelseResult:= false;endend;// 卸载时判断客户端是否正在运行function RunTaskU(FileName: string; bFullpath: Boolean): Boolean;external &#39;RunTask@{app}/ISTask.dll stdcall delayload uninstallonly&#39;;function KillTaskU(ExeFileName: string): Integer;external &#39;KillTask@{app}/ISTask.dll stdcall delayload uninstallonly&#39;;function InitializeUninstall(): Boolean;varname:String;notice:String;beginResult:= true;name := &#39;&#39;程序.exe&#39;;if RunTaskU(name, false) thenbeginnotice := GetRunningNotice(&#39;&#39;);if MsgBox(notice, mbConfirmation, MB_YESNO) = IDYES thenbeginKillTaskU(name);endelseResult:= false;endUnloadDll(ExpandConstant(&#39;{app}/ISTask.dll&#39;));// 必须要释放，否则卸载不干净end; 终结进程 除了上述几种方法外，还有一种终结进程的方法：
[code]// 通过名称终结进程procedure TaskKillProcessByName(AppName: String);varWbemLocator : Variant;WMIService : Variant;WbemObjectSet: Variant;WbemObject : Variant;begin;WbemLocator := CreateOleObject(&#39;WbemScripting.SWbemLocator&#39;);WMIService := WbemLocator.ConnectServer(&#39;localhost&#39;, &#39;root\CIMV2&#39;);WbemObjectSet := WMIService.ExecQuery(&#39;SELECT * FROM Win32_Process Where Name=&#34;&#39; + AppName + &#39;&#34;&#39;);if not VarIsNull(WbemObjectSet) and (WbemObjectSet.Count &gt; 0) thenbeginWbemObject := WbemObjectSet.ItemIndex(0);if not VarIsNull(WbemObject) thenbeginWbemObject.Terminate();WbemObject := Unassigned;end;end;end; 环境变量的添加和删除 [code]procedure SetEnv(aEnvName, aEnvValue: string; aIsInstall, aIsInsForAllUser: Boolean);varsOrgValue: string;S1, sFileName: string;bRetValue, bInsForAllUser: Boolean;SL: TStringList;x: integer;beginbInsForAllUser := aIsInsForAllUser;if UsingWinNT thenbeginif bInsForAllUser thenbRetValue := RegQueryStringValue(HKEY_LOCAL_MACHINE, &#39;SYSTEM\CurrentControlSet\Control\Session Manager\Environment&#39;, aEnvName, sOrgValue)elsebRetValue := RegQueryStringValue(HKEY_CURRENT_USER, &#39;Environment&#39;, aEnvName, sOrgValue)sOrgValue := Trim(sOrgValue);beginS1 := aEnvValue;if pos(Uppercase(s1), Uppercase(sOrgValue)) = 0 then //还没有加入beginif aIsInstall thenbeginx := Length(sOrgValue);if (x &gt; 0) and (StringOfChar(sOrgValue[x], 1) &lt;&gt; &#39;;&#39;) thenS1 := &#39;;&#39;+S1;sOrgValue := sOrgValue + S1;end;end elsebeginif not aIsInstall thenbeginStringChangeEx(sOrgValue, S1 + &#39;;&#39;, &#39;&#39;, True);StringChangeEx(sOrgValue, S1, &#39;&#39;, True);end;end;if bInsForAllUser thenRegWriteStringValue(HKEY_LOCAL_MACHINE, &#39;SYSTEM\CurrentControlSet\Control\Session Manager\Environment&#39;, aEnvName, sOrgValue)elsebeginif (not aIsInstall) and (Trim(sOrgValue) = &#39;&#39;) thenRegDeleteValue(HKEY_CURRENT_USER, &#39;Environment&#39;, aEnvName)elseRegWriteStringValue(HKEY_CURRENT_USER, &#39;Environment&#39;, aEnvName, sOrgValue);end;end;end else //非NT 系统,如Win98beginSL := TStringList.Create;trysFileName := ExpandConstant(&#39;{sd}\autoexec.bat&#39;);LoadStringFromFile(sFileName, S1);SL.Text := s1;s1 := &#39;&#34;&#39; + aEnvValue + &#39;&#34;&#39;;s1 := &#39;set &#39;+aEnvName +s1 + &#39;=%path%;&#39; ;bRetValue := False;x := SL.IndexOf(s1);if x = -1 thenbeginif aIsInstall thenbeginSL.Add(s1);bRetValue := True;end;end else //还没添加if not aIsInstall thenbeginSL.Delete(x);bRetValue := True;end;if bRetValue thenSL.SaveToFile(sFileName);finallySL.free;end;end;end; 环境变量中是否包含指定路径 [code]unction NeedsAddPath(Param: string): boolean;varOrigPath: string;beginif not RegQueryStringValue(HKEY_LOCAL_MACHINE,&#39;SYSTEM\CurrentControlSet\Control\Session Manager\Environment&#39;, &#39;Path&#39;, OrigPath)then beginResult := True;exit;end;// look for the path with leading and trailing semicolon// Pos() returns 0 if not foundResult := Pos(&#39;;&#39; + UpperCase(Param) + &#39;;&#39;, &#39;;&#39; + UpperCase(OrigPath) + &#39;;&#39;) = 0; if Result = True thenResult := Pos(&#39;;&#39; + UpperCase(Param) + &#39;\;&#39;, &#39;;&#39; + UpperCase(OrigPath) + &#39;;&#39;) = 0; end; 覆盖安装 [code]varisskip:Boolean;ResultCode:integer;gbInstallPath:string;procedure InitializeWizard();beginWizardForm.DirEdit.Text :=gbInstallPath;end// 卸载前通过注册表获得之前的安装路径并保存function getpath(AppName: String):stringbeginif RegQueryStringValue(&#39;自己的参数&#39;,gbInstallPath) thenresult := gbInstallPathelseresult := WizardForm.DirEdit.Text;end;// 在InitializeSetup时如果检测到需要覆盖安装，则静默卸载gbInstallPath := gbInstallPath(ResultStr); Exec(gbInstallPath, &#39;/silent&#39;, &#39;&#39;, SW_HIDE, ewWaitUntilTerminated, ResultCode); 将程序中所有用到{app}的地方替换为{code:getpath}跳过相关的安装页（比如欢迎页、选择安装位置页、创建快捷方式页等）function ShouldSkipPage(PageID: Integer): Boolean; //在这个函数中选择你想跳过的页返回true ]]></content>
  </entry>
  
  <entry>
    <title>linux基础(二)</title>
    <url>/yfmff/yfmff.github.io.git/post/linux/linuxbase2/</url>
    <categories><category>linux</category>
    </categories>
    <tags>
    </tags>
    <content type="html"><![CDATA[tar Linux 操作系统中默认自带两个原始的压缩工具分别是gzip和bzip2, 但是它们都有先天的缺陷，不能打包压缩文件, 每个文件都会生成一个单独的压缩包, 并且压缩之后不会保留原文件。Linux 中自带一个打包工具，叫做tar, 默认情况下该工具是不能进行压缩操作的，在这种情况下tar和gzip、 bzip2就联姻了，各自发挥各自的优势，Linux下最强大的打包压缩工具至此诞生。
压缩 使用tar压缩，用到的参数见下表，使用时，顺序无要求。
参数 含义 c 创建压缩文件 z 使用zip的方式进行文件压缩 j 使用bzip2的方式进行文件压缩 v 压缩过程中显示压缩信息，可以省略不写 f 指定压缩包的名字 一般认为 .tgz 文件就等同于 .tar.gz 文件，因此它们的压缩方式是相同的。 压缩举例：
1# 查看目录内容 2[root@localhost ~/files]# ls 3get onepiece.txt tmp.txt 4 5# 压缩目录中所有文件, 如果要压缩某几个文件, 直接指定文件名即可 6[root@localhost ~/files] tar zcvf all.tar.gz * 7get/ # ....... 压缩信息 8get/link.lnk # ....... 压缩信息 9get/onepiece/ # ....... 压缩信息 10get/onepiece/haha.txt 11get/link.txt 12onepiece.txt 13tmp.txt 14 15# 查看目录文件, 多了一个压缩文件 all.tar.gz 16[root@localhost ~/files]# ls 17all.tar.gz get onepiece.txt tmp.txt 解压缩 使用tar进行文件的解压缩，涉及的参数如下，在使用过程中参数没有先后顺序:
参数 含义 x 释放压缩文件内容 z 使用gzip的方式进行文件压缩，压缩包后缀为 .tar.gz j 使用bzip2的方式进行文件压缩，压缩包后缀为 .tar.bz2 v 压缩过程中显示压缩信息，可以省略不写 f 指定压缩包的名字 使用以上参数是将压缩包解压到当前目录，如果需要解压到指定目录，需要指定参数 -C。 一般认为 .tgz文件就等同于 .tar.gz文件，解压缩方式是相同的。解压的语法格式如下:
1# 语法1: 解压到当前目录中 2$ tar 参数 压缩包名 3 4# 语法2: 解压到指定目录中 5$ tar 参数 压缩包名 -C 解压目录 举例：解压缩
1# 查看目录文件信息 2[root@localhost ~/files]# ls 3all.tar.gz get onepiece.txt part.tar.bz2 tmp.txt temp 4 5# 将 all.tar.gz 压缩包解压缩到 temp 目录中 6[root@localhost ~/files] tar zxvf all.tar.gz -C temp 7get/ # 解压缩文件信息 8get/link.lnk # 解压缩文件信息 9get/onepiece/ # 解压缩文件信息 10get/onepiece/haha.txt # 解压缩文件信息 11get/link.txt 12onepiece.txt 13tmp.txt 14 15# 查看temp目录内容, 都是从压缩包中释放出来的 16[root@localhost ~/files]# ls temp/ 17get onepiece.txt tmp.txt 查找相关 find 通过文件名查找 语法格式： 1# 语法格式: 根据文件名搜索 2# 如果我们进行模糊查询，建议（非必须）将带有通配符的文件名写到引号中（单引号或者双引号都可以），这样可以避免搜索命令执行失败（如果不加引号，某些情况下会这样）。 3$ find 搜索的路径 -name 要搜索的文件名 举例：
1# 模式搜索 2# 搜索 root 家目录下文件后缀为 txt 的文件 3[root@localhost ~]# find /root -name &#34;*.txt&#34; 4/root/files/get/onepiece/haha.txt 5/root/files/get/onepiece/onepiece.txt 6/root/files/get/onepiece.txt 7/root/files/get/link.txt 8/root/files/root.txt 9/root/files/onepiece.txt 10/root/ace/brother/finally/die.txt 11/root/onepiece.txt 12 13################################################## 14 15# 精确搜索 16# 搜索 root 家目录下文件名为 onepiece.txt 的文件 17[root@localhost ~]# find /root -name &#34;onepiece.txt&#34; 18/root/files/get/onepiece/onepiece.txt 19/root/files/get/onepiece.txt 20/root/files/onepiece.txt 21/root/onepiece.txt 通过文件类型查找 linux中有7种文件类型，按文件类型查找时，语法规则如下： 1# 语法格式: 2$ find 搜索的路径 -type 文件类型 举例：
1# 搜索 root 用户家目录下, 软连接类型的文件 2[root@localhost ~]# find /root -type l 3/root/link.lnk 4/root/files/get/link.lnk 5/root/file/link 按照文件大小搜索 如果需要根据文件大小进行搜索，需要使用参数 -size。关于文件大小的单位有很多，可以根据实际需求选择，常用的分别有k(小写),M(大写),G(大写)。 在进行文件大小判断的时候，需要指定相应的范围，涉及的符号有两个分别为：加号 (+) 和 减号 (-)，下面具体说明其使用方法： 1# 语法格式: 2$ find 搜索的路径 -size [+|-]文件大小 3	- 文件大小需要加单位: 4	- k (小写) 5	- M (大写) 6	- G (大写) 关于文件大小的区间划分非常重要，这里以 4k 来举例: -size 4k 表示的区间为 (4-1k，4k], 表示一个区间，大于 3k, 小于等于 4k -size -4k: [0k, 4-1k], 表示一个区间，大于等于 0 并且 小于等于 3k -size +4k: (4k, 正无穷), 表示搜索大于 4k 的文件 举例：
1# 搜索当前目录下 大于1M的所有文件 (file&gt;3M) 2$ find ./ -size +3M 3 4# 搜索当前目录下 大于等于0M并且小于等于2M的文件 (0M &lt;= file &lt;=2M) 5$ find ./ -size -3M 6 7# 搜索当前目录下 大于2M并且小于等于3M的文件 (2M &lt; file &lt;=3M) 8$ find ./ -size 3M 9 10# 搜索当前目录下 大于1M 并且 小于等于 3M 的文件 11$ find ./ -size +1M -size -4M 同时执行多个操作 在搜索文件的时候如果想在一个find 执行多个操作，通过使用管道 | 的方式是行不通的，比如下面的操作:
1# 比如: 通过find搜索最多两层目录中后缀为 .txt 的文件, 然后再查看这些满足条件的文件的详细信息 2# 在find操作中直接通过管道操作多个指令, 最终输出的结果是有问题, 因此不能直接这样使用 3$ find ./ -maxdepth 2 -name &#34;*.txt&#34; | ls -l 4total 612 5drwxr-xr-x 2 root root 4096 Jan 26 18:11 a 6-rw-r--r-- 1 root root 269 Jan 26 17:44 a.c 7drwxr-xr-x 3 root root 4096 Jan 26 18:39 ace 8drwxr-xr-x 4 root root 4096 Jan 25 15:21 file 9lrwxrwxrwx 1 root root 24 Jan 25 17:27 link.lnk -&gt; /root/files/onepiece.txt 10drwxr-xr-x 4 root root 4096 Jan 26 18:39 files 11-r--r--r-- 1 root root 37 Jan 26 16:50 onepiece.txt 12-rw-r--r-- 1 root root 598314 Dec 2 02:07 rarlinux-x64-6.0.0.tar.gz 如果想要实现上面的需求，需要在 find中使用exec,ok,xargs, 这样就可以在find命令执行完毕之后，再执行其他的子命令了。
exec -exec是find的参数，可以在exec参数后添加其他需要被执行的shell命令。 find添加了exec参数之后，命令的尾部需要加一个后缀 {} \ , 注意{}和 \之间需要有一个空格。 在参数-exec后添加的shell命令处理的是find搜索之后的结果，find的结果会作为新添加的shell命令的输入，最后在终端上输出最终的处理结果。
1# 语法： 2$ find 路径 参数 参数值 -exec shell命令2 {} \; 3 4# 搜索最多两层目录, 文件名后缀为 .txt的文件 5$ find ./ -maxdepth 2 -name &#34;*.txt&#34; 6./files/root.txt 7./files/onepiece.txt 8./onepiece.txt 9 10# 搜索到满足条件的文件之后, 再继续查看文件的详细属性信息 11$ find ./ -maxdepth 2 -name &#34;*.txt&#34; -exec ls -l {} \; 12-rw-r--r-- 1 root root 0 Jan 25 17:54 ./files/root.txt 13-r--r--r-- 2 root root 37 Jan 25 17:54 ./files/onepiece.txt 14-r--r--r-- 1 root root 37 Jan 26 16:50 ./onepiece.txt OK -ok和 -exec都是find命令的参数，使用方式类似，但是这个参数是交互式的，在处理find的结果的时候，会向用户发起询问，比如在删除搜索结果的时候，为了保险起见，就需要询问机制了。 语法格式如下:
1# 语法: 其实就是将 -exec 替换为 -ok, 其他都不变 2$ find 路径 参数 参数值 -ok shell命令2 {} \; 3 4# 搜索到了2个满足条件的文件 5$ find ./ -maxdepth 1 -name &#34;*.txt&#34; 6./aaaaa.txt 7./english.txt 8 9# 查找并显示文件详细信息 10$ find ./ -maxdepth 1 -name &#34;*.txt&#34; -ok ls -l {} \; 11&lt; ls ... ./aaaaa.txt &gt; ? y	# 同意显示文件详细信息 12-rw-rw-r-- 1 root root 10 Apr 17 11:34 ./aaaaa.txt 13&lt; ls ... ./english.txt &gt; ? n	# 不同意显示文件详细信息, 会跳过显示该条信息 14 15# 什么时候需要交互呢? ---&gt; 删除文件的时候 16$ find ./ -maxdepth 1 -name &#34;*.txt&#34; -ok rm -rf {} \; 17&lt; rm ... ./aaaaa.txt &gt; ? y	# 同意删除 18&lt; rm ... ./english.txt &gt; ? n	# 不同意删除 19 20# 删除一个文件之后再次进行相同的搜索 21$ find ./ -maxdepth 1 -name &#34;*.txt&#34; 22./english.txt	# 只剩下了一个.txt 文件 xargs 在使用find的 -exec参数的时候，需要在指定的子命令尾部添加几个特殊字符 {} \;，一不小心就容易写错，有一种看起来更加直观、书写更加简便的方式，我们可以使用xargs替换掉 -exec参数，而且在处理数据的时候xargs更高效。有了xargs的加持我们就可以在find命令中直接使用管道完成前后命令的数据传递，使用方法如下:
1# 在find 中 使用 xargs 关键字我们就可以使用管道了, 否则使用管道也不会起作用 2# 将 find 搜索的结果通过管道传递给后边的shell命令继续处理 3$ find 路径 参数 参数值 | xargs shell命令2 4 5# 查找文件 6$ find ./ -maxdepth 1 -name &#34;*.cpp&#34; 7./occi.cpp 8./main.cpp 9./test.cpp 10 11# 查找文件, 并且显示文件的详细信息 12root@OS:~$ find ./ -maxdepth 1 -name &#34;*.cpp&#34; | xargs ls -l 13-rw-r--r-- 1 root root 2223 Mar 2 2020 ./main.cpp 14-rw-r--r-- 1 root root 1406 Mar 2 2020 ./occi.cpp 15-rw-r--r-- 1 root root 2015 Mar 1 2020 ./test.cpp 16 17 18# xargs的效率比使用 -exec 效率高 19	-exec: 将find查询的结果逐条传递给后边的shell命令 20	-xargs: 将find查询的结果一次性传递给后边的shell命令 grep grep命令用于查找文件里符合条件的字符串。grep命令中有几个常用参数:
参数 含义 r 如果需要搜索目录中的文件内容，需要进行递归操作，必须指定该参数 i 对应要搜索的关键字，忽略字符大小写的差别 n 在显示符合样式的那一行之前，标示出该行的列数编号 1# 语法格式: 2# 对应要搜索的文件内容，建议放到引号中，因为关键字中可能有特殊字符，或者有空格，从而导致解析错误。 3# 关于引号， 单双都可以，可根据自己的需求选择。 4$ grep &#34;搜索的内容&#34; 搜索的路径/文件 参数 5 6# 举例： 7# 搜索指定文件中是否有字符串 include 8[root@localhost ~]# grep &#34;include&#34; a.c 9#include &lt;stdio.h&gt; 10#include &lt;unistd.h&gt; 11#include &lt;fcntl.h&gt; 12 13# 不区分大小写进行搜索 14[root@localhost ~]# grep &#34;INCLUDE&#34; a.c 15[root@localhost ~]# grep &#34;INCLUDE&#34; a.c -i 16#include &lt;stdio.h&gt; 17#include &lt;unistd.h&gt; 18#include &lt;fcntl.h&gt; 19 20# 搜索指定目录中哪些文件中包含字符串 include 并且显示关键字所在的行号 21[root@localhost ~]# grep &#34;include&#34; ./ -rn 22./a.c:1:#include &lt;stdio.h&gt; 23./a.c:2:#include &lt;unistd.h&gt; 24./a.c:3:#include &lt;fcntl.h&gt; 25./files/get/e.c:1:#include &lt;stdio.h&gt; 26./files/get/e.c:2:#include &lt;unistd.h&gt; 27./files/get/e.c:3:#include &lt;fcntl.h&gt; 28./files/c.c:1:#include &lt;stdio.h&gt; 29./files/c.c:2:#include &lt;unistd.h&gt; 30./files/c.c:3:#include &lt;fcntl.h&gt; 31./ace/b.c:1:#include &lt;stdio.h&gt; 32./ace/b.c:2:#include &lt;unistd.h&gt; 33./ace/b.c:3:#include &lt;fcntl.h&gt; 34./.bash_history:1449:grep &#34;include&#34; ./ 35./.bash_history:1451:grep &#34;include&#34; ./ -r 36./.bash_history:1465:grep &#34;include&#34; a.c ]]></content>
  </entry>
  
  <entry>
    <title>linux基础(一)</title>
    <url>/yfmff/yfmff.github.io.git/post/linux/linuxbase1/</url>
    <categories><category>linux</category>
    </categories>
    <tags>
    </tags>
    <content type="html"><![CDATA[
Linux目录 linux和window视觉上最大的不同，除了可视化的界面外，就是windows上能看到不同的盘符。linux中根目录的子目录结构相对是固定的，各个目录的功能也是固定的，常见目录的功能列举如下：
目录 功能 bin binary, 二进制文件目录，存储了可执行程序 sbin root用户使用的一些二进制可执行程序 etc 配置文件目录，系统的或者用户自己安装的应用程序的配置文件都存储在这个目录中 lib 存储了一些动态库和静态库，给系统或者安装的软件使用 media 挂载目录，挂载外部设备，比如：光驱，扫描仪 mnt 临时挂载目录，比如我们可以将 U 盘临时挂载到这个目录下 proc 内存使用的一个映射目录，给操作系统使用的 tmp 临时目录，存放临时数据，重启电脑数据就被自动删除了 boot 存储了开机相关的设置 home 存储了普通用户的家目录，家目录名和用户名相同 root root用户的家目录 dev 设备目录，Linux中一切皆文件，所有的硬件会抽象成文件存储起来，比如：键盘， 鼠标 lost+found 一般时候是空的，电脑异常关闭 / 崩溃时用来存储这些无家可归的文件，用于用户系统恢复 opt 第三方软件的安装目录 var 存储了系统使用的一些经常会发生变化的文件， 比如：日志文件 usr 系统的资源目录 /usr/bin 可执行的二进制应用程序 /usr/games 游戏目录 /usr/include 包含的标准头文件目录 /usr/local 和opt目录作用相同，安装第三方软件 对于用户自己的文件，一般都是存放到自己的家目录中，也就是 /home/用户名里边，通过指定的相应的路径就可以找到这个文件了。关于路径的指定的有两种方式：相对路径和绝对路径命令解析器 在linux中，一切操作都是通过和一个黑窗口交互来完成的，这个黑窗口就是终端，我们输入的命令最终都会被命令解析器执行，那么，命令解析器是如何工作的呢？
命令解析器是linux中的一个进程，叫做bash，也被称为shell或者sh，linux中默认使用bash，也支持sh。当我们在终端黑窗口输入命令时并按下回车时，命令解析器就开始工作了：
和window一样，linux中也有环境变量，名为PATH，里面存放了系统目录，通过以下命令可查看PATH 的值 1# 通过 echo 命令可以查看环境变量 PATH 中的值, 在shell中变量名前加 $ 就是取值 2[root@VM-8-14-centos ~]# echo $PATH 3/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin 命令解析器会搜索PATH目录，来看这些目录中有没有你输入的指令 如果找到了，就执行，这个目录没找到就继续找下一个目录，要是到最后的目录都还没找到，就报错 命令提示符号 1[root@localhost ~/tmpuser/dir/dir2]# 2[root@localhost ~/tmpuser/dir/dir2]$ 符号 含义 root 当前登录的用户的用户名 @ 在哪个主机上 localhost 主机名，装linux时会指定，可修改 ~ 当前用户的家目录(各个用户有自己的家目录，root用户为 /root，普通用户为 /home/用户名) ~/tmpuser/dir/dir2 当前用户在哪个工作目录，可用pwd查看 # 代表当前用户是root用户 ﹩ 代表当前用户是 普通用户 通用用命令 TAB 自动补齐，比如你要打开一个名为abcdefg.txt的文件，但是文件名太长记不住，你可以只输入abc，然后按TAB键，系统会自动帮你补齐。如果以abc开头的文件很多 ，就会列表出来给你看，需要你多打几个字母才能联想出来，当然，这个命令 还可以补全sh命令
cd 切换工作目录。
命令 含义 cd 目录名 比如cd /tmp 就是进入当前文件夹下叫做tmp的子文件夹中 cd . 还是在当前目录 cd ../ 跳到当前文件夹的上一层文件夹，等同于cd .. cd ~ 回到当前用户的家目录 cd - 在你最近访问过的两个目录之间切换 tree 该命令的作用是以树状结构显示目录 , tree工具默认是没有的，需要手动安装，centos安装方式是sudo yum install tree。
touch 使用touch命令可以创建一个新的空文件 , 如果指定的文件是已存在的，只会更新文件的修改日期，对内容没有任何影响。
重定向 关于重定向使用最多的是就是输出重定向 , 顾名思义就是修改输出的数据的位置，通过重定向操作我们可以非常方便的进行文件的复制，或者文件内容的追加。输出重定向使用的不是某个关键字而是符号 &gt; 或者 &raquo;。
&gt;: 将文件内容写入到指定文件中，如果文件中已有数据，则会使用新数据覆盖原数据。
&raquo;: 将输出的内容追加到指定的文件尾部。
1# 输出的重定向举例: printf默认是要将数据打印到终端, 可以修改默认的输出位置 =&gt; 重定向到某个文件中 2# 关键字 &gt; 3# 执行一个shell指令, 获得一个输出, 这个输出默认显示到终端, 如果要将其保存到文件中, 就可以使用重定向 4# 如果当前目录下test.txt不存在, 会被创建, 如果存在, 内容被覆盖 5$ date &gt; test.txt 6# 日期信息被写入到文件 test.txt中 7root@localhost:~/Linux$ cat test.txt 8Wed Apr 15 09:37:52 CST 2020 9 10# 如果不希望文件被覆盖, 而是追加, 需要使用 &gt;&gt; 11in@localhost:~/Linux$ date &gt;&gt; test.txt 12# 日期信息被追加到 test.txt中 13root@localhost:~/Linux$ cat test.txt 14Wed Apr 15 09:37:52 CST 2020 15Wed Apr 15 09:38:44 CST 2020 16 17# 继续追加信息 18root@localhost:~/Linux$ date &gt;&gt; test.txt 19root@localhost:~/Linux$ cat test.txt 20Wed Apr 15 09:37:52 CST 2020 21Wed Apr 15 09:38:44 CST 2020 22Wed Apr 15 09:39:03 CST 2020 文件相关命令 ls 打印文件信息，如果是目录，则显示目录中文件的信息。
命令 含义 ls -a 显示所有文件（包括隐藏文件，隐藏文件是文件名前有.的文件） ls -l 列表显示文件详细信息（类型、操作权限、创建时间、修改时间、名字等） ls -l在某些linux操作系统（如centos）可以简写成ll。 文件类型 linux中共有7种文件类型，通过看它们的前缀能进行分辨（如 -rw-r&ndash;r&ndash;)
前缀 含义 - 普通文件，不能执行的是白色，压缩包为红色，可执行的文件是绿色 d 说明这个文件是目录 l 软链接文件，相当于快捷方式 c 字符设备，用黄色字体表示 b 块设备，用黄色字体表示 p 管道文件，用棕黄色表示 s 套接字文件，用粉色字体表示 文件权限 r 读，w 写，x 执行，- 没有任何权限
1 - rwx rw- r-- 1 root root 2 | | | | 3文件类型 文件所有 文件所属 其他人权限 4 者权限 组权限 硬链接和软链接 硬链接是一个整数N，如果大于1，则说明在一个或多个目录下有N个文件，但是这N个文件不占多个空间，它们使用同一块内存空间，改动其中一个文件，其他的文件内容也就同时改变了。使用ln命令，就可创建一个硬链接。而软链接就是一个快捷方式罢了 。下面代码示范了软链接和硬链接的创建方法：
1# 创建软链接 2# 语法: ln -s 源文件路径 软链接文件的名字(可以带路径) 3 4# 查看目录文件 5[root@localhost ~/haha]# ll 6total 8 7drwxr-xr-x 3 root root 4096 Jan 25 17:27 get 8-rw-r--r-- 1 root root 37 Jan 25 17:26 onepiece.txt 9 10# 给 onepiece.txt 创建软连接, 放到子目录 get 中 11[root@localhost ~/haha]# ln -s /root/haha/onepiece.txt get/link.lnk 12[root@localhost ~/haha]# ll get 13total 4 14lrwxrwxrwx 1 root root 24 Jan 25 17:27 link.lnk -&gt; /root/haha/onepiece.txt 15drwxr-xr-x 2 root root 4096 Jan 24 21:37 onepiece 16 17######################################################## 18# 创建硬链接 19# 语法: ln 源文件 硬链接文件的名字(可以带路径) 20 21# 创建硬链接文件, 放到子目录中 22[root@localhost ~/haha]# ln onepiece.txt get/link.txt 23 24# 查看链接文件和硬链接计数, 从 1 --&gt; 2 25[root@localhost ~/haha]# ll get 26total 8 27lrwxrwxrwx 1 root root 24 Jan 25 17:27 link.lnk -&gt; /root/haha/onepiece.txt 28-rw-r--r-- 2 root root 37 Jan 25 17:26 link.txt 29drwxr-xr-x 2 root root 4096 Jan 24 21:37 onepiece 创建和删除文件夹 创建目录：mkdir 文件夹名称[-p]。可选参数：p代表递归创建，即一次创建多层。 删除目录：rm [-irf] 文件名。可选参数：i是删除时给提示，r，代表递归删除（子文件夹及其里面的文件也会删除），f代表强制删除。
cp 拷贝命令
1# 文件不存在得到新文件, 文件存在就覆盖 2# 目录不存在得到新目录, 该目录被拷贝到存在的目录中 3# 拷贝目录需要 -r 4cp 源目录 目标目录 -r 5cp 源文件 新文件名（可指明目录） mv 移动或者重命名文件
1mv 源文件 目标目录 2mv 源文件名A 新文件名B(如果A和B都存在，则A消失，B文件内容为A的内容) 修改文件属性 修改文件权限 文件权限是针对文件所有者 , 文件所属组用户 , 其他人这三类人而言的，对应的操作指令是 chmod 。设置方式也有两种，分别为文字设定法和数字设定法。 文字设定法是通过一些关键字 r, w, x, - 来描述用户对文件的操作权限。 数字设定法是通过一些数字 0, 1, 2, 4, 5, 6, 7 来描述用户对文件的操作权限。 文字设定法：
1#chmod 2# 语法格式: chmod who [+|-|=] mod 文件名 3	- who: 4	- u: user -&gt; 文件所有者 5	- g: group -&gt; 文件所属组用户 6	- o: other -&gt; 其他 7	- a: all, 以上是三类人 u+g+o 8	- 对权限的操作: 9	+: 添加权限 10	-: 去除权限 11	=: 权限的覆盖 12	- mod: 权限 13	r: read, 读 14	w: write, 写 15	x: execute, 执行 16	-: 没有权限 17	18# 将文件所有者权限设置为读和执行, 也就是权限覆盖 19root@localhost:~/Linux$ chmod u=rx b.txt 20root@localhost:~/Linux$ ll b.txt 21-r-xrw-r-- 2 root root 2929 Apr 14 18:53 b.txt* 22 23# 给其他人添加写和执行权限 24root@localhost:~/Linux$ chmod o+wx b.txt 25root@localhost:~/Linux$ ll b.txt 26-r-xrw-rwx 2 root root 2929 Apr 14 18:53 b.txt* 27 28# 给文件所属组用户去掉读和执行权限 29root@localhost:~/Linux$ chmod g-rx b.txt 30root@localhost:~/Linux$ ll b.txt 31-r-x-w-rwx 2 root root 2929 Apr 14 18:53 b.txt* 32 33# 将文件所有者,文件所属组用户,其他人权限设置为读+写+执行 34root@localhost:~/Linux$ chmod a=rwx b.txt 35root@localhost:~/Linux$ ll b.txt 36-rwxrwxrwx 2 root root 2929 Apr 14 18:53 b.txt* 数字设定法：
1# 语法格式: chmod [+|-|=] mod 文件名 2	- 对权限的操作: 3	+: 添加权限 4	-: 去除权限 5	=: 权限的覆盖, 等号可以不写 6	- mod: 权限描述, 所有权限都放开是 7 7	- 4: read, r 8	- 2: write, w 9	- 1: execute , x 10	- 0: 没有权限 11	12# 分解: chmod 0567 a.txt 13 14 0 5 6 7 15 八进制 文件所有者 文件所属组用户 其他人 16 r + x r + w r+w+x 17 18######################### 举例 ######################### 19# 查看文件 c.txt 的权限	20root@localhost:~/Linux$ ll c.txt 21-rwxrwxrwx 2 root root 2929 Apr 14 18:53 c.txt* 22 23# 文件所有者去掉执行权限, 所属组用户去掉写权限, 其他人去掉读+写权限 24root@localhost:~/Linux$ chmod -123 c.txt 25root@localhost:~/Linux$ ll c.txt 26-rw-r-xr-- 2 root root 2929 Apr 14 18:53 c.txt* 27 28# 文件所有者添加执行权限, 所属组用户和其他人权限不变 29root@localhost:~/Linux$ chmod +100 c.txt 30root@localhost:~/Linux$ ll c.txt 31-rwxr-xr-- 2 root root 2929 Apr 14 18:53 c.txt* 32 33# 将文件所有者,文件所属组用户,其他人权限设置为读+写, 没有执行权限 34root@localhost:~/Linux$ chmod 666 c.txt 35root@localhost:~/Linux$ ll c.txt 36-rw-rw-rw- 2 root root 2929 Apr 14 18:53 c.txt 修改文件所有者 默认情况下，文件是通过哪个用户创建出来的，就属于哪个用户，这个用户属于哪个组，文件就属于哪个组。如果有特殊需求，可以修改文件所有者，对应的操作命令是chown。因为修改文件所有者就跨用户操作，普通用户没有这个权限，需要借助管理员权限才能完成该操作。 普通用户借助管理员权限执行某些shell命令, 需要在命令前加关键字sudo, 但是普通用户默认是没有使用sudo的资格的, 需要修改 /etc/sudoers文件。
1# 语法1-只修改所有者: 2$ sudo chown 新的所有者 文件名 3 4# 语法2-同时修改所有者和所属组: 5$ sudo chown 新的所有者:新的组名 文件名 6 7# 查看文件所有者：b.txt 属于 root 用户 8root@localhost:~/Linux$ ll b.txt 9-rw-rw-rw- 2 root root 2929 Apr 14 18:53 b.txt 10 11# 将 b.txt 的所有者修改为 luffy 12root@localhost:~/Linux$ sudo chown luffy b.txt 13[sudo] password for root: 14root@localhost:~/Linux$ ll b.txt 15-rw-rw-rw- 2 luffy root 2929 Apr 14 18:53 b.txt 16 17# 修改文件所有者和文件所属组 18# 查看文件所有者和所属组 19root@localhost:~/Linux$ ll b.txt 20-rw-rw-rw- 2 luffy root 2929 Apr 14 18:53 b.txt 21 22# 同时修改文件所有者和文件所属组 23root@localhost:~/Linux$ sudo chown root:luffy b.txt 24root@localhost:~/Linux$ ll b.txt 25-rw-rw-rw- 2 root luffy 2929 Apr 14 18:53 b.txt 修改文件所属组 普通用户没有修改文件所属组的权限，如果需要修改需要借助管理员权限才能完成，需要使用的命令是chgrp。当然了这个属性的修改也可以使用chown命令来完成。
1# 只修改文件所属的组, 普通用户没有这个权限, 借助管理员的权限 2# 语法: sudo chgrp 新的组 文件名 3 4# 查看文件所属组信息 5root@localhost:~/Linux$ ll b.txt 6-rw-rw-rw- 2 root luffy 2929 Apr 14 18:53 b.txt 7 8# 修改文件所属的组 9root@localhost:~/Linux$ sudo chgrp root b.txt 10root@localhost:~/Linux$ ll b.txt 11-rw-rw-rw- 2 root root 2929 Apr 14 18:53 b.txt ]]></content>
  </entry>
  
  <entry>
    <title>git相关操作</title>
    <url>/yfmff/yfmff.github.io.git/post/others/gitnote/</url>
    <categories>
    </categories>
    <tags>
      <tag>git</tag>
    </tags>
    <content type="html"><![CDATA[最近入职了一家新的公司，要求使用gitlab来管理项目代码（前公司使用的是SVN），之前没接触过，故在此总结下常用的git命令以及创建或者从仓库中下载/上传代码的相关操作。 使用git管理代码需要账号，如果是gitlab的话，需要你公司给你注册账号。注册 在github上注册你的账号，会要求你输入你的账号名称、邮箱、密码，记得保管好。
生成SSHKey 我们工作时，要么是将代码从服务器下载到本地，要么是将本地代码传到服务器。上传和下载时，服务器都需要验证身份，为了简化操作，可以采用SSHKey。在一个空文件夹，鼠标右键，点击git bash here，输入以下指令： 1ssh-keygen -t rsa -C &#34;youxiang@xx.com&#34; # 邮箱地址 指令执行完后，会在c盘user文件夹下生成 .ssh文件夹，打开得到id_rsa.pub文件，打开并原样复制。 打开github或者gitlab的账号设置，将刚刚复制得到的密钥复制并保存。 此后，在本地关联服务器的代码仓库后，只需输入一次账号密码，以后上传或下载代码就不再需要重复输入了。 本地库关联服务器远程库 这里有两种情况：
服务器上已经有项目仓库了，我们需要下载一个本地使用的副本。 服务器上没有项目，我们本地写好后，想在服务器新建一个仓库来管理代码。 服务器已有项目 得到想要下载的项目库的地址(以我的临时代码仓库为例子)。 确定你想要放代码的文件夹，然后鼠标右键，点击git bash here。输入以下代码： 1git clone -b master git@github.com:yfmff/mff_git_io.git 操作完成后，会在当前文件夹新建一个和你项目一样名称的文件夹，拉取的代码就在此文件夹中（我的是mff_git_io)。 当然，你也可以采用另一种方法，和服务器的代码仓库建立联系，执行以下代码： 1git init 2git remote add 主机名 git@github.com:yfmff/mff_git_io.gi 主机名默认是origin，此时，当前文件夹不会新建mff_git_io这个文件夹，而是直接吧mff_git_io文件夹中的文件下载到当前文件夹中。
本地新建项目上传到服务器 在github或者gitlab上新建一个空项目，并复制下此项目的网络地址。 在项目文件的父文件夹，点击git bash here,运行以下命令： 1git init 2git add * # 将所有文件都添加到缓存区 3git commit –m “初次上传文件” 4git remote add origin git@github.com:yfmff/mff_git_io.git # 只需要执行一次 5 6# git push 的完全体是 git push &lt;远程主机名&gt;&lt;本地分支名&gt;:&lt;远程分支名&gt; 7git push –u origin master #分支名 执行完后，本地仓库的代码就提交到远程仓库了。 本地代码关联服务器的过程中会认证你的身份，执行以下命令：
1git config –[global] user.name &#34;名称&#34; 2git config –[global] user.email&#34;邮箱&#34; 3# global 全局，如果不加则默认只在当前文件夹下 接下来，你和同事就可以愉快的开发了，你的同事修改了某个文件，你需要更新本地文件，执行以下代码即可：
1git pull 2# git pull的完全体是 git pull &lt;远程主机名&gt; &lt;分支名&gt;:&lt;本地分支名&gt; 3git pull -r origin master # 可以避免出现merge 4# 或者 5git fetch 6git merge 分支操作 项目可以有很多分支，比如，一个主分支master，用来制作发布版本，而平常的开发都放在另一个分支中，开发完成后再合并到主分支中。常用的分支操作如下：
1git branch dev # 新建名叫dev的分支（本地） 2git checkout dev # 本地转到dev分支下工作 3git checkout –b dev	# 新建dev分支并切换到dev分支工作 4git push origin –u dev # 将新建的分支提交到服务器 5git branch origin –delete dev # 删除服务器上的dev分支 6git merge master # master分支合并到当前分支 7git branch # 查看当前分支 8git branch –d(D为强制删除) xxx # 删除本地名为xxx的分支 冲突处理 可以选择放弃本地最新的修改，采用服务器的版本覆盖本地仓库以及工作区间，再更新到远程仓库就不会冲突了（git pull 或者git merge dev）。 1git checkout head 解决冲突后提交本地修改 将本地修改放入缓存区(成功后本地工作区间的代码跟本地仓库代码会同步)， 具体指令： 1 git stash 缓存当前的代码，去其他分支干别的事 如果要修复一个bug，不过当前正在dev分支上进行的工作只进行到一半，还没法提交，git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：
1# 储藏当前工作状态 2git stash 3 4# 首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支（本地） 5git checkout master 6git checkout -b issue 7 8# 修复完成后，切换到master分支，并完成合并，最后删除issue分支 9git checkout master 10git merge issue # 本地的master分支改了，但是服务器的没改，需要上传服务器 11git push –u origin master 12 13# 现在，是时候接着回到dev分支干活了！ 14git checkout dev 15 16# 恢复现场 17git stash pop 其他命令 删除 1# 将文件从工作区和暂存区删除：git rm -f xxx 2# 将文件只从暂存区删除：git rm –cached xxxx 3# 递归删除： git rm –r * xxx（xxx如果是一个目录，则会递归的删除目录中所有文件） 4git rm 移动或者重命名命令 1git mv [old] [new] 上传修改的代码 1git add [文件名] # 将修改的文件都添加到缓存区 2git commit –m &#34;上传的原因&#34; 3git push –u origin master # master为分支名 ]]></content>
  </entry>
  
  <entry>
    <title>enable_shared_from_this</title>
    <url>/yfmff/yfmff.github.io.git/post/cpp/enableshared/</url>
    <categories><category>cpp</category>
    </categories>
    <tags>
    </tags>
    <content type="html"><![CDATA[enable_shared_from_this是一个模版类，从C++11开始支持。定义在头文件 memory中：template&lt; class T &gt; class enable_shared_from_this;基本概念 enable_shared_from_this 可以让一个 已经被一个共享智能指针管理的对象（假设为Obj）安全的生成其他额外的、指向Obj的共享指针shared_ptr。具体方式是：enable_shared_from_this有一个成员函数，shared_from_this()，用指向Obj的指针或Obj自己调用此函数，即可返回一个新的share_ptr对象。 shared_ptr有引用计数，每多一个shared_ptr指向同一个变量时，shared_ptr引用计数增加1，反之，则减少1，等到引用计数减为0时，该变量所占用的内存就被释放了。为什么需要这个类呢？ 我们需要在类对象的内部中获得一个指向当前对象的shared_ptr对象。 当一个类被share_ptr管理，且在类的成员函数里需要把当前类对象作为参数传给其他函数时，这时就需要传递一个指向自身的share_ptr。 原理剖析 首先看下enable_shared_from_this的源代码：
1template&lt;class T&gt; class enable_shared_from_this 2{ 3protected: 4 5 BOOST_CONSTEXPR enable_shared_from_this() BOOST_SP_NOEXCEPT 6 { } 7 BOOST_CONSTEXPR enable_shared_from_this(enable_shared_from_this const &amp;) BOOST_SP_NOEXCEPT 8 { } 9 enable_shared_from_this &amp; operator=(enable_shared_from_this const &amp;) BOOST_SP_NOEXCEPT 10 { 11 return *this; 12 } 13 ~enable_shared_from_this() BOOST_SP_NOEXCEPT // ~weak_ptr&lt;T&gt; newer throws, so this call also must not throw 14 { 15 } 16public: 17 shared_ptr&lt;T&gt; shared_from_this() 18 { 19 shared_ptr&lt;T&gt; p( weak_this_ ); 20 BOOST_ASSERT( p.get() == this ); 21 return p; 22 } 23 24 shared_ptr&lt;T const&gt; shared_from_this() const 25 { 26 shared_ptr&lt;T const&gt; p( weak_this_ ); 27 BOOST_ASSERT( p.get() == this ); 28 return p; 29 } 30 31 weak_ptr&lt;T&gt; weak_from_this() BOOST_SP_NOEXCEPT 32 { 33 return weak_this_; 34 } 35 36 weak_ptr&lt;T const&gt; weak_from_this() const BOOST_SP_NOEXCEPT 37 { 38 return weak_this_; 39 } 40 41public: // actually private, but avoids compiler template friendship issues 42 43 // Note: invoked automatically by shared_ptr; do not call 44 template&lt;class X, class Y&gt; void _internal_accept_owner( shared_ptr&lt;X&gt; const * ppx, Y * py ) const BOOST_SP_NOEXCEPT 45 { 46 if( weak_this_.expired() ) 47 { 48 weak_this_ = shared_ptr&lt;T&gt;( *ppx, py ); 49 } 50 } 51 52private: 53 mutable weak_ptr&lt;T&gt; weak_this_;//注意这里 54}; 55 56#endif // #ifndef BOOST_SMART_PTR_ENABLE_SHARED_FROM_THIS_HPP_INCLUDED 单独把 shared_from_this() 拿出来：
1 shared_ptr&lt;T&gt; shared_from_this() 2 { 3 shared_ptr&lt;T&gt; p( weak_this_ ); 4 BOOST_ASSERT( p.get() == this ); 5 return p; 6 } 可见，在函数中，构建了一个临时的共享指针p，但是这个p是由类的成员变量weak_this_（弱指针）初始化的！ 对于一个派生自enable_shared_from_this的类的对象而言，每次调用shared_from_this()，都是根据同一个弱指针来构造一个临时的shared_ptr对象，这就保证了执行 shared_from_this() 返回的共享指针指向同一块内存。但是，在调用 shared_from_this() 之前，weak_this_ 必须被初始化，因为它是指向该派生类对象所有shared_ptr的源头。
那么，weak_this_ 是在什么时候初始化的呢？ 假设我们有一个test类，派生自enable_shared_from_this，当我们生成test类对象时，必定会调用构造函数，自然也会调用enable_shared_from_this的构造函数。而在调用基类的构造函数时，会初始化定义enable_shared_from_this中的私有成员变量 weak_this_ 为 null_ptr，这时的 weak_this_ 是无效的（或者说不指向任何对象）。 接着，当我们在外部定义一个shared_ptr，指向test类对象时：shared_ptr ptr1(new test()); 此时，shared_ptr的构造函数会执行：
1template&lt;class Y&gt; 2 explicit shared_ptr( Y * p ): px( p ), pn( p ) 3 { 4 boost::detail::sp_enable_shared_from_this( this, p, p ); 5 } 里面调用了 boost::detail::sp_enable_shared_from_this( this, p, p ); 具体看此函数：
1template&lt; class X, class Y, class T &gt; 2 inline void sp_enable_shared_from_this( boost::shared_ptr&lt;X&gt; const * ppx, 3 Y const * py, boost::enable_shared_from_this&lt; T &gt; const * pe ) 4{ 5 if( pe != 0 ) 6 { 7 pe-&gt;_internal_accept_owner( ppx, const_cast&lt; Y* &gt;( py ) ); 8 } 9} 里面又调用了 enable_shared_from_this 的 _internal_accept_owner：
1template&lt;class X, class Y&gt; void _internal_accept_owner( shared_ptr&lt;X&gt; const * ppx, Y * py ) const 2 { 3 if( weak_this_.expired() ) 4 { 5 weak_this_ = shared_ptr&lt;T&gt;( *ppx, py ); 6 } 7 } 至此，enable_shared_from_this类的成员weak_this_进行拷贝赋值，使得weak_this_作为类对象shared_ptr的一个观察者。这时，如果我们类对象本身需要自身的shared_ptr时，就可以调用 shared_from_this() 生成一个了。
特别注意 由上可知，test类对象obj，要是想使用shared_from_this()，就必须保证已经被至少一个shared_ptr所管理。因此，下面的代码是错误的！1class test:public enable_shared_from_this&lt;test&gt; 2{ 3 test(); 4 virtual ~test(); 5} 6 7test* tmp_obj=new test(); 8shared_ptr&lt;test&gt; ptr1 = tmp_obj-&gt;shared_from_this(); //错误！ ]]></content>
  </entry>
  
  <entry>
    <title>C++ 线程同步</title>
    <url>/yfmff/yfmff.github.io.git/post/cpp/threadsyn/</url>
    <categories><category>cpp</category>
    </categories>
    <tags>
    </tags>
    <content type="html"><![CDATA[
C++原生的线程同步方式有以下几种：
std::mutex 互斥锁。
1mutex mymutex; 2mymutex.lock(); //会阻塞 3// mymutex.trylock(); //不会阻塞 4// 临界资源 5mymutex.unlock(); 在所有线程的任务函数执行完毕之前，互斥锁对象是不能被析构的，一定要在程序中保证这个对象的可用性。 斥锁的个数和共享资源的个数相等，也就是说每一个共享资源都应该对应一个互斥锁对象。互斥锁对象的个数和线程的个数没有关系。 std::lock_guard 哨兵锁lock_guard是C++11新增的一个模板类，使用这个类，可以简化互斥锁lock()和unlock()的写法，同时也更安全。这个模板类的定义和常用的构造函数原型如下：
1// 类的定义，定义于头文件 &lt;mutex&gt; 2template&lt; class Mutex &gt; 3class lock_guard; 4 5// 常用构造函数 6explicit lock_guard( mutex_type&amp; m ); / 传入一个锁 lock_guard在使用上面提供的这个构造函数构造对象时，会自动锁定互斥量，而在退出作用域后进行析构时就会自动解锁，从而保证了互斥量的正确操作，避免忘记unlock()操作而导致线程死锁。
std::recursive_mutex 递归互斥锁std::recursive_mutex允许同一线程多次获得互斥锁，可以用来解决同一线程需要多次获取互斥量时死锁的问题。
1#include &lt;iostream&gt; 2#include &lt;thread&gt; 3#include &lt;mutex&gt; 4using namespace std; 5 6struct Calculate 7{ 8 Calculate() : m_i(6) {} 9 10 void mul(int x) 11 { 12 lock_guard&lt;mutex&gt; locker(m_mutex); 13 m_i *= x; 14 } 15 16 void div(int x) 17 { 18 lock_guard&lt;mutex&gt; locker(m_mutex); 19 m_i /= x; 20 } 21 22 void both(int x, int y) 23 { 24 lock_guard&lt;mutex&gt; locker(m_mutex); 25 mul(x); 26 div(y); 27 } 28 29 int m_i; 30 mutex m_mutex; // 会产生死锁，而采用recursive_mutex可以解决这个问题 31}; 32 33int main() 34{ 35 Calculate cal; 36 cal.both(6, 3); 37 return 0; 38} 使用递归互斥锁的场景往往都是可以简化的，使用递归互斥锁很容易放纵复杂逻辑的产生，从而导致bug的产生 递归互斥锁比非递归互斥锁效率要低一些。 递归互斥锁虽然允许同一个线程多次获得同一个互斥锁的所有权，但最大次数并未具体说明，一旦超过一定的次数，就会抛出std::system错误。 std::timed_mutex std::timed_mutex是超时独占互斥锁，主要是在获取互斥锁资源时增加了超时等待功能，因为不知道获取锁资源需要等待多长时间，为了保证不一直等待下去，设置了一个超时时长，超时后线程就可以解除阻塞去做其他事情了。
std::timed_mutex比std::_mutex多了两个成员函数：try_lock_for()和try_lock_until()：
1void lock(); 2bool try_lock(); 3void unlock(); 4 5// std::timed_mutex比std::_mutex多出的两个成员函数 6template &lt;class Rep, class Period&gt; 7 bool try_lock_for (const chrono::duration&lt;Rep,Period&gt;&amp; rel_time); 8 9template &lt;class Clock, class Duration&gt; 10 bool try_lock_until (const chrono::time_point&lt;Clock,Duration&gt;&amp; abs_time); try_lock_for函数是当线程获取不到互斥锁资源的时候，让线程阻塞一定的时间长度。 try_lock_until函数是当线程获取不到互斥锁资源的时候，让线程阻塞到某一个指定的时间点。 关于两个函数的返回值：当得到互斥锁的所有权之后，函数会马上解除阻塞，返回true，如果阻塞的时长用完或者到达指定的时间点之后，函数也会解除阻塞，返回false。 举例： 1#include &lt;iostream&gt; 2#include &lt;thread&gt; 3#include &lt;mutex&gt; 4using namespace std; 5 6timed_mutex g_mutex; 7 8void work() 9{ 10 chrono::seconds timeout(1); 11 while (true) 12 { 13 // 通过阻塞一定的时长来争取得到互斥锁所有权 14 if (g_mutex.try_lock_for(timeout)) 15 { 16 cout &lt;&lt; &#34;当前线程ID: &#34; &lt;&lt; this_thread::get_id() 17 &lt;&lt; &#34;, 得到互斥锁所有权...&#34; &lt;&lt; endl; 18 // 模拟处理任务用了一定的时长 19 this_thread::sleep_for(chrono::seconds(10)); 20 // 互斥锁解锁 21 g_mutex.unlock(); 22 break; 23 } 24 else 25 { 26 cout &lt;&lt; &#34;当前线程ID: &#34; &lt;&lt; this_thread::get_id() 27 &lt;&lt; &#34;, 没有得到互斥锁所有权...&#34; &lt;&lt; endl; 28 // 模拟处理其他任务用了一定的时长 29 this_thread::sleep_for(chrono::milliseconds(50)); 30 } 31 } 32} 33 34int main() 35{ 36 thread t1(work); 37 thread t2(work); 38 39 t1.join(); 40 t2.join(); 41 42 return 0; 43} 关于递归超时互斥锁std::recursive_timed_mutex的使用方式和std::timed_mutex是一样的，只不过它可以允许一个线程多次获得互斥锁所有权，而std::timed_mutex只允许线程获取一次互斥锁所有权。另外，递归超时互斥锁std::recursive_timed_mutex也拥有和 std::recursive_mutex一样的弊端，不建议频繁使用。
条件变量 条件变量是 C++11 提供的另外一种用于等待的同步机制，它能阻塞一个或多个线程，直到收到另外一个线程发出的通知或者超时时，才会唤醒当前阻塞的线程。条件变量需要和互斥量配合起来使用，C++11 提供了两种条件变量：
条件变量 条件 condition_variable 需要配合std::unique_lockstd::mutex进行wait操作 condition_variable_any 可以和任意带有lock()、unlock() 的mutex 使用 condition_variable condition_variable的成员函数主要分为两部分：线程等待（阻塞）函数 和线程通知（唤醒）函数，这些函数被定义于头文件 &lt;condition_variable&gt;。
等待函数 1// 调用该函数的线程直接被阻塞 2void wait (unique_lock&lt;mutex&gt;&amp; lck); 3 4// 该函数的第二个参数是一个判断条件，是一个返回值为布尔类型的函数 5// 表达式返回false当前线程被阻塞，表达式返回true当前线程不会被阻塞，继续向下执行 6template &lt;class Predicate&gt; 7void wait (unique_lock&lt;mutex&gt;&amp; lck, Predicate pred); 独占的互斥锁对象不能直接传递给 wait() 函数，需要通过模板类 unique_lock 进行二次处理，通过得到的对象仍然可以对独占的互斥锁对象做如下操作，使用起来更灵活。如果线程被该函数阻塞，这个线程会释放占有的互斥锁的所有权。 当阻塞解除之后这个线程会重新得到互斥锁的所有权，继续向下执行， 这个过程是在函数内部完成的，了解这个过程即可，其目的是为了避免线程的死锁。 wait_for()函数和 wait()的功能是一样的，只不过多了一个阻塞时长，假设阻塞的线程没有被其他线程唤醒，当阻塞时长用完之后，线程就会自动解除阻塞，继续向下执行。
1template &lt;class Rep, class Period&gt; 2cv_status wait_for (unique_lock&lt;mutex&gt;&amp; lck, 3 const chrono::duration&lt;Rep,Period&gt;&amp; rel_time); 4	5template &lt;class Rep, class Period, class Predicate&gt; 6bool wait_for(unique_lock&lt;mutex&gt;&amp; lck, 7 const chrono::duration&lt;Rep,Period&gt;&amp; rel_time, Predicate pred); wait_until() 函数和 wait_for() 的功能是一样的，它是指定让线程阻塞到某一个时间点，假设阻塞的线程没有被其他线程唤醒，当到达指定的时间点之后，线程就会自动解除阻塞，继续向下执行。
1template &lt;class Clock, class Duration&gt; 2cv_status wait_until (unique_lock&lt;mutex&gt;&amp; lck, 3 const chrono::time_point&lt;Clock,Duration&gt;&amp; abs_time); 4 5template &lt;class Clock, class Duration, class Predicate&gt; 6bool wait_until (unique_lock&lt;mutex&gt;&amp; lck, 7 const chrono::time_point&lt;Clock,Duration&gt;&amp; abs_time, Predicate pred); 通知函数 1void notify_one() noexcept; //唤醒一个被当前条件变量阻塞的线程 2void notify_all() noexcept; // 唤醒全部被当前条件变量阻塞的线程 例子：
1#include &lt;iostream&gt; 2#include &lt;thread&gt; 3#include &lt;mutex&gt; 4#include &lt;list&gt; 5#include &lt;functional&gt; 6#include &lt;condition_variable&gt; 7using namespace std; 8 9class SyncQueue 10{ 11public: 12 SyncQueue(int maxSize) : m_maxSize(maxSize) {} 13 14 void put(const int&amp; x) 15 { 16 unique_lock&lt;mutex&gt; locker(m_mutex); 17 // 判断任务队列是不是已经满了 18 while (m_queue.size() == m_maxSize) 19 { 20 cout &lt;&lt; &#34;任务队列已满, 请耐心等待...&#34; &lt;&lt; endl; 21 // 阻塞线程 22 m_notFull.wait(locker); 23 } 24 // 将任务放入到任务队列中 25 m_queue.push_back(x); 26 cout &lt;&lt; x &lt;&lt; &#34; 被生产&#34; &lt;&lt; endl; 27 // 通知消费者去消费 28 m_notEmpty.notify_one(); 29 } 30 31 int take() 32 { 33 unique_lock&lt;mutex&gt; locker(m_mutex); 34 while (m_queue.empty()) 35 { 36 cout &lt;&lt; &#34;任务队列已空，请耐心等待。。。&#34; &lt;&lt; endl; 37 m_notEmpty.wait(locker); 38 } 39 // 从任务队列中取出任务(消费) 40 int x = m_queue.front(); 41 m_queue.pop_front(); 42 // 通知生产者去生产 43 m_notFull.notify_one(); 44 cout &lt;&lt; x &lt;&lt; &#34; 被消费&#34; &lt;&lt; endl; 45 return x; 46 } 47 48 bool empty() 49 { 50 lock_guard&lt;mutex&gt; locker(m_mutex); 51 return m_queue.empty(); 52 } 53 54 bool full() 55 { 56 lock_guard&lt;mutex&gt; locker(m_mutex); 57 return m_queue.size() == m_maxSize; 58 } 59 60 int size() 61 { 62 lock_guard&lt;mutex&gt; locker(m_mutex); 63 return m_queue.size(); 64 } 65 66private: 67 list&lt;int&gt; m_queue; // 存储队列数据 68 mutex m_mutex; // 互斥锁 69 condition_variable m_notEmpty; // 不为空的条件变量 70 condition_variable m_notFull; // 没有满的条件变量 71 int m_maxSize; // 任务队列的最大任务个数 72}; 73 74int main() 75{ 76 SyncQueue taskQ(50); 77 auto produce = bind(&amp;SyncQueue::put, &amp;taskQ, placeholders::_1); 78 auto consume = bind(&amp;SyncQueue::take, &amp;taskQ); 79 thread t1[3]; 80 thread t2[3]; 81 for (int i = 0; i &lt; 3; ++i) 82 { 83 t1[i] = thread(produce, i+100); 84 t2[i] = thread(consume); 85 } 86 87 for (int i = 0; i &lt; 3; ++i) 88 { 89 t1[i].join(); 90 t2[i].join(); 91 } 92 93 return 0; 94} condition_variable_any condition_variable_any的成员函数也是分为两部分：线程等待（阻塞）函数 和线程通知（唤醒）函数，这些函数被定义于头文件 &lt;condition_variable&gt;。
等待函数 1// 调用该函数的线程直接被阻塞 2template &lt;class Lock&gt; void wait (Lock&amp; lck); 3// 该函数的第二个参数是一个判断条件，是一个返回值为布尔类型的函数 4// 表达式返回false当前线程被阻塞，表达式返回true当前线程不会被阻塞，继续向下执行 5template &lt;class Lock, class Predicate&gt; 6void wait (Lock&amp; lck, Predicate pred); 可以直接传递给 wait() 函数的互斥锁类型有四种:std::mutex、std::timed_mutex、std::recursive_mutex、std::recursive_timed_mutex。 如果线程被该函数阻塞，这个线程会释放占有的互斥锁的所有权，当阻塞解除之后这个线程会重新得到互斥锁的所有权，继续向下执行（这个过程是在函数内部完成的，了解这个过程即可，其目的是为了避免线程的死锁）。 wait_for() 函数和 wait() 的功能是一样的，只不过多了一个阻塞时长，假设阻塞的线程没有被其他线程唤醒，当阻塞时长用完之后，线程就会自动解除阻塞，继续向下执行。
1template &lt;class Lock, class Rep, class Period&gt; 2cv_status wait_for (Lock&amp; lck, const chrono::duration&lt;Rep,Period&gt;&amp; rel_time); 3	4template &lt;class Lock, class Rep, class Period, class Predicate&gt; 5bool wait_for (Lock&amp; lck, const chrono::duration&lt;Rep,Period&gt;&amp; rel_time, Predicate pred); wait_until() 函数和 wait_for() 的功能是一样的，它是指定让线程阻塞到某一个时间点，假设阻塞的线程没有被其他线程唤醒，当到达指定的时间点之后，线程就会自动解除阻塞，继续向下执行。
1template &lt;class Lock, class Clock, class Duration&gt; 2cv_status wait_until (Lock&amp; lck, const chrono::time_point&lt;Clock,Duration&gt;&amp; abs_time); 3 4template &lt;class Lock, class Clock, class Duration, class Predicate&gt; 5bool wait_until (Lock&amp; lck, 6 const chrono::time_point&lt;Clock,Duration&gt;&amp; abs_time, 7 Predicate pred); 通知函数 1void notify_one() noexcept; // 唤醒一个阻塞的线程 2void notify_all() noexcept; // 唤醒全部阻塞的线程 举例：
1#include &lt;iostream&gt; 2#include &lt;thread&gt; 3#include &lt;mutex&gt; 4#include &lt;list&gt; 5#include &lt;functional&gt; 6#include &lt;condition_variable&gt; 7using namespace std; 8 9class SyncQueue 10{ 11public: 12 SyncQueue(int maxSize) : m_maxSize(maxSize) {} 13 14 void put(const int&amp; x) 15 { 16 lock_guard&lt;mutex&gt; locker(m_mutex); 17 // 根据条件阻塞线程 18 m_notFull.wait(m_mutex, [this]() { 19 return m_queue.size() != m_maxSize; 20 }); 21 // 将任务放入到任务队列中 22 m_queue.push_back(x); 23 cout &lt;&lt; x &lt;&lt; &#34; 被生产&#34; &lt;&lt; endl; 24 // 通知消费者去消费 25 m_notEmpty.notify_one(); 26 } 27 28 int take() 29 { 30 lock_guard&lt;mutex&gt; locker(m_mutex); 31 m_notEmpty.wait(m_mutex, [this]() { 32 return !m_queue.empty(); 33 }); 34 // 从任务队列中取出任务(消费) 35 int x = m_queue.front(); 36 m_queue.pop_front(); 37 // 通知生产者去生产 38 m_notFull.notify_one(); 39 cout &lt;&lt; x &lt;&lt; &#34; 被消费&#34; &lt;&lt; endl; 40 return x; 41 } 42 43 bool empty() 44 { 45 lock_guard&lt;mutex&gt; locker(m_mutex); 46 return m_queue.empty(); 47 } 48 49 bool full() 50 { 51 lock_guard&lt;mutex&gt; locker(m_mutex); 52 return m_queue.size() == m_maxSize; 53 } 54 55 int size() 56 { 57 lock_guard&lt;mutex&gt; locker(m_mutex); 58 return m_queue.size(); 59 } 60 61private: 62 list&lt;int&gt; m_queue; // 存储队列数据 63 mutex m_mutex; // 互斥锁 64 condition_variable_any m_notEmpty; // 不为空的条件变量 65 condition_variable_any m_notFull; // 没有满的条件变量 66 int m_maxSize; // 任务队列的最大任务个数 67}; 68 69int main() 70{ 71 SyncQueue taskQ(50); 72 auto produce = bind(&amp;SyncQueue::put, &amp;taskQ, placeholders::_1); 73 auto consume = bind(&amp;SyncQueue::take, &amp;taskQ); 74 thread t1[3]; 75 thread t2[3]; 76 for (int i = 0; i &lt; 3; ++i) 77 { 78 t1[i] = thread(produce, i + 100); 79 t2[i] = thread(consume); 80 } 81 82 for (int i = 0; i &lt; 3; ++i) 83 { 84 t1[i].join(); 85 t2[i].join(); 86 } 87 88 return 0; 89} ]]></content>
  </entry>
  
  <entry>
    <title>C++多线程</title>
    <url>/yfmff/yfmff.github.io.git/post/cpp/thread/</url>
    <categories><category>cpp</category>
    </categories>
    <tags>
    </tags>
    <content type="html"><![CDATA[
构造函数 1thread() noexcept; //默认构造函，构造一个线程对象，在这个线程中不执行任何处理动作 2thread( thread&amp;&amp; other ) noexcept; //移动构造函数，将 other 的线程所有权转移给新的 thread 对象。之后 other 不再表示执行线程。 3// 创建线程对象，并在该线程中执行函数f中的业务逻辑，args 是要传递给函数 f 的参数 4template&lt; class Function, class... Args &gt; 5explicit thread( Function&amp;&amp; f, Args&amp;&amp;... args ); 6// 使用 =delete 显示删除拷贝构造，不允许线程对象之间的拷贝 7thread( const thread&amp; ) = delete; 成员函数 get_id() 1std:🧵:id get_id() const noexcept; //获取线程 ID join() join() 字面意思是连接一个线程，意味着主动地等待线程的终止（线程阻塞）。在某个线程中通过子线程对象调用join() 函数，调用这个函数的线程被阻塞，但是子线程对象中的任务函数会继续执行，当任务执行完毕之后join() 会清理当前子线程中的相关资源然后返回，同时，调用该函数的线程解除阻塞继续向下执行。函数在哪个线程中被执行，那么函数就阻塞哪个线程。如果要阻塞主线程的执行，只需要在主线程中通过子线程对象调用这个方法即可，当调用这个方法的子线程对象中的任务函数执行完毕之后，主线程的阻塞也就随之解除了。
detach() detach() 函数的作用是进行线程分离，分离主线程和创建出的子线程。在线程分离之后，主线程退出也会一并销毁创建出的所有子线程，在主线程退出之前，它可以脱离主线程继续独立的运行，任务执行完毕之后，这个子线程会自动释放自己占用的系统资源。线程分离函数detach()不会阻塞线程，子线程和主线程分离之后，在主线程中就不能再对这个子线程做任何控制了，比如：通过join()阻塞主线程等待子线程中的任务执行完毕，或者调用get_id ()获取子线程的线程ID。有利就有弊，鱼和熊掌不可兼得，建议使用 join()。
joinable() joinable() 函数用于判断主线程和子线程是否处理关联（连接）状态，一般情况下，二者之间的关系处于关联状态，该函数返回一个布尔类型。
在创建的子线程对象的时候，如果没有指定任务函数，那么子线程不会启动，主线程和这个子线程也不会进行连接 在创建的子线程对象的时候，如果指定了任务函数，子线程启动并执行任务，主线程和这个子线程自动连接成功 子线程调用了detach()函数之后，父子线程分离，同时二者的连接断开，调用joinable()返回false 在子线程调用了join()函数，子线程中的任务函数继续执行，直到任务处理完毕，这时join()会清理（回收）当前子线程的相关资源，所以这个子* 线程和主线程的连接也就断开了，因此，调用join()之后再调用joinable()会返回false。 this_thread 关于线程的命名空间std::this_thread,提供了四个公共的成员函数:
get_id() 得到线程ID。 sleep_for() 调用这个函数的线程会马上从运行态变成阻塞态并在这种状态下休眠一定的时长，因为阻塞态的线程已经让出了 CPU 资源，代码也不会被执行，所以线程休眠过程中对 CPU 来说没有任何负担。 sleep_until() 和sleep_for()不同的是它的参数类型不一样，功能是一样的。 yield() 在线程中调用这个函数之后，处于运行态的线程会主动让出自己已经抢到的CPU时间片，最终变为就绪态，这样其它的线程就有更大的概率能够抢到CPU时间片了，目的是避免一个线程长时间占用CPU资源，从而导致多线程处理性能下降。使用这个函数的时候需要注意一点，线程调用了 yield() 之后会主动放弃CPU资源，但是这个变为就绪态的线程会马上参与到下一轮CPU的抢夺战中，不排除它能继续抢到CPU时间片的情况，这是概率问题。 ]]></content>
  </entry>
  
  <entry>
    <title>C++ 线程异步</title>
    <url>/yfmff/yfmff.github.io.git/post/cpp/threadasyn/</url>
    <categories><category>cpp</category>
    </categories>
    <tags>
    </tags>
    <content type="html"><![CDATA[
std::future C++11 中增加的线程类，使得我们能够非常方便的创建和使用线程，但有时会有些不方便，比如需要获取线程返回的结果，就不能通过join()得到结果，只能通过一些额外手段获得，比如：定义一个全局变量，在子线程中赋值，在主线程中读这个变量的值，整个过程比较繁琐。C++ 提供的线程库中提供了一些类用于访问异步操作的结果。 future是一个模板类，也就是这个类可以存储任意指定类型的数据。
1// 定义于头文件 &lt;future&gt; 2template&lt; class T &gt; class future; 3template&lt; class T &gt; class future&lt;T&amp;&gt;; 4template&lt;&gt; class future&lt;void&gt;; 5 6future() noexcept; 7future( future&amp;&amp; other ) noexcept; 8future( const future&amp; other ) = delete; 以下函数用于取出future对象内部保存的数据，其中void get() 是为 future 准备的，此时对象内部类型就是void，该函数是一个阻塞函数，当子线程的数据就绪后解除阻塞就能得到传出的数值了。
1T get(); 2T&amp; get(); 3void get(); 因为future对象内部存储的是异步线程任务执行完毕后的结果，是在调用之后的将来得到的，因此可以通过调用 wait() 方法，阻塞当前线程，等待这个子线程的任务执行完毕，任务执行完毕当前线程的阻塞也就解除了。
1void wait() const; 如果当前线程wait() 方法就会死等，直到子线程任务执行完毕将返回值写入到 future对象中，调用 wait_for() 只会让线程阻塞一定的时长，但是这样并不能保证对应的那个子线程中的任务已经执行完毕了。
wait_until() 和 wait_for() 函数功能是差不多，前者是阻塞到某一指定的时间点，后者是阻塞一定的时长。
1template&lt; class Rep, class Period &gt; 2std::future_status wait_for( const std::chrono::duration&lt;Rep,Period&gt;&amp; timeout_duration ) const; 3 4template&lt; class Clock, class Duration &gt; 5std::future_status wait_until( const std::chrono::time_point&lt;Clock,Duration&gt;&amp; timeout_time ) const; 当wait_until() 和 wait_for() 函数返回之后，并不能确定子线程当前的状态，因此我们需要判断函数的返回值，这样就能知道子线程当前的状态了：
状态值 意义 future_status::deferred 子线程中的任务函仍未启动 future_status::ready 子线程中的任务已经执行完毕，结果已就绪 future_status::timeout 子线程中的任务正在执行中，指定等待时长已用完 std::promise 成员函数 std::promise是一个协助线程赋值的类，它能够将数据和future对象绑定起来，为获取线程函数中的某个值提供便利。std::promise是一个模板类，我们要在线程中传递什么类型的数据，模板参数就指定为什么类型。
1// 定义于头文件 &lt;future&gt; 2template&lt; class R &gt; class promise; 3template&lt; class R &gt; class promise&lt;R&amp;&gt;; 4template&lt;&gt; class promise&lt;void&gt;; 5 6promise(); 7promise( promise&amp;&amp; other ) noexcept; 8promise( const promise&amp; other ) = delete; 在std::promise类内部管理着一个future类对象，调用get_future()就可以得到这个future对象了。
1std::future&lt;T&gt; get_future(); 存储要传出的value值，并立即让状态就绪，这样数据被传出其它线程就可以得到这个数据了。重载的第四个函数是为 promise 类型的对象准备的。
1void set_value( const R&amp; value ); 2void set_value( R&amp;&amp; value ); 3void set_value( R&amp; value ); 4void set_value(); 存储要传出的value值，但是不立即令状态就绪。在当前线程退出时，子线程资源被销毁，再令状态就绪。
1void set_value_at_thread_exit( const R&amp; value ); 2void set_value_at_thread_exit( R&amp;&amp; value ); 3void set_value_at_thread_exit( R&amp; value ); 4void set_value_at_thread_exit(); 用法 在主线程中创建std::promise对象 将这个std::promise对象通过引用的方式传递给子线程的任务函数 在子线程任务函数中给std::promise对象赋值 在主线程中通过std::promise对象取出绑定的future实例对象 通过得到的future对象取出子线程任务函数中返回的值。 1#include &lt;iostream&gt; 2#include &lt;thread&gt; 3#include &lt;future&gt; 4using namespace std; 5 6int main() 7{ 8 promise&lt;int&gt; pr; 9 thread t1([](promise&lt;int&gt; &amp;p) { 10 p.set_value(100); // 子线程任务函数执行期间，让状态就绪 11 //p.set_value_at_thread_exit(100); //子线程任务函数执行结束，让状态就绪 12 this_thread::sleep_for(chrono::seconds(3)); 13 cout &lt;&lt; &#34;睡醒了....&#34; &lt;&lt; endl; 14 }, ref(pr)); 15 16 future&lt;int&gt; f = pr.get_future(); 17 int value = f.get(); 18 cout &lt;&lt; &#34;value: &#34; &lt;&lt; value &lt;&lt; endl; 19 20 t1.join(); 21 return 0; 22} 在外部主线程中创建的promise对象必须要通过引用的方式传递到子线程的任务函数中，在实例化子线程对象的时候，如果任务函数的参数是引用类型，那么实参一定要放到**std::ref()**函数中，表示要传递这个实参的引用到任务函数中。std::packaged_task std::packaged_task类包装了一个可调用对象包装器类对象（可调用对象包装器包装的是可调用对象，可调用对象都可以作为函数来使用）。这个类可以将内部包装的函数和future类绑定到一起，以便进行后续的异步调用，它和std::promise有点类似，std::promise内部保存一个共享状态的值，而std::packaged_task保存的是一个函数。
成员函数 1// 定义于头文件 &lt;future&gt; 2template&lt; class &gt; class packaged_task; 3template&lt; class R, class ...Args &gt; 4class packaged_task&lt;R(Args...)&gt;; 5 6packaged_task() noexcept; 7template &lt;class F&gt; 8explicit packaged_task( F&amp;&amp; f ); 9 10packaged_task( const packaged_task&amp; ) = delete; 11packaged_task( packaged_task&amp;&amp; rhs ) noexcept; 通过调用任务对象内部的get_future() 方法就可以得到一个 future 对象，基于这个对象就可以得到传出的数据了。
1std::future&lt;R&gt; get_future(); packaged_task 的使用 packaged_task其实就是对子线程要执行的任务函数进行了包装，和可调用对象包装器的使用方法相同，包装完毕之后直接将包装得到的任务对象传递给线程对象就可以了。
1#include &lt;iostream&gt; 2#include &lt;thread&gt; 3#include &lt;future&gt; 4using namespace std; 5 6int main() 7{ 8 packaged_task&lt;int(int)&gt; task([](int x) { 9 return x += 100; 10 }); 11 12 thread t1(ref(task), 100); 13 14 future&lt;int&gt; f = task.get_future(); 15 int value = f.get(); 16 cout &lt;&lt; &#34;value: &#34; &lt;&lt; value &lt;&lt; endl; 17 18 t1.join(); 19 return 0; 20} 在上面的示例代码中，通过packaged_task类包装了一个匿名函数作为子线程的任务函数，最终的得到的这个任务对象需要通过引用的方式传递到子线程内部，这样才能在主线程的最后通过任务对象得到future对象，再通过这个future对象取出子线程通过返回值传递出的数据。
std::async std::async函数比前面提到的std::promise和packaged_task更高级一些，因为通过这函数可以直接启动一个子线程并在这个子线程中执行对应的任务函数，异步任务执行完成返回的结果也是存储到一个future对象中，当需要获取异步任务的结果时，只需要调用future 类的get() 方法即可，如果不关注异步任务的结果，只是简单地等待任务完成的话，可以调用future 类的wait() 或者wait_for() 方法。该函数的函数原型如下：
1// 定义于头文件 &lt;future&gt; 2// 直接调用传递到函数体内部的可调用对象，返回一个 future 对象 3template&lt; class Function, class... Args&gt; 4std::future&lt;std::result_of_t&lt;std::decay_t&lt;Function&gt;(std::decay_t&lt;Args&gt;...)&gt;&gt; 5 async( Function&amp;&amp; f, Args&amp;&amp;... args ); 6 7// 通过指定的策略调用传递到函数内部的可调用对象，返回一个 future 对象 8template&lt; class Function, class... Args &gt; 9std::future&lt;std::result_of_t&lt;std::decay_t&lt;Function&gt;(std::decay_t&lt;Args&gt;...)&gt;&gt; 10 async( std::launch policy, Function&amp;&amp; f, Args&amp;&amp;... args ); launch policy：可调用对象・f 的执行策略:
policy 意义 std::launch::async 调用async函数时创建新的线程执行任务函数 std::launch::deferred 调用async函数时不执行任务函数，直到调用了future 的get() 或者wait() 时才执行任务（这种方式不会创建新的线程） 关于 std::async() 函数的使用，对应的示例代码如下：
调用 async () 函数直接创建线程执行任务: 1#include &lt;iostream&gt; 2#include &lt;thread&gt; 3#include &lt;future&gt; 4using namespace std; 5 6int main() 7{ 8 cout &lt;&lt; &#34;主线程ID: &#34; &lt;&lt; this_thread::get_id() &lt;&lt; endl; 9 // 调用函数直接创建线程执行任务 10 future&lt;int&gt; f = async([](int x) { 11 cout &lt;&lt; &#34;子线程ID: &#34; &lt;&lt; this_thread::get_id() &lt;&lt; endl; 12 this_thread::sleep_for(chrono::seconds(5)); 13 return x += 100; 14 }, 100); 15 16 future_status status; 17 do { 18 status = f.wait_for(chrono::seconds(1)); 19 if (status == future_status::deferred) 20 { 21 cout &lt;&lt; &#34;线程还没有执行...&#34; &lt;&lt; endl; 22 f.wait(); 23 } 24 else if (status == future_status::ready) 25 { 26 cout &lt;&lt; &#34;子线程返回值: &#34; &lt;&lt; f.get() &lt;&lt; endl; 27 } 28 else if (status == future_status::timeout) 29 { 30 cout &lt;&lt; &#34;任务还未执行完毕, 继续等待...&#34; &lt;&lt; endl; 31 } 32 } while (status != future_status::ready); 33 34 return 0; 35} 调用async() 函数时不指定策略就是直接创建线程并执行任务，示例代码的主线程中做了如下操作status = f.wait_for(chrono::seconds(1)); 其实直接调用f.get()就能得到子线程的返回值。这里为了演示wait_for() 的使用，所以写的复杂了些。
调用 async () 函数不创建线程执行任务 1#include &lt;iostream&gt; 2#include &lt;thread&gt; 3#include &lt;future&gt; 4using namespace std; 5 6int main() 7{ 8 cout &lt;&lt; &#34;主线程ID: &#34; &lt;&lt; this_thread::get_id() &lt;&lt; endl; 9 // 调用函数直接创建线程执行任务 10 future&lt;int&gt; f = async(launch::deferred, [](int x) { 11 cout &lt;&lt; &#34;子线程ID: &#34; &lt;&lt; this_thread::get_id() &lt;&lt; endl; 12 return x += 100; 13 }, 100); 14 15 this_thread::sleep_for(chrono::seconds(5)); 16 cout &lt;&lt; f.get(); 17 18 return 0; 19} 由于指定了launch::deferred策略，因此调用async()函数并不会创建新的线程执行任务，当使用future 类对象调用了get() 或者wait() 方法后才开始执行任务（此处一定要注意调用wait_for() 函数是不行的）。 两次输出的线程 ID 是相同的，任务函数是在主线程中被延迟（主线程休眠了 5 秒）调用了。
最终总结：
使用async() 函数，是多线程操作中最简单的一种方式，不需要自己创建线程对象，并且可以得到子线程函数的返回值。 使用std::promise类，在子线程中可以传出返回值也可以传出其他数据，并且可选择在什么时机将数据从子线程中传递出来，使用起来更灵活。 使用std::packaged_task类，可以将子线程的任务函数进行包装，并且可以得到子线程的返回值。 ]]></content>
  </entry>
  
  <entry>
    <title>关于 Hugo NexT 组织</title>
    <url>/yfmff/yfmff.github.io.git/about.html</url>
    <categories>
    </categories>
    <tags>
    </tags>
    <content type="html"><![CDATA[Hugo NexT 组织是由众多喜爱 NexT 主题及风格的世界各地友人共同组建而成，为的就是让这个主题继续在 Hugo 引擎中也能得到发扬光大，在此也欢迎你的加入！
我们的愿景 延续 NexT 经典的黑白调搭配，保持简单的易用性及强大的功能。
使用反馈 加入 GitHub Discussions或 Gitter在线讨论 🍻 GitHub Issues提交错误报告 🐛 GitHub Feature表新功能的想法 ✨ 同时国内用户也可加入 QQ 群交流： 604710815
]]></content>
  </entry>
  
  <entry>
    <title>C++ CallOnce</title>
    <url>/yfmff/yfmff.github.io.git/post/cpp/thread2/</url>
    <categories><category>cpp</category>
    </categories>
    <tags>
    </tags>
    <content type="html"><![CDATA[在某些特定情况下，某些函数只能在多线程环境下调用一次,就可以使用std::call_once()来保证函数在多线程环境下只能被调用一次。使用 call_once()的时候，需要一个once_flag作为 call_once() 的传入参数。
1// 定义于头文件 &lt;mutex&gt; 2template&lt; class Callable, class... Args &gt; 3void call_once( std::once_flag&amp; flag, Callable&amp;&amp; f, Args&amp;&amp;... args ); 使用实例：
1#include &lt;iostream&gt; 2#include &lt;thread&gt; 3#include &lt;mutex&gt; 4using namespace std; 5 6once_flag g_flag; 7void do_once(int a, string b) 8{ 9 cout &lt;&lt; &#34;name: &#34; &lt;&lt; b &lt;&lt; &#34;, age: &#34; &lt;&lt; a &lt;&lt; endl; 10} 11 12void do_something(int age, string name) 13{ 14 static int num = 1; 15 call_once(g_flag, do_once, 19, &#34;luffy&#34;); 16 cout &lt;&lt; &#34;do_something() function num = &#34; &lt;&lt; num++ &lt;&lt; endl; 17} 18 19int main() 20{ 21 thread t1(do_something, 20, &#34;ace&#34;); 22 thread t2(do_something, 20, &#34;sabo&#34;); 23 thread t3(do_something, 19, &#34;luffy&#34;); 24 t1.join(); 25 t2.join(); 26 t3.join(); 27 28 return 0; 29} ]]></content>
  </entry>
  
  <entry>
    <title>using关键字</title>
    <url>/yfmff/yfmff.github.io.git/post/cpp/using/</url>
    <categories><category>cpp</category>
    </categories>
    <tags>
    </tags>
    <content type="html"><![CDATA[之前，常用typedef定义别名：
1typedef 旧的类型名 新的类型名; 2// 使用举例 3typedef unsigned int uint_t; C++ 11后，可用using定义别名，格式如下：
1using 新的类型 = 旧的类型; 2// 使用举例 3using uint_t = int; 相比较typedef而言，using使用起来会更加简洁，代码可读性也更好，比如：
1// 使用typedef定义函数指针 2typedef int(*func_ptr)(int, double); 3 4// 使用using定义函数指针 5using func_ptr1 = int(*)(int, double); 模板的别名 使用typedef定义模版的别名是非常麻烦的：
1 2// 想要的效果： 3//typedef map&lt;int, string&gt; m1; 4//typedef map&lt;int, int&gt; m2; 5//typedef map&lt;int, double&gt; m3; 6 7//template &lt;typename T&gt; 8//typedef map&lt;int, T&gt; type;	// error, 语法错误 9 10// 需要一个外敷类 11#include &lt;iostream&gt; 12#include &lt;functional&gt; 13#include &lt;map&gt; 14using namespace std; 15 16template &lt;typename T&gt; 17// 定义外敷类 18struct MyMap 19{ 20 typedef map&lt;int, T&gt; type; 21}; 22 23int main(void) 24{ 25 MyMap&lt;string&gt;::type m; 26 m.insert(make_pair(1, &#34;luffy&#34;)); 27 m.insert(make_pair(2, &#34;ace&#34;)); 28 29 MyMap&lt;int&gt;::type m1; 30 m1.insert(1, 100); 31 m1.insert(2, 200); 32 33 return 0; 34} 而用using就很简单：
1#include &lt;iostream&gt; 2#include &lt;functional&gt; 3#include &lt;map&gt; 4using namespace std; 5 6template &lt;typename T&gt; 7using mymap = map&lt;int, T&gt;; 8 9int main(void) 10{ 11 // map的value指定为string类型 12 mymap&lt;string&gt; m; 13 m.insert(make_pair(1, &#34;luffy&#34;)); 14 m.insert(make_pair(2, &#34;ace&#34;)); 15 16 // map的value指定为int类型 17 mymap&lt;int&gt; m1; 18 m1.insert(1, 100); 19 m1.insert(2, 200); 20 21 return 0; 22} ]]></content>
  </entry>
  
  <entry>
    <title>C++智能指针</title>
    <url>/yfmff/yfmff.github.io.git/post/cpp/smartptr/</url>
    <categories><category>cpp</category>
    </categories>
    <tags>
    </tags>
    <content type="html"><![CDATA[
共享智能指针 由字面意思就可知道，这种指针可以和其他智能指针同时指向同一块内存，从而实现资源共享。shared_ptr是一个模版类，使用时需要指定类型。共享指针在初始化后就管理那块指向的内存了，其内部有用于记录这块内存被多少个其他智能指针指向的引用计数变量，每多一个智能指针指向这块内存，则引用计数+1，反之，减1。当共享 智能指针没有被初始化时，引用计数为0。当引用计数减少为0时，该内存就会被析构，同时，指针也会无效。
初始化的方式 1// 方法1： 2std::shared_ptr&lt;T&gt; 智能指针名字(创建堆内存); 3shared_ptr&lt;int&gt; ptr1(new int(250));//此时，引用计数为1 4 5// 方法2：通过拷贝和移动构造函数初始化 6shared_ptr&lt;int&gt; ptr2(ptr1); //此时，引用计数为2 7shared_ptr&lt;int&gt; ptr3 = ptr1;//此时，引用计数为3 8std::shared_ptr&lt;int&gt; ptr5 = std::move(ptr2); //此时，引用计数还是3 9 10//方法3： 11shared_ptr&lt;int&gt; tmp_ptr=make_shared&lt;int&gt;(100); 12 13// 方法4： 14shared_ptr&lt;int&gt; tmp_ptr2； 15tmp_ptr2.reset(new int(101)); 如果使用拷贝的方式初始化共享智能指针对象，这两个对象会同时管理同一块堆内存，堆内存对应的引用计数也会增加；如果使用移动的方式初始智能指针对象，只是转让了内存的所有权，管理内存的对象并不会增加，因此内存的引用计数不会变化。 对于一个未初始化的共享智能指针，可以通过reset方法来初始化，当智能指针中有值的时候，调用reset会使引用计数减1。 不要使用一个原始指针初始化多个shared_ptr。 指定删除器 C++11 中使用shared_ptr管理动态数组时，需要指定删除器，因为std::shared_ptr的默认删除器不支持数组对象。 删除器本质上就是一个函数，比如：
1#include &lt;iostream&gt; 2#include &lt;memory&gt; 3using namespace std; 4 5// 自定义删除器函数，释放int型内存 6void deleteIntPtr(int* p) 7{ 8 delete p; 9 cout &lt;&lt; &#34;int 型内存被释放了...&#34;; 10} 11 12int main() 13{ 14 shared_ptr&lt;int&gt; ptr(new int(250), deleteIntPtr); 15 return 0; 16} 删除器函数也可以是 lambda 表达式，因此代码也可以写成下面这样：
1int main() 2{ 3 shared_ptr&lt;int&gt; ptr(new int(250), [](int* p) {delete p; }); 4 return 0; 5} 接下来就可以写共享指针管理数组时的删除器了：
1int main() 2{ 3 shared_ptr&lt;int&gt; ptr(new int[10], default_delete&lt;int[]&gt;()); 4 return 0; 5} 独占智能指针 std::unique_ptr是一个独占型的智能指针，它不允许其他的智能指针共享其内部的指针，可以通过它的构造函数初始化一个独占智能指针对象，但是不允许通过赋值将一个unique_ptr赋值给另一个 unique_ptr。
初始化 1// 通过构造函数初始化对象 2unique_ptr&lt;int&gt; ptr1(new int(10)); 3// error, 不允许将一个unique_ptr赋值给另一个unique_ptr 4unique_ptr&lt;int&gt; ptr2 = ptr1; std::unique_ptr不允许复制，但是可以通过函数返回给其他的std::unique_ptr，还可以通过std::move来转译给其他的 std::unique_ptr，这样原始指针的所有权就被转移了，这个原始指针还是被独占的,比如：
1#include &lt;iostream&gt; 2#include &lt;memory&gt; 3using namespace std; 4 5unique_ptr&lt;int&gt; func() 6{ 7 return unique_ptr&lt;int&gt;(new int(520)); 8} 9 10int main() 11{ 12 // 通过构造函数初始化 13 unique_ptr&lt;int&gt; ptr1(new int(10)); 14 // 通过转移所有权的方式初始化 15 unique_ptr&lt;int&gt; ptr2 = move(ptr1); 16 unique_ptr&lt;int&gt; ptr3 = func(); 17 18 return 0; 19} std::unique_ptr 也可reset() 来解除对原始内存的管理，也可以用来初始化一个独占的智能指针。如果想要获取独占智能指针管理的原始地址，可以调用get() 方法。
删除器 unique_ptr 指定删除器和shared_ptr指定删除器是有区别的，unique_ptr指定删除器的时候需要确定删除器的类型，所以不能像 shared_ptr 那样直接指定删除器，举例说明：
1shared_ptr&lt;int&gt; ptr1(new int(10), [](int*p) {delete p; });	// ok 2unique_ptr&lt;int&gt; ptr1(new int(10), [](int*p) {delete p; });	// error 3 4int main() 5{ 6 using func_ptr = void(*)(int*); 7 unique_ptr&lt;int, func_ptr&gt; ptr1(new int(10), [](int*p) {delete p; }); 8 9 return 0; 10} 在上面的代码中第 7 行，func_ptr的类型和lambda表达式的类型是一致的。在lambda表达式没有捕获任何变量的情况下是正确的，如果捕获了变量，编译时则会报错：
1int main() 2{ 3 using func_ptr = void(*)(int*); 4 unique_ptr&lt;int, func_ptr&gt; ptr1(new int(10), [&amp;](int*p) {delete p; });	// error 5 return 0; 6} 上面的代码中错误原因是这样的，在 lambda 表达式没有捕获任何外部变量时，可以直接转换为函数指针，一旦捕获了就无法转换了，如果想要让编译器成功通过编译，那么需要使用可调用对象包装器来处理声明的函数指针：
1int main() 2{ 3 using func_ptr = void(*)(int*); 4 unique_ptr&lt;int, function&lt;void(int*)&gt;&gt; ptr1(new int(10), [&amp;](int*p) {delete p; }); 5 return 0; 6} 弱引用指针 弱引用智能指针std::weak_ptr可以看做是shared_ptr的助手，它不管理shared_ptr内部的指针。std::weak_ptr没有重载操作符 * 和 -&gt;，因为它不共享指针，不能操作资源，所以它的构造不会增加引用计数，析构也不会 减少引用计数，它的主要作用就是作为一个旁观者监视shared_ptr 中管理的资源是否存在。
初始化 1// 默认构造函数 2constexpr weak_ptr() noexcept; 3// 拷贝构造 4weak_ptr (const weak_ptr&amp; x) noexcept; 5template &lt;class U&gt; weak_ptr (const weak_ptr&lt;U&gt;&amp; x) noexcept; 6// 通过shared_ptr对象构造 7template &lt;class U&gt; weak_ptr (const shared_ptr&lt;U&gt;&amp; x) noexcept; 其他常用方法 use_count()：获得当前所观测资源的引用计数。 expired()：判断观测的资源是否已经被释放。 lock()：获取管理所监测资源的shared_ptr对象。 reset()：清空弱引用指针对象，使其不监测任何资源。 解决循环引用问题 1#include &lt;iostream&gt; 2#include &lt;memory&gt; 3using namespace std; 4 5struct TA; 6struct TB; 7 8struct TA 9{ 10 weak_ptr&lt;TB&gt; bptr; 11 ~TA() 12 { 13 cout &lt;&lt; &#34;class TA is disstruct ...&#34; &lt;&lt; endl; 14 } 15}; 16 17struct TB 18{ 19 shared_ptr&lt;TA&gt; aptr; 20 ~TB() 21 { 22 cout &lt;&lt; &#34;class TB is disstruct ...&#34; &lt;&lt; endl; 23 } 24}; 25 26void testPtr() 27{ 28 shared_ptr&lt;TA&gt; ap(new TA); 29 shared_ptr&lt;TB&gt; bp(new TB); 30 cout &lt;&lt; &#34;TA object use_count: &#34; &lt;&lt; ap.use_count() &lt;&lt; endl; 31 cout &lt;&lt; &#34;TB object use_count: &#34; &lt;&lt; bp.use_count() &lt;&lt; endl; 32 33 ap-&gt;bptr = bp; 34 bp-&gt;aptr = ap; 35 cout &lt;&lt; &#34;TA object use_count: &#34; &lt;&lt; ap.use_count() &lt;&lt; endl; 36 cout &lt;&lt; &#34;TB object use_count: &#34; &lt;&lt; bp.use_count() &lt;&lt; endl; 37} 38 39int main() 40{ 41 testPtr(); 42 return 0; 43} ]]></content>
  </entry>
  
  <entry>
    <title>lambda表达式</title>
    <url>/yfmff/yfmff.github.io.git/post/cpp/lambda/</url>
    <categories><category>cpp</category>
    </categories>
    <tags>
    </tags>
    <content type="html"><![CDATA[
基本语法 lambda表达式的基本语法归纳下来就是：
1[capture](params) opt -&gt; ret {body;}; 其中capture是捕获列表，params是参数列表，opt是函数选项，ret是返回值类型，body是函数体。 除了函数体（body）外，其他参数均可忽略，如：
auto func=[](){return 1;}; // 没捕获列表，参数列表 捕获列表 规则如下：
[] - 不捕捉任何变量 [&amp;] - 捕获外部作用域中所有变量，并作为引用在函数体内使用 (按引用捕获) [=] - 捕获外部作用域中所有变量，并作为副本在函数体内使用 (按值捕获) 拷贝的副本在匿名函数体内部是只读的 [=, &amp;foo] - 按值捕获外部作用域中所有变量，并按照引用捕获外部变量foo [bar] - 按值捕获bar变量，同时不捕获其他变量 [&amp;bar] - 按引用捕获bar变量，同时不捕获其他变量 [this] - 捕获当前类中的 this 指针 此时，lambda表达式拥有和当前类成员函数同样的访问权限 如果已经使用了 **&amp;**或者 =, 默认添加此选项 在匿名函数内部，需要通过lambda表达式的捕获列表控制如何捕获外部变量，以及访问哪些变量。默认状态下lambda表达式无法修改通过复制方式捕获外部变量，如果希望修改这些外部变量，需要通过引用的方式进行捕获。当然，按值捕获的情况下如果也想修改外部变量的话，可以通过mutable关键字。1int a = 0; 2auto f1 = [=] {return a++; }; // error, 按值捕获外部变量, a是只读的 3auto f2 = [=]()mutable {return a++; }; // ok 为什么通过值拷贝的方式捕获的外部变量是只读的？ 因为lambda表达式的类型在C++11中会被看做是一个带operator() 的类，即仿函数，按照C++标准，lambda表达式的operator()默认是const的，一个const成员函数是无法修改成员变量值的。mutable 选项的作用就在于取消operator() 的 const 属性。
]]></content>
  </entry>
  
  <entry>
    <title>可调用对象包装器</title>
    <url>/yfmff/yfmff.github.io.git/post/cpp/function/</url>
    <categories><category>cpp</category>
    </categories>
    <tags>
    </tags>
    <content type="html"><![CDATA[
可调用对象 可以是一个函数指针： 1int haha(int a,int b) 2{ 3 cout&lt;&lt;a&lt;&lt;b; 4} 5// 定义函数指针 6int(*myfunc)(int,int)=&amp;haha; 是一个具有operator()成员函数的类对象（仿函数） 1#include &lt;iostream&gt; 2#include &lt;string&gt; 3#include &lt;vector&gt; 4using namespace std; 5 6struct Test 7{ 8 // ()操作符重载 9 void operator()(string msg) 10 { 11 cout &lt;&lt; &#34;msg: &#34; &lt;&lt; msg &lt;&lt; endl; 12 } 13}; 14 15int main(void) 16{ 17 Test t; 18 t(&#34;haaah&#34;);	// 仿函数 19 return 0; 20} 是一个可被转换为函数指针的类对象。 1#include &lt;iostream&gt; 2#include &lt;string&gt; 3#include &lt;vector&gt; 4using namespace std; 5 6using func_ptr = void(*)(int, string); 7struct Test 8{ 9 static void print(int a, string b) 10 { 11 cout &lt;&lt; &#34;name: &#34; &lt;&lt; b &lt;&lt; &#34;, age: &#34; &lt;&lt; a &lt;&lt; endl; 12 } 13 14 // 将类对象转换为函数指针 15 operator func_ptr() 16 { 17 return print; 18 } 19}; 20 21int main(void) 22{ 23 Test t; 24 // 对象转换为函数指针, 并调用 25 t(19, &#34;faker&#34;); 26 27 return 0; 28} 是一个类成员函数指针或者类成员指针 1#include &lt;iostream&gt; 2#include &lt;string&gt; 3#include &lt;vector&gt; 4using namespace std; 5 6struct Test 7{ 8 void print(int a, string b) 9 { 10 cout &lt;&lt; &#34;name: &#34; &lt;&lt; b &lt;&lt; &#34;, age: &#34; &lt;&lt; a &lt;&lt; endl; 11 } 12 int m_num; 13}; 14 15int main(void) 16{ 17 // 定义类成员函数指针指向类成员函数 18 void (Test::*func_ptr)(int, string) = &amp;Test::print; 19 // 类成员指针指向类成员变量 20 int Test::*obj_ptr = &amp;Test::m_num; 21 22 Test t; 23 // 通过类成员函数指针调用类成员函数 24 (t.*func_ptr)(19, &#34;faker&#34;); 25 // 通过类成员指针初始化类成员变量 26 t.*obj_ptr = 1; 27 cout &lt;&lt; &#34;number is: &#34; &lt;&lt; t.m_num &lt;&lt; endl; 28 29 return 0; 30} C++ 中的可调用类型繁多，如果我们需要写一个函数，形参需要同时支持这4种可调用对象做为参，会很麻烦，得定义4个功能相同的函数，但是，通过std::function和std::bind便可统一这些操作。
可调用对象包装器 std::function是可调用对象的包装器。它是一个类模板，可以容纳除了类成员（函数）指针之外的所有可调用对象。通过指定它的模板参数，它可以用统一的方式处理函数、函数对象、函数指针，并允许保存和延迟执行它们。
用法 使用前需要：
1#include &lt;functional&gt; 2std::function&lt;返回值类型(参数类型列表)&gt; diy_name = 可调用对象; 3 4// 例子 5#include &lt;iostream&gt; 6#include &lt;functional&gt; 7using namespace std; 8 9int add(int a, int b) 10{ 11 cout &lt;&lt; a &lt;&lt; &#34; + &#34; &lt;&lt; b &lt;&lt; &#34; = &#34; &lt;&lt; a + b &lt;&lt; endl; 12 return a + b; 13} 14 15class T1 16{ 17public: 18 static int sub(int a, int b) 19 { 20 cout &lt;&lt; a &lt;&lt; &#34; - &#34; &lt;&lt; b &lt;&lt; &#34; = &#34; &lt;&lt; a - b &lt;&lt; endl; 21 return a - b; 22 } 23}; 24 25class T2 26{ 27public: 28 int operator()(int a, int b) 29 { 30 cout &lt;&lt; a &lt;&lt; &#34; * &#34; &lt;&lt; b &lt;&lt; &#34; = &#34; &lt;&lt; a * b &lt;&lt; endl; 31 return a * b; 32 } 33}; 34 35int main(void) 36{ 37 // 绑定一个普通函数 38 function&lt;int(int, int)&gt; f1 = add; 39 // 绑定以静态类成员函数 40 function&lt;int(int, int)&gt; f2 = T1::sub; 41 // 绑定一个仿函数 42 T2 t; 43 function&lt;int(int, int)&gt; f3 = t; 44 45 // 函数调用 46 f1(9, 3); 47 f2(9, 3); 48 f3(9, 3); 49 50 return 0; 51} 作为回调函数使用 回调函数本身就是通过函数指针实现的，使用对象包装器可以取代函数指针的作用：
1#include &lt;iostream&gt; 2#include &lt;functional&gt; 3using namespace std; 4 5class A 6{ 7public: 8 // 构造函数参数是一个包装器对象 9 A(const function&lt;void()&gt;&amp; f) : callback(f) 10 { 11 } 12 13 void notify() 14 { 15 callback(); // 调用通过构造函数得到的函数指针 16 } 17private: 18 function&lt;void()&gt; callback; 19}; 20 21class B 22{ 23public: 24 void operator()() 25 { 26 cout &lt;&lt; &#34;我是要成为海贼王的男人!!!&#34; &lt;&lt; endl; 27 } 28}; 29int main(void) 30{ 31 B b; 32 A a(b); // 仿函数通过包装器对象进行包装 33 a.notify(); 34 35 return 0; 36} 最终调用的是B类对象的void operator()()。
绑定器 std::bind用来将可调用对象与其参数一起进行绑定。绑定后的结果可以使用std::function进行保存，并延迟调用到任何我们需要的时候。它主要有两大作用：
将可调用对象与其参数一起绑定成一个仿函数。 将多元（参数个数为n，n&gt;1）可调用对象转换为一元或者（n-1）元可调用对象，即只绑定部分参数。 绑定器函数使用语法格式如下：
1// 绑定非类成员函数/变量 2auto f = std::bind(可调用对象地址, 绑定的参数/占位符); 3// 绑定类成员函/变量 4auto f = std::bind(类函数/成员地址, 类实例对象地址, 绑定的参数/占位符); 5 6// 例子 7#include &lt;iostream&gt; 8#include &lt;functional&gt; 9using namespace std; 10 11void callFunc(int x, const function&lt;void(int)&gt;&amp; f) 12{ 13 if (x % 2 == 0) 14 { 15 f(x); 16 } 17} 18 19void output(int x) 20{ 21 cout &lt;&lt; x &lt;&lt; &#34; &#34;; 22} 23 24void output_add(int x) 25{ 26 cout &lt;&lt; x + 10 &lt;&lt; &#34; &#34;; 27} 28 29int main(void) 30{ 31 // 使用绑定器绑定可调用对象和参数 32 auto f1 = bind(output, placeholders::_1); 33 for (int i = 0; i &lt; 10; ++i) 34 { 35 callFunc(i, f1); 36 } 37 cout &lt;&lt; endl; 38 39 auto f2 = bind(output_add, placeholders::_1); 40 for (int i = 0; i &lt; 10; ++i) 41 { 42 callFunc(i, f2); 43 } 44 cout &lt;&lt; endl; 45 46 return 0; 47} 在上面的程序中，使用了std::bind绑定器，在函数外部通过绑定不同的函数，控制了最后执行的结果。std::bind绑定器返回的是一个仿函数类型，得到的返回值可以直接赋值给一个std::function，在使用的时候我们并不需要关心绑定器的返回值类型，使用auto进行自动类型推导就可以了。
placeholders::_1是一个占位符，代表这个位置将在函数调用时被传入的第一个参数所替代。同样还有其他的占位符placeholders::_2、placeholders::_3、placeholders::_4、placeholders::_5等……
有了占位符的概念之后，使得 std::bind 的使用变得非常灵活:
1#include &lt;iostream&gt; 2#include &lt;functional&gt; 3using namespace std; 4 5void output(int x, int y) 6{ 7 cout &lt;&lt; x &lt;&lt; &#34; &#34; &lt;&lt; y &lt;&lt; endl; 8} 9 10int main(void) 11{ 12 // 使用绑定器绑定可调用对象和参数, 并调用得到的仿函数 13 bind(output, 1, 2)(); 14 bind(output, placeholders::_1, 2)(10); 15 bind(output, 2, placeholders::_1)(10); 16 17 // error, 调用时没有第二个参数 18 // bind(output, 2, placeholders::_2)(10); 19 // 调用时第一个参数10被吞掉了，没有被使用 20 bind(output, 2, placeholders::_2)(10, 20); 21 22 bind(output, placeholders::_1, placeholders::_2)(10, 20); 23 bind(output, placeholders::_2, placeholders::_1)(10, 20); 24 25 26 return 0; 27} 通过测试可以看到，std::bind可以直接绑定函数的所有参数，也可以仅绑定部分参数。在绑定部分参数的时候，通过使用 std::placeholders来决定空位参数将会属于调用发生时的第几个参数。
可调用对象包装器std::function是不能实现对类成员函数指针或者类成员指针的包装的，但是通过绑定器std::bind的配合之后，就可以完美的解决这个问题了，再来看一个例子，然后再解释里边的细节：
1#include &lt;iostream&gt; 2#include &lt;functional&gt; 3using namespace std; 4 5class Test 6{ 7public: 8 void output(int x, int y) 9 { 10 cout &lt;&lt; &#34;x: &#34; &lt;&lt; x &lt;&lt; &#34;, y: &#34; &lt;&lt; y &lt;&lt; endl; 11 } 12 int m_number = 100; 13}; 14 15int main(void) 16{ 17 Test t; 18 // 绑定类成员函数 19 function&lt;void(int, int)&gt; f1 = 20 bind(&amp;Test::output, &amp;t, placeholders::_1, placeholders::_2); 21 // 绑定类成员变量(公共) 22 function&lt;int&amp;(void)&gt; f2 = bind(&amp;Test::m_number, &amp;t); 23 24 // 调用 25 f1(520, 1314); 26 f2() = 2333; 27 cout &lt;&lt; &#34;t.m_number: &#34; &lt;&lt; t.m_number &lt;&lt; endl; 28 29 return 0; 30} 在用绑定器绑定类成员函数或者成员变量的时候需要将它们所属的实例对象一并传递到绑定器函数内部。f1的类型是function&lt;void(int, int)&gt;，通过使用std::bind将Test的成员函数output的地址和对象t绑定，并转化为一个仿函数并存储到对象f1中。
使用绑定器绑定的类成员变量m_number得到的仿函数被存储到了类型为function&lt;int&amp;(void)&gt;的包装器对象f2中，并且可以在需要的时候修改这个成员。其中int是绑定的类成员的类型，并且允许修改绑定的变量，因此需要指定为变量的引用，由于没有参数因此参数列表指定为void。
示例程序中是使用 function 包装器保存了 bind 返回的仿函数，如果不知道包装器的模板类型如何指定，可以直接使用 auto 进行类型的自动推导，这样使用起来会更容易一些。
]]></content>
  </entry>
  
  <entry>
    <title>auto关键字</title>
    <url>/yfmff/yfmff.github.io.git/post/cpp/autotype/</url>
    <categories><category>cpp</category>
    </categories>
    <tags>
    </tags>
    <content type="html"><![CDATA[使用规则 auto的使用规则非常简单，但是使用auto时必须初始化，让编译器推导它的实际类型，编译器在编译时将auto占位符替换为真正的类型。语法规则如下：
1auto 变量名=变量的值; 2 3// 举例 4auto i=20; // i为整形 5auto j=1.0; // j为double类型 6int a=20; 7auto *b=&amp;a; // b为int* 类型 不仅如此，auto还可以和指针、引用结合起来使用也可以带上 const、volatile 限定符，在不同的场景下有对应的推导规则，规则内容如下：
当变量不是指针或者引用类型时，推导的结果中不会保留 const、volatile 关键字 当变量是指针或者引用类型时，推导的结果中会保留 const、volatile 关键字 先来看一组变量带指针和引用并使用 auto 进行类型推导的例子：
1int temp = 110; 2auto *a = &amp;temp;	// 变量a的数据类型为int*，因此auto关键字被推导为int类型 3auto b = &amp;temp;	// 变量b的数据类型为int*，因此auto关键字被推导为int* 类型 4auto &amp;c = temp;	// 变量c的数据类型为int&amp;，因此auto关键字被推导为int类型 5auto d = temp;	// 变量d的数据类型为int，因此auto关键字被推导为int 类型 6 7在来看一组带 const 限定的变量，使用 auto 进行类型推导的例子: 8C++ 9int tmp = 250; 10const auto a1 = tmp; // 变量a1的数据类型为const int，因此auto关键字被推导为int类型 11auto a2 = a1; // 变量a2的数据类型为int，但是a2没有声明为指针或引用因此const属性被去掉，auto被推导为int 12const auto &amp;a3 = tmp; //变量a3的数据类型为const int&amp;，a3被声明为引用因此const属性被保留，auto关键字被推导为int 13auto &amp;a4 = a3; //变量 a4 的数据类型为 const int&amp;，a4 被声明为引用因此 const 属性被保留，auto关键字被推导为const int 类型 auto的限制 auto不是万能的，以下几种条件不可用auto。
不能作为函数参数使用。 不能用于类的非静态成员变量的初始化。 不能使用auto关键字定义数组。 无法使用auto推导出模板参数 ]]></content>
  </entry>
  
  <entry>
    <title>委托构造与继承构造</title>
    <url>/yfmff/yfmff.github.io.git/post/cpp/construct/</url>
    <categories><category>cpp</category>
    </categories>
    <tags>
    </tags>
    <content type="html"><![CDATA[构造函数 在了解委托和继承构造函数前，先复习下类对象的构造。 在C++中声明自己的类，哪怕是个空类，编译器也会帮我们生成一系列函数，包括：
无参构造函数：创建类对象 拷贝构造函数：拷贝类对象 移动构造函数：拷贝类对象 拷贝赋值函数：类对象赋值 移动赋值函数：类对象赋值 析构函数：销毁类对象 当然，一旦我们重新定义了这些函数，编译器就不会生成默认版本。
= default和= delete C++11标准中称 = default 修饰的函数为显式默认【缺省】（explicit defaulted）函数，而称 =delete 修饰的函数为删除（deleted）函数或者显示删除函数。= default只能用于上述6个函数。
委托构造 委托构造函数允许使用同一个类中的一个构造函数调用其它的构造函数，从而简化相关变量的初始化。直接上代码了：
1#include &lt;iostream&gt; 2using namespace std; 3 4class Test 5{ 6public: 7 Test() {}; 8 Test(int max) // 1号 9 { 10 this-&gt;m_max = max &gt; 0 ? max : 100; 11 } 12 13 Test(int max, int min):Test(max) //2号 14 { 15 this-&gt;m_min = min &gt; 0 &amp;&amp; min &lt; max ? min : 1; 16 } 17 18 Test(int max, int min, int mid):Test(max, min) //3号 19 { 20 this-&gt;m_middle = mid &lt; max &amp;&amp; mid &gt; min ? mid : 50; 21 } 22 23 int m_min; 24 int m_max; 25 int m_middle; 26}; 27 28int main() 29{ 30 Test t(90, 30, 60); 31 cout &lt;&lt; &#34;min: &#34; &lt;&lt; t.m_min &lt;&lt; &#34;, middle: &#34; 32 &lt;&lt; t.m_middle &lt;&lt; &#34;, max: &#34; &lt;&lt; t.m_max &lt;&lt; endl; 33 return 0; 34} 从代码可见，1号函数初始化了m_max，2号函数调用了1号函数来初始化了m_max，自己手动初始化了m_min，而3号函数则调用了2号函数来初始化了m_min和m_max，它自己只初始化了m_middle，减少了重复代码，类似于一个链条。需要注意的是：
这种链式的构造函数调用不能形成一个闭环（死循环），否则会在运行期抛异常。 如果要进行多层构造函数的链式调用，建议将构造函数的调用的写在初始列表中而不是函数体内部，否则编译器会提示形参的重复定义。 1Test(int max) 2{ 3 this-&gt;m_max = max &gt; 0 ? max : 100; 4} 5 6Test(int max, int min) 7{ 8 Test(max);	// error, 此处编译器会报错, 提示形参max被重复定义 9 this-&gt;m_min = min &gt; 0 &amp;&amp; min &lt; max ? min : 1; 10} 在初始化列表中调用了代理构造函数初始化某个类成员变量之后，就不能在初始化列表中再次初始化这个变量了。 1// 错误, 使用了委托构造函数就不能再次m_max初始化了 2Test(int max, int min) : Test(max), m_max(max) 3{ 4 this-&gt;m_min = min &gt; 0 &amp;&amp; min &lt; max ? min : 1; 5} 继承构造函数 C++11 中提供的继承构造函数可以让派生类直接使用基类的构造函数，而无需自己再写构造函数，尤其是在基类有很多构造函数的情况下，可以极大地简化派生类构造函数的编写。先来看没有继承构造函数之前的处理方式：
1#include &lt;iostream&gt; 2#include &lt;string&gt; 3using namespace std; 4 5class Base 6{ 7public: 8 Base(int i) :m_i(i) {} 9 Base(int i, double j) :m_i(i), m_j(j) {} 10 Base(int i, double j, string k) :m_i(i), m_j(j), m_k(k) {} 11 12 int m_i; 13 double m_j; 14 string m_k; 15}; 16 17class Child : public Base 18{ 19public: 20 Child(int i) :Base(i) {} 21 Child(int i, double j) :Base(i, j) {} 22 Child(int i, double j, string k) :Base(i, j, k) {} 23}; 24 25int main() 26{ 27 Child c(520, 13.14, &#34;i love you&#34;); 28 cout &lt;&lt; &#34;int: &#34; &lt;&lt; c.m_i &lt;&lt; &#34;, double: &#34; 29 &lt;&lt; c.m_j &lt;&lt; &#34;, string: &#34; &lt;&lt; c.m_k &lt;&lt; endl; 30 return 0; 31} 没有使用继承构造函数的时候，子类中初始化从基类继承的类成员，需要在子类中重新定义和基类一致的构造函数，非常繁琐。使用继承构造函数后：
1#include &lt;iostream&gt; 2#include &lt;string&gt; 3using namespace std; 4 5class Base 6{ 7public: 8 Base(int i) :m_i(i) {} 9 Base(int i, double j) :m_i(i), m_j(j) {} 10 Base(int i, double j, string k) :m_i(i), m_j(j), m_k(k) {} 11 12 int m_i; 13 double m_j; 14 string m_k; 15}; 16 17class Child : public Base 18{ 19public: 20 using Base::Base; 21}; 22 23int main() 24{ 25 Child c1(520, 13.14); 26 cout &lt;&lt; &#34;int: &#34; &lt;&lt; c1.m_i &lt;&lt; &#34;, double: &#34; &lt;&lt; c1.m_j &lt;&lt; endl; 27 Child c2(520, 13.14, &#34;i love you&#34;); 28 cout &lt;&lt; &#34;int: &#34; &lt;&lt; c2.m_i &lt;&lt; &#34;, double: &#34; 29 &lt;&lt; c2.m_j &lt;&lt; &#34;, string: &#34; &lt;&lt; c2.m_k &lt;&lt; endl; 30 return 0; 31} 没有添加任何构造函数，而是添加了using Base::Base; 这样就可以在子类中直接继承父类的所有的构造函数，通过他们去构造子类对象了。 另外如果在子类中隐藏了父类中的同名函数，也可以通过using的方式在子类中使用基类中的这些父类函数：
1#include &lt;iostream&gt; 2#include &lt;string&gt; 3using namespace std; 4 5class Base 6{ 7public: 8 Base(int i) :m_i(i) {} 9 Base(int i, double j) :m_i(i), m_j(j) {} 10 Base(int i, double j, string k) :m_i(i), m_j(j), m_k(k) {} 11 12 void func(int i) 13 { 14 cout &lt;&lt; &#34;base class: i = &#34; &lt;&lt; i &lt;&lt; endl; 15 } 16 17 void func(int i, string str) 18 { 19 cout &lt;&lt; &#34;base class: i = &#34; &lt;&lt; i &lt;&lt; &#34;, str = &#34; &lt;&lt; str &lt;&lt; endl; 20 } 21 22 int m_i; 23 double m_j; 24 string m_k; 25}; 26 27class Child : public Base 28{ 29public: 30 using Base::Base; 31 using Base::func; 32 void func() 33 { 34 cout &lt;&lt; &#34;child class: i&#39;am luffy!!!&#34; &lt;&lt; endl; 35 } 36}; 37 38int main() 39{ 40 Child c(250); 41 c.func(); 42 c.func(19); 43 c.func(19, &#34;luffy&#34;); 44 return 0; 45} 子类中的func() 函数隐藏 了基类中的两个func() 因此默认情况下通过子类对象只能调用无参的func()，在上面的子类代码中添加了using Base::func; 之后，就可以通过子类对象直接调用父类中被隐藏的带参func()函数了。
]]></content>
  </entry>
  
  <entry>
    <title>QtTcp</title>
    <url>/yfmff/yfmff.github.io.git/post/qt/qttcp/</url>
    <categories><category>qt</category>
    </categories>
    <tags>
    </tags>
    <content type="html"><![CDATA[Qt提供了两个类用于TCP通信：
QTcpServer：服务器类，用于监听客户端连接以及和客户端建立连接。 QTcpSocket：通信的套接字类，客户端、服务器端都需要使用。 QTcpServer 常用API：
1QTcpServer::QTcpServer(QObject *parent = Q_NULLPTR); 2bool QTcpServer::listen(const QHostAddress &amp;address = QHostAddress::Any, quint16 port = 0); 3// 判断当前对象是否在监听, 是返回true，没有监听返回false 4bool QTcpServer::isListening() const; 5// 如果当前对象正在监听返回监听的服务器地址信息, 否则返回 QHostAddress::Null 6QHostAddress QTcpServer::serverAddress() const; 7// 如果服务器正在侦听连接，则返回服务器的端口; 否则返回0 8quint16 QTcpServer::serverPort() const address：通过类QHostAddress可以封装IPv4、IPv6 格式的IP地址，QHostAddress::Any表示自动绑定。 port：如果指定为 0 表示随机绑定一个可用端口。
每次有新连接可用时都会发出newConnection() 信号。
1[signal] void QTcpServer::newConnection(); 和客户端建立连接之后,得到用于通信的QTcpSocket套接字对象，它是QTcpServer的一个子对象，当QTcpServer对象析构的时候会自动析构这个子对象，当然也可自己手动析构，建议用完之后自己手动析构这个通信的QTcpSocket 对象。
1QTcpSocket *QTcpServer::nextPendingConnection(); QTcpSocket QTcpSocket 是一个套接字通信类，不管是客户端还是服务器端都需要使用，常用API如下：
1QTcpSocket::QTcpSocket(QObject *parent = Q_NULLPTR); 2 3// 连接服务器，需要服务器的IP和端口号 4[virtual] void QAbstractSocket::connectToHost(const QString &amp;hostName, quint16 port, OpenMode openMode = ReadWrite, NetworkLayerProtocol protocol = AnyIPProtocol); 5 6[virtual] void QAbstractSocket::connectToHost(const QHostAddress &amp;address, quint16 port, OpenMode openMode = ReadWrite); 读取和发送数据：
1// 读取： 2// 指定可接收的最大字节数 maxSize 的数据到指针 data 指向的内存中 3qint64 QIODevice::read(char *data, qint64 maxSize); 4// 指定可接收的最大字节数 maxSize，返回接收的字符串 5QByteArray QIODevice::read(qint64 maxSize); 6// 将当前可用操作数据全部读出，通过返回值返回读出的字符串 7QByteArray QIODevice::readAll(); 8 9// 发送： 10// 发送指针 data 指向的内存中的 maxSize 个字节的数据 11qint64 QIODevice::write(const char *data, qint64 maxSize); 12// 发送指针 data 指向的内存中的数据，字符串以 \0 作为结束标记 13qint64 QIODevice::write(const char *data); 14// 发送参数指定的字符串 15qint64 QIODevice::write(const QByteArray &amp;byteArray); 在 Qt 中不管调用读操作函数接收数据，还是调用写函数发送数据，操作的对象都是本地的由 Qt 框架维护的一块内存。因此，调用了发送函数数据不一定会马上被发送到网络中，调用了接收函数也不是直接从网络中接收数据，关于底层的相关操作是不需要使用者来维护的。调用connectToHost() 函数并成功建立连接之后发出connected() 信号。在套接字断开连接时发出 disconnected() 信号。
1[signal] void QAbstractSocket::connected(); 2[signal] void QAbstractSocket::disconnected(); 在使用 QTcpSocket 进行套接字通信的过程中，如果该类对象发射出readyRead() 信号，说明对端发送的数据达到了，之后就可以调用read 函数接收数据了。
1[signal] void QIODevice::readyRead(); 通信流程 服务端 创建套接字服务器QTcpServer对象 通过QTcpServer对象设置监听，即：QTcpServer::listen() 基于QTcpServer::newConnection() 信号检测是否有新的客户端连接 如果有新的客户端连接，调用 QTcpSocket* QTcpServer::nextPendingConnection() 得到通信的套接字对象 使用通信的套接字对象QTcpSocket和客户端进行通信 假设有个程序，界面有两个按钮，一个是用于开启服务器，一个是给客户端发送消息：
1class MainWindow : public QMainWindow 2{ 3 Q_OBJECT 4 5public: 6 explicit MainWindow(QWidget *parent = 0); 7 ~MainWindow(); 8 9private slots: 10 void on_startServer_clicked(); 11 12 void on_sendMsg_clicked(); 13 14private: 15 Ui::MainWindow *ui; 16 QTcpServer* m_server; 17 QTcpSocket* m_tcp; 18}; 19 20MainWindow::MainWindow(QWidget *parent) : 21 QMainWindow(parent), 22 ui(new Ui::MainWindow) 23{ 24 ui-&gt;setupUi(this); 25 setWindowTitle(&#34;TCP - 服务器&#34;); 26 // 创建 QTcpServer 对象 27 m_server = new QTcpServer(this); 28 // 检测是否有新的客户端连接 29 connect(m_server, &amp;QTcpServer::newConnection, this, [=]() 30 { 31 m_tcp = m_server-&gt;nextPendingConnection(); 32 ui-&gt;record-&gt;append(&#34;成功和客户端建立了新的连接...&#34;); 33 m_status-&gt;setPixmap(QPixmap(&#34;:/connect.png&#34;).scaled(20, 20)); 34 // 检测是否有客户端数据 35 connect(m_tcp, &amp;QTcpSocket::readyRead, this, [=]() 36 { 37 // 接收数据 38 QString recvMsg = m_tcp-&gt;readAll(); 39 ui-&gt;record-&gt;append(&#34;客户端Say: &#34; + recvMsg); 40 }); 41 // 客户端断开了连接 42 connect(m_tcp, &amp;QTcpSocket::disconnected, this, [=]() 43 { 44 ui-&gt;record-&gt;append(&#34;客户端已经断开了连接...&#34;); 45 m_tcp-&gt;deleteLater(); 46 m_status-&gt;setPixmap(QPixmap(&#34;:/disconnect.png&#34;).scaled(20, 20)); 47 }); 48 }); 49} 50 51MainWindow::~MainWindow() 52{ 53 delete ui; 54} 55 56// 启动服务器端的服务按钮 57void MainWindow::on_startServer_clicked() 58{ 59 // 设置服务器监听8888端口 60 m_server-&gt;listen(QHostAddress::Any, 8888); 61 ui-&gt;startServer-&gt;setEnabled(false); 62} 63 64// 点击发送数据按钮 65void MainWindow::on_sendMsg_clicked() 66{ 67 QString sendMsg = ui-&gt;msg-&gt;toPlainText(); 68 m_tcp-&gt;write(sendMsg.toUtf8()); 69 ui-&gt;record-&gt;append(&#34;服务器Say: &#34; + sendMsg); 70 ui-&gt;msg-&gt;clear(); 71} 客户端 创建通信的套接字类QTcpSocket对象 使用服务器端绑定的IP和端口连接服务器QAbstractSocket::connectToHost() 使用QTcpSocket对象和服务器进行通信 客户端上有三个按钮，连接服务器，断开连接和发送消息。
1class MainWindow : public QMainWindow 2{ 3 Q_OBJECT 4 5public: 6 explicit MainWindow(QWidget *parent = 0); 7 ~MainWindow(); 8 9private slots: 10 void on_connectServer_clicked(); 11 12 void on_sendMsg_clicked(); 13 14 void on_disconnect_clicked(); 15 16private: 17 Ui::MainWindow *ui; 18 QTcpSocket* m_tcp; 19}; 20 21MainWindow::MainWindow(QWidget *parent) : 22 QMainWindow(parent), 23 ui(new Ui::MainWindow) 24{ 25 ui-&gt;setupUi(this); 26 setWindowTitle(&#34;TCP - 客户端&#34;); 27 28 // 创建通信的套接字对象 29 m_tcp = new QTcpSocket(this); 30 // 检测服务器是否回复了数据 31 connect(m_tcp, &amp;QTcpSocket::readyRead, [=]() 32 { 33 // 接收服务器发送的数据 34 QByteArray recvMsg = m_tcp-&gt;readAll(); 35 ui-&gt;record-&gt;append(&#34;服务器Say: &#34; + recvMsg); 36 }); 37 38 // 检测是否和服务器是否连接成功了 39 connect(m_tcp, &amp;QTcpSocket::connected, this, [=]() 40 { 41 ui-&gt;record-&gt;append(&#34;恭喜, 连接服务器成功!!!&#34;); 42 m_status-&gt;setPixmap(QPixmap(&#34;:/connect.png&#34;).scaled(20, 20)); 43 }); 44 45 // 检测服务器是否和客户端断开了连接 46 connect(m_tcp, &amp;QTcpSocket::disconnected, this, [=]() 47 { 48 ui-&gt;record-&gt;append(&#34;服务器已经断开了连接, ...&#34;); 49 ui-&gt;connectServer-&gt;setEnabled(true); 50 ui-&gt;disconnect-&gt;setEnabled(false); 51 }); 52} 53 54MainWindow::~MainWindow() 55{ 56 delete ui; 57} 58 59// 连接服务器按钮按下之后的处理动作 60void MainWindow::on_connectServer_clicked() 61{ 62 QString ip = ui-&gt;ip-&gt;text(); 63 unsigned short port = ui-&gt;port-&gt;text().toInt(); 64 // 连接服务器 65 m_tcp-&gt;connectToHost(QHostAddress(ip), port); 66 ui-&gt;connectServer-&gt;setEnabled(false); 67 ui-&gt;disconnect-&gt;setEnabled(true); 68} 69 70// 发送数据按钮按下之后的处理动作 71void MainWindow::on_sendMsg_clicked() 72{ 73 QString sendMsg = ui-&gt;msg-&gt;toPlainText(); 74 m_tcp-&gt;write(sendMsg.toUtf8()); 75 ui-&gt;record-&gt;append(&#34;客户端Say: &#34; + sendMsg); 76 ui-&gt;msg-&gt;clear(); 77} 78 79// 断开连接按钮被按下之后的处理动作 80void MainWindow::on_disconnect_clicked() 81{ 82 m_tcp-&gt;close(); 83 ui-&gt;connectServer-&gt;setEnabled(true); 84 ui-&gt;disconnect-&gt;setEnabled(false); 85} ]]></content>
  </entry>
  
  <entry>
    <title>Qt线程同步与异步（并发）</title>
    <url>/yfmff/yfmff.github.io.git/post/qt/qtthreadsyn/</url>
    <categories><category>qt</category>
    </categories>
    <tags>
      <tag>qt-thread</tag>
    </tags>
    <content type="html"><![CDATA[什么是线程同步 在我们的程序中有一个公共数据（可能是数据中心类的实例对象或者一个数字等，这里假定是int pub_num=0），假设，同时有A、B、C、D4个线程访问这个pub_num，A是将这个数+1，b是将这个数-1，C是将这个数+5，D是将这个数-20，那么20秒后，pub_num值是多少？恐怕没人能知道，因为，线程的运行取决于它有没有得到CPU时间片，我们无法知道ABCD分别运行了几次（或者有没有运行）。因此，我们需要一个机制，来保证，当一个线程访问pub_num时，其他线程无法访问，让线程依次对pub_num进行修改，这样我们才好预测pub_num的值。这种机制就是线程同步。其中pub_num也被称为临界资源。
QT线程同步的方式 QMutex QMutex类似与C++中的mutex类，给临界资源加锁。用完临界资源后需要解锁。
1// QMutex有两种模式：Recursive, NonRecursive 2// Recursive:一个线程可以对mutex多次lock，直到相应次数的unlock调用后，mutex才真正被解锁。 3 QMutex(RecursionMode mode = NonRecursive); 1QMutex mutex; //锁 2void func() 3{ 4 mutex.lock(); 5 // 假设这里有临界资源 6 mutex.unlock(); 7} 8 9class thread1:public QThread 10{ 11 protected: 12 virtual void run() override 13 { 14 func(); 15 } 16} 17 18class thread2:public QThread 19{ 20 protected: 21 virtual void run() override 22 { 23 func(); 24 } 25} 假设程序中同时运行了thread1和thread2，那么它们都会执行func()，此时采用互斥锁就可线程同步。
QMutexLocker 每次使用QMutex都要成对的使用lock和unlock，稍不注意就会造成死锁，此时可采用QMutexLocker，类似于C++中的哨兵锁：lock_guard 。QMutexLocker需要QMutex来实例化。
1// 创建线程的代码省略了 2QMutex mutex; //锁 3void func() 4{ 5 QMutexLocker guardlocker(&amp;mutex); 6 // 假设这里有临界资源 7} 在创建guardlocker时会从该位置起自动加锁并记录加锁的线程，当guardlocker析构时，会自动解锁。
QReadWriteLock 当我们只是想读取临界区数据的值时，此时其实不用加锁也可以，毕竟我们又不修改数据，但是采用上述方法做不到，因此，QT提供功能更强的QReadWriteLock读写锁。
1QReadWriteLock ( RecursionMode recursionMode ) //和QMutex类似，此处不再重复 1QReadWriteLock locker; // 读写锁 2// 创建线程的代码省略了 3void func() 4{ 5 locker.lockForWrite(); 6 // locker.lockForRead(); 7 // 假设这里是临界代码段 8 locker.unlock(); 9} 读写锁所对应的哨兵锁 和QMutex类似，为了简化操作，QT定义了QReadLocker、QWriteLocker，其构造函数都需要一个QReadWriteLock对象来初始化。
1QReadWriteLock lock; 2// 省略线程创建的代码 3 4void func() 5{ 6 QReadLocker rdlocker(&amp;lock); 7 QWriteLocker wrlocker(&amp;lock); 8 // 假设这是临界代码段 9} 信号量QSemaphore 在进行PV操作时，生产者需要的是空闲位置存放产品，结果是可取的产品多了一个，消费者则相反。定义两个信号量：QSemaphore freeSpace和QSemaphore usedSpace，前者是给生产者使用的，后者是给消费者使用的。 QSemaphore常用的api：
1QSemaphore(int n); // 建立的信号量总共多少资源 2void acquire(int n); // 每调用一次，减少n个资源，如果资源总数不够，则阻塞 3int available(); // 返回当前可用资源数 4void release(int n); // 每调用一次，增加n个资源 5bool tryacquire(int n); // 类似acquire，但是资源总数不够也不回阻塞 下面举个例子：
1//定义两个信号量，一个是生产者（把车开进去）的，一个是消费者（把车开出来）的 2int total=10; // 总共多少资源，比如总共10个车位 3QSemaphore producese(total); //一开始停车场是空的，生产者自然可以把车开进去，此时它的信号量的初始值应该为total 4QSemaphore customse(0); //一开始停车场是空的，消费者没法开啊，所以信号量为0 5 6class producer:public QThread 7{ 8 protected: 9 void run() 10 { 11 // 开进一辆车就占了一个位置，可用的车位-1 12 producese.acquire(1); 13 // 能开的车数量+1 14 customse.release(1); 15 } 16} 17 18class customer:public QThread 19{ 20 protected: 21 void run() 22 { 23 // 开出一辆车，车位中剩余的车数量-1 24 customse.acquire(1); 25 26 // 空位数量+1 27 producese.release(1); 28 } 29} 条件变量 PV操作还有另外一种方法：条件变量。Qt提供了QWaitCondition类，类似于C++中的condition_variable或condition_variable_any。 QWaitCondition用于多线程的同步，一个线程调用QWaitCondition::wait() 阻塞等待，直到另一个线程调用QWaitCondition::wake() 唤醒才继续往下执行。QWaitCondition 需要QMutex 搭配使用。
1// 给一个vector添加值，最多允许10个数字 2vector&lt;int&gt; m_vec; 3QMutex tmpmu; 4QWaitCondition notempty; // 不为空的条件变量 5QWaitCondition notfull; // 不为满的条件变量 6 7void producer::run() // 添加 8{ 9 tmpmu.lock(); 10 if(m_vec.size()&gt;9u) // 10个的时候不准添加了 11 { 12 // 容器满了，没法添加，阻塞，等待消费者消费后唤醒 13 notfull.wait(&amp;tmpmu); 14 } 15 m_vec.push_back(1); 16 // 通知消费者消费 17 notempty.wake(&amp;tmpmu); 18} 19 20void customer::run() // 删除 21{ 22 tmpmu.lock(); 23 if(m_vec.empty()) 24 { 25 // 容器为空，没法删除，等待生产者生产后唤醒 26 notempty.wait(&amp;tmpmu); 27 } 28 29 m_vec.pop(); 30 notfull.wake(&amp;tmpmu); 31} QtConcurrent 并发异步，QtConcurrent::run能够方便快捷的将任务丢到子线程中去执行，无需继承任何类，也不需要重写函数，使用非常简单。 QtConcurrent常用接口：
1QFuture&lt;T&gt; QtConcurrent::run(Function function, ...) 2QFuture&lt;T&gt; QtConcurrent::run(QThreadPool *pool, Function function, ...) 3 4QtConcurrent::map() //自动申请最佳线程调用传入的map函数并行对容器中的每个元素做就地运算，返回一个QFuture&lt;void&gt;只用于状态管理 5QtConcurrent::mapped() //类似于map()，只是不做就地修改，调用时创建拷贝，并且会返回一个QFuture&lt;ResultType&gt;用于处理每一个mapped后的结果 6QtConcurrent::mappedReduced() //类似于mapped()，只是会使用reduce函数将结果整合成一个值，并返回该值序列上的并行过滤（移除） 7QtConcurrent::filter() //根据传入的filter函数的结果从容器中移除元素，返回一个QFuture&lt;void&gt;只用于状态管理 8QtConcurrent::filtered() //类似于filter()，只是不做就地修改，将需要保留的元素拷贝到新容器，返回一个QFuture&lt;ResultType&gt;序列用于处理每一个filtered后的结果 9QtConcurrent::filteredReduced() //类似于filtered()，只是会使用reduce函数将结果整合成一个值，并返回该值 可以将比较耗时的操作放入run()，结果会返回QFuture类对象，表示异步计算的结果。QFutureWatcher则允许使用信号和槽监视QFuture，比如：
1QFutureWatcher&lt;void&gt; watcher=new QFutureWatcher&lt;void&gt;; 2QFuture&lt;void&gt; future=QtConcurrent::run([](){功能代码}); 3connect(watcher,&amp;QFutureWatcher::finished,[](){完成后干什么}); ]]></content>
  </entry>
  
  <entry>
    <title>QtUdp</title>
    <url>/yfmff/yfmff.github.io.git/post/qt/qtudp/</url>
    <categories><category>qt</category>
    </categories>
    <tags>
    </tags>
    <content type="html"><![CDATA[Qt中关于UDP操作简单示例：
1#include &#34;widget.h&#34; 2#include &#34;ui_widget.h&#34; 3#include&lt;QNetworkDatagram&gt; 4 5Widget::Widget(QWidget *parent) 6 : QWidget(parent) 7 , ui(new Ui::Widget) 8{ 9 ui-&gt;setupUi(this); 10 setWindowTitle(&#34;端口号8000&#34;); 11 ui-&gt;btnSend-&gt;setEnabled(false); 12 13 m_socket=new QUdpSocket(this); 14 m_socket-&gt;bind(QHostAddress::Any,8000); 15 16 // // 如果需要组播 17 // m_socket-&gt;bind(QHostAddress::AnyIPv4,8000); 18 // m_socket-&gt;joinMulticastGroup(QHostAddress(&#34;127.0.0.1&#34;)); 19 // // 离开组播 20 // m_socket-&gt;leaveMulticastGroup(QHostAddress(&#34;127.0.0.1&#34;)); 21 22 // 有数据发过来，自动触发readyread 23 connect(m_socket,&amp;QUdpSocket::readyRead,[&amp;]() 24 { 25 // 读数据 26 char buf[1024]={0}; 27 QHostAddress tmp_addr; // 对方地址 28 quint16 port; // 对方端口 29 m_socket-&gt;readDatagram(buf,sizeof(buf),&amp;tmp_addr,&amp;port); 30 31 QString txt=QString(&#34;[%1:%2]：&#34;).arg(tmp_addr.toString()).arg(port); 32 ui-&gt;editShow-&gt;append(txt); 33 ui-&gt;editShow-&gt;append(buf); 34 }); 35} 36 37// 界面上有个发送消息的按钮，会发送editSend里的内容 38void Widget::on_btnSend_clicked() 39{ 40 if(!m_socket) return; 41 QString ip=ui-&gt;editip-&gt;text(); 42 QString port=ui-&gt;editport-&gt;text(); 43 QString send_txt=ui-&gt;editSend-&gt;toPlainText(); 44 45 m_socket-&gt;writeDatagram(send_txt.toUtf8(),QHostAddress(ip),port.toUInt()); 46 ui-&gt;editShow-&gt;append(send_txt); 47 ui-&gt;editSend-&gt;clear(); 48} ]]></content>
  </entry>
  
  <entry>
    <title>Qt事件</title>
    <url>/yfmff/yfmff.github.io.git/post/qt/qtevent/</url>
    <categories><category>qt</category>
    </categories>
    <tags>
    </tags>
    <content type="html"><![CDATA[事件的分发过程 Qt主要用来编写GUI程序，而GUI程序大都基于事件，通过回调来实现功能。当点击鼠标、键盘时或者计时器到时间了就会产生相应的事件，通过对这些事件作出回应，就可实现我们自定义的功能。每个Qt的GUI程序在main函数中都会有个QApplication应用程序对象，在main函数结束前，这个对象会调用exec()来检测该应用程序的事件。事件产生后，事件会经过：事件派发-&gt;事件过滤-&gt;事件分发-&gt;事件处理几个阶段:
事件产生后，QApplication应用程序对象会调用notify()，把事件发送到指定的窗口： 1[override virtual] bool QApplication::notify(QObject *receiver, QEvent *e); 事件在发送过程中可以通过事件过滤器进行过滤，默认不对任何产生的事件进行过滤。 1// 需要先给窗口安装过滤器, 该事件才会触发 2[virtual] bool QObject::eventFilter(QObject *watched, QEvent *event) 当事件发送到指定窗口之后，窗口的事件分发器会对收到的事件进行分类: 1[override virtual protected] bool QWidget::event(QEvent *event); 事件分发器会将分类之后的事件（鼠标事件、键盘事件、绘图事件。。。）分发给对应的事件处理器函数进行处理，每个事件处理器函数都有默认的处理动作（我们也可以重写这些事件处理器函数），比如：鼠标事件： 1// 鼠标按下 2[virtual protected] void QWidget::mousePressEvent(QMouseEvent *event); 3// 鼠标释放 4[virtual protected] void QWidget::mouseReleaseEvent(QMouseEvent *event); 5// 鼠标移动 6[virtual protected] void QWidget::mouseMoveEvent(QMouseEvent *event); 事件处理函数 从后往前汉，先看事件处理。如果我们想改变这些事件的响应（比如鼠标左键点击），只需要定义一个派生自QWidget的类，重写它的响应函数即可。比如，在点击关闭时，弹窗提示是否关闭的功能实现：
1#include &lt;QMainWindow&gt; 2 3QT_BEGIN_NAMESPACE 4namespace Ui { class MainWindow; } 5QT_END_NAMESPACE 6 7class MainWindow : public QMainWindow 8{ 9 Q_OBJECT 10 11public: 12 MainWindow(QWidget *parent = nullptr); 13 ~MainWindow(); 14 15protected: 16 // 重写事件处理器函数 17 void closeEvent(QCloseEvent* ev); 18 void resizeEvent(QResizeEvent* ev); 19 20private: 21 Ui::MainWindow *ui; 22}; 23 24MainWindow::MainWindow(QWidget *parent) 25 : QMainWindow(parent) 26 , ui(new Ui::MainWindow) 27{ 28 ui-&gt;setupUi(this); 29} 30 31MainWindow::~MainWindow() 32{ 33 delete ui; 34} 35 36void MainWindow::closeEvent(QCloseEvent *ev) 37{ 38 QMessageBox::Button btn = QMessageBox::question(this, &#34;关闭窗口&#34;, &#34;您确定要关闭窗口吗?&#34;); 39 if(btn == QMessageBox::Yes) 40 { 41 // 接收并处理这个事件 42 ev-&gt;accept(); 43 } 44 else 45 { 46 // 忽略这个事件 47 ev-&gt;ignore(); 48 } 49} 50 51void MainWindow::resizeEvent(QResizeEvent *ev) 52{ 53 qDebug() &lt;&lt; &#34;oldSize: &#34; &lt;&lt; ev-&gt;oldSize() 54 &lt;&lt; &#34;currentSize: &#34; &lt;&lt; ev-&gt;size(); 55} 事件分发器 当事件产生被发送到对应的窗口之后，窗口并不会直接处理这个事件，而是对这些事件进行细分，然后根据事件的类型再次进行分发，对应的事件处理器函数得到这个分发的事件之后就开始处理这个事件。 关于窗口事件的分发，对应一个事件分发器，叫做event：
1[override virtual protected] bool QWidget::event(QEvent *event); 其中，QEvent常用API：
1// 该函数的作用是让窗口接受传递过来的事件，事件不会向上层窗口（父窗口）传递。 2void QEvent::accept(); 3 4// 该函数的作用是让窗口忽略传递过来的事件，事件被传递给父窗口（向上传递）。 5void QEvent::ignore(); 6 7// 设置传递过来的事件是被接受还是被忽略 8// setAccepted(true) == accept() 9// setAccepted(false) == ignore() 10bool QEvent::isAccepted() const; 11void QEvent::setAccepted(bool accepted); 12 13// 得到传递的窗口的事件的类型，返回值是一个枚举类型 14QEvent::Type QEvent::type() const; 在不需要人为干预的情况下，事件分发器会自主的完成相关事件的分发，下面来还原一下事件分发器的分发流程，以下是这个函数的部分源码展示：
1bool QWidget::event(QEvent *ev) 2{ 3 switch(ev-&gt;type()) 4 { 5 // 鼠标移动 6 case QEvent::MouseMove:	7 mouseMoveEvent((QMouseEvent*)event); 8 break; 9 // 鼠标按下 10 case QEvent::MouseButtonPress:	11 mousePressEvent((QMouseEvent*)event); 12 break; 13 // 鼠标释放 14 case QEvent::MouseButtonRelease:	15 mouseReleaseEvent((QMouseEvent*)event); 16 break; 17 // 鼠标双击 18 case QEvent::MouseButtonDblClick:	19 mouseDoubleClickEvent((QMouseEvent*)event); 20 break; 21 // 键盘按键被按下事件 22 case QEvent::KeyPress: 23 break; 24 ... 25 ... 26 ... 27 default: 28 break; 29 } 30} 如果我们不想让某些触发的事件进入到当前窗口中，可以在事件分发器中进行拦截，拦截之前先来了解一下事件分发器函数的返回值：
如果传入的事件已被识别并且处理，则需要返回 true，否则返回false。如果返回值是true，那么Qt会认为这个事件已经处理完毕，不会再将这个事件发送给其它对象，而是会继续处理事件队列中的下一事件。 在event() 函数中，调用事件对象的accept() 和ignore() 函数是没有作用的，不会影响到事件的传播。 下面来举个例子，在窗口中过滤掉鼠标按下的事件:
1bool MainWindow::event(QEvent *ev) 2{ 3 if(ev-&gt;type() == QEvent::MouseButtonPress || 4 ev-&gt;type() == QEvent::MouseButtonDblClick) 5 { 6 // 过滤调用鼠标按下的事件 7 return true; 8 } 9 return QWidget::event(ev); 10} 这样窗口就再也收不到鼠标的单击和双击事件了，对于这两个事件以外的其他事件是没有任何影响的，因为在重写的事件分发器函数的最后调用了父类的事件分发器函数,这样就能保证其他事件按照默认的分发流程进行分发，并最终被窗口处理掉。
事件过滤器 除了使用事件分发器来过滤Qt窗口中产生的事件，还可以通过事件过滤器过滤相关的事件。当Qt的事件通过应用程序对象发送给相关窗口之后，窗口接收到数据之前这个期间可对事件进行过滤，过滤掉的事件就不能被继续处理了。QObject有一个eventFilter() 函数，用于建立事件过滤器。函数原型如下：
1[virtual] bool QObject::eventFilter(QObject *watched, QEvent *event); watched：要过滤的事件的所有者对象 event：要过滤的具体的事件 返回值：如果想过滤掉这个事件，停止它被进一步处理，返回true，否则返回false 过滤前需要先安装过滤器：
1// 给要被过滤事件的类对象安装事件过滤器 2void QObject::installEventFilter(QObject *filterObj); 在要进行事件过滤的类中（filterObj 参数对应的类）重写从QObject类继承的虚函数eventFilter()。
举例 在一个窗口中有一个多行文本输入框 QTextEdit，需要让我们屏蔽掉键盘上的回车键，也就是按回车键之后在这个文本编辑框中再也不能换行了。主窗口头文件： mainwindow.h
1QT_BEGIN_NAMESPACE 2namespace Ui { class MainWindow; } 3QT_END_NAMESPACE 4 5class MainWindow : public QMainWindow 6{ 7 Q_OBJECT 8 9public: 10 MainWindow(QWidget *parent = nullptr); 11 ~MainWindow(); 12 13 bool eventFilter(QObject *watched, QEvent *event); 14 15private: 16 Ui::MainWindow *ui; 17}; 主窗口源文件： mainwindow.cpp
1MainWindow::MainWindow(QWidget *parent) 2 : QMainWindow(parent) 3 , ui(new Ui::MainWindow) 4{ 5 ui-&gt;setupUi(this); 6 7 ui-&gt;textEdit-&gt;installEventFilter(this); 8} 9 10MainWindow::~MainWindow() 11{ 12 delete ui; 13} 14 15bool MainWindow::eventFilter(QObject *watched, QEvent *event) 16{ 17 // 判断对象和事件 18 if(watched == ui-&gt;textEdit &amp;&amp; event-&gt;type() == QEvent::KeyPress) 19 { 20 QKeyEvent* keyEv = (QKeyEvent*)event; 21 if(keyEv-&gt;key() == Qt::Key_Enter || // 小键盘确认 22 keyEv-&gt;key() == Qt::Key_Return) // 大键盘回车 23 { 24 qDebug() &lt;&lt; &#34;我是回车, 被按下了...&#34;; 25 return true; 26 } 27 } 28 return false; 29} 事件过滤器和被安装过滤器的组件必须在同一线程，否则，过滤器将不起作用。另外，如果在安装过滤器之后，这两个组件到了不同的线程，那么，只有等到二者重新回到同一线程的时候过滤器才会有效。
]]></content>
  </entry>
  
  <entry>
    <title>Qt信号槽机制</title>
    <url>/yfmff/yfmff.github.io.git/post/qt/qtsignalandslot/</url>
    <categories><category>qt</category>
    </categories>
    <tags>
    </tags>
    <content type="html"><![CDATA[信号和槽概述 信号槽，实际就是观察者模式 (发布 - 订阅模式)。当某个事件发生之后，比如，按钮检测到自己被点击了一下，它就会发出一个信号（signal）。这种发出是没有目的的，类似广播。如果有对象对这个信号感兴趣，它就会使用连接（connect）函数，意思是，将想要处理的信号和自己的一个函数（称为槽（slot））绑定来处理这个信号。也就是说，当信号发出时，被连接的槽函数会自动被回调。这就类似观察者模式：当发生了感兴趣的事件，某一个操作就会被自动触发。
单线程场景：相当于函数指针的调用 多线程场景：信号触发时，发送者线程将槽函数的调用转化为一次“调用事件”放入事件循环队列，接受者线程执行到下次事件处理时，处理“调用事件”，调用相应的函数。
信号的本质 信号是由于用户对窗口或控件进行了某些操作，导致窗口或控件产生了某个特定事件，这时候Qt对应的窗口类会发出某个信号，以此对用户的挑选做出反应。信号的本质就是事件，比如：
鼠标移动、单击、释放 键盘输入 窗口刷新 按钮单击、双击 那么在Qt中信号是通过什么形式呈现给使用者的呢？
我们对哪个窗口进行操作，哪个窗口就可以捕捉到这些被触发的事件。 对于使用者来说触发了一个事件我们就可以得到Qt框架给我们发出的某个特定信号 信号的呈现形式就是函数， 也就是说某个事件产生了， Qt框架就会调用某个对应的信号函数通知使用者。 在QT中信号的发出者是某个实例化的类对象，对象内部可以进行相关事件的检测。
槽的本质 在Qt中槽函数是一类特殊的功能的函数，在编码过程中也可以作为类的普通成员函数来使用。之所以称之为槽函数是因为它们还有一个职责就是对Qt框架中产生的信号进行处理。
举个简单的例子：女朋友说：“我肚子饿了！”，于是我带她去吃饭。 上边例子中相当于女朋友发出了一个信号， 我收到了信号并其将其处理掉了。
实例对象 角色 描述 女朋友 信号发出者 信号携带的信息：饿了 我 信号接受者 处理女朋友发射的信号：带她去吃饭 在Qt中槽函数的所有者也是某个类的实例对象。
信号和槽的关系 在Qt中信号和槽函数都是独立的个体，本身没有任何联系，但是由于某种特性需求我们可以将二者连接到一起，好比牛郎和织女想要相会必须要有喜鹊为他们搭桥一样。在Qt中我们需要使用QOjbect类中的connect函数将二者的关联。 connect的函数原型如下：1QMetaObject::Connection QObject::connect( 2 const QObject *sender, PointerToMemberFunction signal, 3 const QObject *receiver, PointerToMemberFunction method, 4	Qt::ConnectionType type = Qt::AutoConnection); 5参数: 6 - sender: 发出信号的对象 7 - signal: 属于sender对象, 信号是一个函数, 这个参数的类型是函数 8 指针, 信号函数地址 9 - receiver: 信号接收者 10 - method: 属于receiver对象, 当检测到sender发出了signal信号, 11 receiver对象调用method方法，信号发出之后的处理动作 12 13// 参数 signal 和 method 都是函数地址, 因此简化之后的 connect() 如下: 14connect(const QObject *sender, &amp;QObject::signal, 15 const QObject *receiver, &amp;QObject::method); 使用connect() 进行信号槽连接的注意事项:
connect函数相当于做了信号处理动作的注册。 调用conenct函数的sender对象的信号并没有产生, 因此receiver对象的method也不会被调用。 method槽函数本质是一个回调函数, 调用的时机是信号产生之后, 调用是Qt框架来执行的。 connect中的sender和recever两个指针必须被实例化了, 否则conenct不会成功。 补充知识：关于connect函数的第5个参数1第五个参数是信号和槽的链接类型： 2Qt::AutoConnection(默认)：自动链接，如果信号在接收者所依附的线程内发射，等同于直接连接，如果发射信号的线程和接收者所依附的线程不同，则等同于队列连接。 3Qt::DirectConnection:直接连接，当信号发射时，槽函数将直接被调用，不论槽函数所属对象位于哪个线程，槽函数都在发射信号的线程内执行（这种方式不能跨线程传递消息）。 4Qt::QueuedConnection:队列连接，当控制权回到接受者所依附线程的事件循环时，槽函数被调用。槽函数在接受者所依附的线程执行（这种方式可以在线程内传递消息，也可以在线程之间传递）。 5Qt::UniqueConnection:独立链接，防止重复链接 6Qt::BlockingQueuedConnection:阻塞队列链接，和Qt::QueuedConnection类似，但是发送消息后阻塞，直到等到关联的slot被执行（说明它是专门用来多线程传递消息的，而且是阻塞的类型）。 7 8单线程：使用直接连接效率最高，默认也可以 9多线程：使用Qt::QueuedConnection或者Qt::BlockingQueuedConnection 标准信号槽的使用 假设有一个窗口，窗口上有一个按钮，实现点击该按钮则关闭窗口的操作。
1// 单击按钮关闭窗口 2connect(ui-&gt;closewindow, &amp;QPushButton::clicked, this, &amp;MainWindow::close); connect() 操作一般写在窗口的构造函数中, 相当于在事件产生之前在qt框架中先进行注册, 这样在程序运行过程中假设产生了按钮的点击事件, 框架就会调用信号接收者对象对应的槽函数了, 如果信号不产生, 槽函数也就一直不会被调用。
自定义信号槽使用 Qt预先定义了一些信号和槽，但是，我们总会有需求是Qt预先定义的信号槽不能满足的，此时，需要自定义信号和槽。想在Qt类中自定义信号和槽，需要满足以下条件：
这个新的子类必须从QObject类或者是QObject子类进行派生 在定义类的头文件中加入Q_OBJECT宏 1// 在头文件派生类的时候，首先像下面那样引入Q_OBJECT宏： 2class MyMainWindow : public QWidget 3{ 4 Q_OBJECT // 信号宏，类似与DECLARE_MESSAGE_MAP 5 ...... 6} 自定义信号 在Qt中信号的本质是事件，但是在框架中也是以函数的形式存在的，只不过信号对应的函数只有声明，没有定义。如果Qt中的标准信号不能满足我们的需求，可以在程序中进行信号的自定义，当自定义信号对应的事件产生之后，认为的将这个信号发射出去即可（其实就是调用一下这个信号函数）。
注意：参数不可使用宏定义和函数指针，参数列表不可使用默认值，不可使用模板类
自定义信号时需注意：
信号是类的成员函数。 返回值必须是void类型。 信号的名字可以根据实际情况进行指定。 参数可以随意指定, 信号也支持重载。 信号需要使用signals关键字进行声明, 使用方法类似于public等关键字。 信号函数只需要声明, 不需要定义(没有函数体实现)。 在程序中发射自定义信号: 发送信号的本质就是调用信号函数： 习惯性在信号函数前加关键字: emit, 但是可以省略不写。 emit只是显示的声明一下信号要被发射了, 没有特殊含义。 底层 emit == #define emit。 1// 举例: 信号重载 2// Qt中的类想要使用信号槽机制必须要从QObject类派生(直接或间接派生都可以) 3class Test : public QObject 4{ 5 Q_OBJECT 6signals: 7 void testsignal(); 8	// 参数的作用是数据传递, 谁调用信号函数谁就指定实参 9	// 实参最终会被传递给槽函数 10 void testsignal(int a); 11}; 自定义槽 槽函数就是信号的处理动作，在Qt中槽函数可以作为普通的成员函数来使用。如果标准槽函数提供的功能满足不了需求，可以自己定义槽函数进行某些特殊功能的实现。自定义槽函数和自定义的普通函数写法是一样的。下边给大家阐述一下, 自定义槽的要求和注意事项:
返回值必须是void类型。 槽也是函数, 因此也支持重载。 槽函数需要指定多少个参数, 需要看连接的信号的参数个数。 槽函数的参数是用来接收信号传递的数据的, 信号传递的数据就是信号的参数。 举例 信号函数: void testsig (int a, double b); 槽函数: void testslot (int a, double b); 总结 槽函数的参数应该和对应的信号的参数个数，从左到右类型依次对应。 信号的参数可以大于等于槽函数的参数个数 == 信号传递的数据被忽略了。 信号函数: void testsig (int a, double b); 槽函数: void testslot (int a); Qt中槽函数的类型是多样的。 Qt中的槽函数可以是类的成员函数、全局函数、静态函数、Lambda表达式。 槽函数可以使用关键字进行声明: slots (Qt5中slots可以省略不写)。 public slots: private slots: –&gt; 这样的槽函数不能在类外部被调用 protected slots: –&gt; 这样的槽函数不能在类外部被调用 1// 槽函数书写格式举例 2// 类中的这三个函数都可以作为槽函数来使用 3class Test : public QObject 4{ 5 public: 6 void testSlot(); 7 static void testFunc(); 8 9 public slots: 10 void testSlot(int id); 11}; 根据特定场景自定义信号槽:
再让女朋友饿一次: 女朋友说：“我肚子饿了！”，于是我带她去吃饭。 1// class GirlFriend 2class GirlFriend : public QObject 3{ 4 Q_OBJECT 5public: 6 explicit GirlFriend(QObject *parent = nullptr); 7 8signals: 9 void hungry();	// 不能表达出想要吃什么 10 void hungry(QString msg);	// 可以通过参数表达想要吃什么 11}; 12 13// class Me 14class Me : public QObject 15{ 16 Q_OBJECT 17public: 18 explicit Me(QObject *parent = nullptr); 19 20public slots: 21 // 槽函数 22 void eatMeal(); // 不能知道信号发出者要吃什么 23 void eatMeal(QString msg); // 可以知道信号发出者要吃什么 24}; 信号槽相关扩展 信号槽使用扩展 一个信号可以连接多个槽函数，发送一个信号有多个处理动作 需要写多个connect() 连接。 槽函数的执行顺序是随机的，和connect函数的调用顺序没有关系。 信号的接收者可以是一个对象，也可以是多个对象。 一个槽函数可以连接多个信号，多个不同的信号，处理动作是相同的。 需要写多个connect() 连接。 信号可以连接信号。 信号槽是可以断开的。 信号接收者可以不处理接收的信号，而是继续发射新的信号，这相当于传递了数据，并没有对数据进行处理信号槽的连接方式 Qt5的方式 1// 语法: 2QMetaObject::Connection QObject::connect( 3 const QObject *sender, PointerToMemberFunction signal, 4 const QObject *receiver, PointerToMemberFunction method, 5	Qt::ConnectionType type = Qt::AutoConnection); 6 7// 信号和槽函数也就是第2,4个参数传递的是地址, 编译器在编译过程中会对数据的正确性进行检测 8connect(const QObject *sender, &amp;QObject::signal, 9 const QObject *receiver, &amp;QObject::method); Qt4的方式 这种旧的信号槽连接方式在Qt5中是支持的，但是不推荐使用，因为这种方式在进行信号槽连接的时候，信号槽函数通过宏SIGNAL和SLOT转换为字符串类型。
因为信号槽函数的转换是通过宏来进行转换的，因此传递到宏函数内部的数据不会被进行检测， 如果使用者传错了数据，编译器也不会报错，但实际上信号槽的连接已经不对了，只有在程序运行起来之后才能发现问题，而且问题不容易被定位。
1// Qt4的信号槽连接方式 2[static] QMetaObject::Connection QObject::connect( 3 const QObject *sender, const char *signal, 4 const QObject *receiver, const char *method, 5 Qt::ConnectionType type = Qt::AutoConnection); 6 7connect(const QObject *sender,SIGNAL(信号函数名(参数1, 参数2, ...)), 8 const QObject *receiver,SLOT(槽函数名(参数1, 参数2, ...))); Qt4中声明槽函数必须要使用slots关键字,不能省略举例：我肚子饿了，我要吃东西。 分析：信号发出者是我自己，接受者也是我自己
1class Me : public QObject 2{ 3 Q_OBJECT 4 // Qt4中的槽函数必须这样声明, qt5中的关键字 slots 可以被省略 5public slots: 6 void eat(); 7 void eat(QString somthing); 8 signals: 9 void hungury(); 10 void hungury(QString somthing); 11}; 12 13// 基于上边的类写出解决方案 14// 处理如下逻辑: 我饿了, 我要吃东西 15// 分析: 信号的发出者是我自己, 信号的接收者也是我自己 16Me m; 17// Qt4处理方式 18connect(&amp;m, SIGNAL(eat()), &amp;m, SLOT(hungury())); 19connect(&amp;m, SIGNAL(eat(QString)), &amp;m, SLOT(hungury(QString))); 20 21// Qt5处理方式 22connect(&amp;m, &amp;Me::eat, &amp;m, &amp;Me::hungury);	// error Qt5处理方式错误原因分析：上边的写法之所以错误是因为这个类中信号槽都是重载过的, 信号和槽都是通过函数名去关联函数的地址, 但是这个同名函数对应两块不同的地址, 一个带参, 一个不带参, 因此编译器就不知道去关联哪块地址了, 所以如果我们在这种时候通过以上方式进行信号槽连接, 编译器就会报错。 解决方案可以通过定义函数指针的方式指定出函数的具体参数，这样就可以确定函数的具体地址了。 定义函数指针指向重载的某个信号或者槽函数，在connect()函数中将函数指针名字作为实参就可以了。 1// 定义函数指针指向重载的某一个具体的信号地址 2void (Me::*mysignal)(QString) = &amp;Me::eat; 3// 定义函数指针指向重载的某一个具体的槽函数地址 4void (Me::*myslot)(QString) = &amp;Me::hungury; 5// 使用定义的函数指针完成信号槽的连接 6connect(&amp;m, mysignal, &amp;m, myslot); 总结 Qt4的信号槽连接方式因为使用了宏函数, 宏函数对用户传递的信号槽不会做错误检测, 容易出bug。 Qt5的信号槽连接方式, 传递的是信号槽函数的地址, 编译器会做错误检测, 减少了bug的产生。 当信号槽函数被重载之后, Qt4的信号槽连接方式不受影响。 当信号槽函数被重载之后, Qt5中需要给被重载的信号或者槽定义函数指针。 ]]></content>
  </entry>
  
  <entry>
    <title>Qt多线程</title>
    <url>/yfmff/yfmff.github.io.git/post/qt/qtthread/</url>
    <categories><category>qt</category>
    </categories>
    <tags>
      <tag>qt-thread</tag>
    </tags>
    <content type="html"><![CDATA[Qt中实现多线程非常简单（相对于在linux上使用纯C函数），如果把线程池也算在内的话，Qt提供了三种多线程的方法。Qt提供了QThread类，通过这个类就可以很方便的进行多线程操作，在具体介绍三种方法之前，可先了解下QThread这个类。QThread 1// QThread 类常用 API 2// 构造函数 3QThread::QThread(QObject *parent = Q_NULLPTR); 4// 判断线程中的任务是不是处理完毕了 5bool QThread::isFinished() const; 6// 判断子线程是不是在执行任务 7bool QThread::isRunning() const; 8 9// Qt中的线程可以设置优先级 10// 得到当前线程的优先级 11Priority QThread::priority() const; 12void QThread::setPriority(Priority priority); 13优先级: 14 QThread::IdlePriority --&gt; 最低的优先级 15 QThread::LowestPriority 16 QThread::LowPriority 17 QThread::NormalPriority 18 QThread::HighPriority 19 QThread::HighestPriority 20 QThread::TimeCriticalPriority --&gt; 最高的优先级 21 QThread::InheritPriority --&gt; 子线程和其父线程的优先级相同, 默认是这个 22// 退出线程, 停止底层的事件循环 23// 退出线程的工作函数 24void QThread::exit(int returnCode = 0); 25// 调用线程退出函数之后, 线程不会马上退出因为当前任务有可能还没有完成, 调回用这个函数是 26// 等待任务完成, 然后退出线程, 一般情况下会在 exit() 后边调用这个函数 27bool QThread::wait(unsigned long time = ULONG_MAX); 信号槽 1// 和调用 exit() 效果是一样的 2// 代用这个函数之后, 再调用 wait() 函数 3[slot] void QThread::quit(); 4// 启动子线程 5[slot] void QThread::start(Priority priority = InheritPriority); 6// 线程退出, 可能是会马上终止线程, 一般情况下不使用这个函数 7[slot] void QThread::terminate(); 8 9// 线程中执行的任务完成了, 发出该信号 10// 任务函数中的处理逻辑执行完毕了 11[signal] void QThread::finished(); 12// 开始工作之前发出这个信号, 一般不使用 13[signal] void QThread::started(); 静态方法 1// 返回一个指向管理当前执行线程的QThread的指针 2[static] QThread *QThread::currentThread(); 3// 返回可以在系统上运行的理想线程数 == 和当前电脑的 CPU 核心数相同 4[static] int QThread::idealThreadCount(); 5// 线程休眠函数 6[static] void QThread::msleep(unsigned long msecs);	// 单位: 毫秒 7[static] void QThread::sleep(unsigned long secs);	// 单位: 秒 8[static] void QThread::usleep(unsigned long usecs);	// 单位: 微秒 任务处理函数 1// 子线程要处理什么任务, 需要写到 run() 中 2[virtual protected] void QThread::run(); 这个run() 函数是个虚函数，如果想让创建的子线程执行某个任务，需要写一个子类让其继承QThread，并且在子类中重写父类的run() 方法，函数体就是对应的任务处理流程。另外，这个函数是一个受保护的成员函数，不能够在类的外部调用，如果想要让线程执行这个函数中的业务流程，需要通过当前线程对象调用槽函数start() 启动子线程，当子线程被启动，这个run() 函数也就在线程内部被调用了。
方法1 1#include&lt;QDebug&gt; 2#include&lt;QThread&gt; 3class MyThread:public QThread 4{ 5 ...省略 6 protected: 7 // 重写这个虚函数以执行你的工作 8 virtual run() override 9 { 10 qDebug()&lt;&lt;&#34;鸡你太美~你干嘛~哎呦&#34;; 11 } 12} 13 14int main() 15{ 16 MyThread* TmpThread=new MyThread(); 17 TmpThread-&gt;start(); 18 return 0; 19} 此方法简单，但是流程代码全在run() 里面，不好拆分（拆分需重新构造类，另外开线程了）
方法2 此方法仍然需要创建自己的类，但是不需要派生自QThread，而是派生自QObject
1#include&lt;QDebug&gt; 2#include&lt;QThread&gt; 3class MyJob:public QObject 4{ 5 ...省略 6 void working() // 函数名自己制定，不用非得叫run了 7 { 8 qDebug()&lt;&lt;&#34;鸡你太美~你干嘛~哎呦&#34;; 9 qDebug()&lt;&lt;&#34;小鸡子露出黑脚了吧&#34;; 10 } 11} 12 13// 假设有个按钮btn，点击运行working 14int main() 15{ 16 17 MyJob* jb=new MyJob(); // 千万千万不要制定父对象！！！！！ 18 connect(&amp;btn,&amp;QPushButton::clicked,jb,&amp;MyJob::working); 19 QThread* tmpThread=new QThread(); 20 // 调用QObject的moveToThread方法 21 jb-&gt;moveToThread(tmpThread); 22 tmpThread-&gt;start(); // 线程启动了，但是working()并没有执行 23 //jb-&gt;working(); 不能这么写，这样直接调用还是在主线程 24 return; 25} 此方法推荐，因为哪怕我们需求再多，我们也可分别派生，然后不断的moveToThread，方便我们管理代码。
方法3 线程虽然快，但是创建和销毁都有开销，频发的创建和销毁线程反而会拖慢运行速度，此时可采用线程池。 线程池是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。线程池线程都是后台线程。每个线程都使用默认的堆栈大小，以默认的优先级运行，并处于多线程单元中。如果某个线程在托管代码中空闲（如正在等待某个事件）, 则线程池将插入另一个辅助线程来使所有处理器保持繁忙。如果所有线程池线程都始终保持繁忙，但队列中包含挂起的工作，则线程池将在一段时间后创建另一个辅助线程但线程的数目永远不会超过最大值。超过最大值的线程可以排队，但他们要等到其他线程完成后才启动。
线程池的组成主要分为 3 个部分，这三部分配合工作就可以得到一个完整的线程池：
任务队列，存储需要处理的任务，由工作的线程来处理这些任务 通过线程池提供的API函数，将一个待处理的任务添加到任务队列，或者从任务队列中删除。 已处理的任务会被从任务队列中删除。 线程池的使用者，也就是调用线程池函数往任务队列中添加任务的线程就是生产者线程。 工作的线程（任务队列任务的消费者），N个。 线程池中维护了一定数量的工作线程，他们的作用是是不停的读任务队列，从里边取出任务并处理。 工作的线程相当于是任务队列的消费者角色。 如果任务队列为空，工作的线程将会被阻塞 (使用条件变量 / 信号量阻塞)。 如果阻塞之后有了新的任务，由生产者将阻塞解除，工作线程开始工作。 管理者线程（不处理任务队列中的任务），1个。 它的任务是周期性的对任务队列中的任务数量以及处于忙状态的工作线程个数进行检测。 当任务过多的时候，可以适当的创建一些新的工作线程。 当任务过少的时候，可以适当的销毁一些工作的线程。 QRunnable 在Qt中，想使用线程池，需要先创建任务，而只有QRunnable类型的对象能添加到线程池中，因此我们需要自定义一个派生自QRunnable的类，重写其run()，然后将这个类对象传递给线程池，由线程池决定什么时候运行。 QRunnable常用函数：
1// 在子类中必须要重写的函数, 里边是任务的处理流程 2[pure virtual] void QRunnable::run(); 3 4// 参数设置为 true: 这个任务对象在线程池中的线程中处理完毕, 这个任务对象就会自动销毁 5// 参数设置为 false: 这个任务对象在线程池中的线程中处理完毕, 对象需要程序猿手动销毁 6void QRunnable::setAutoDelete(bool autoDelete); 7// 获取当前任务对象的析构方式,返回true-&gt;自动析构, 返回false-&gt;手动析构 8bool QRunnable::autoDelete() const; 用法：
1class MyWork : public QObject, public QRunnable 2{ 3 Q_OBJECT 4public: 5 explicit MyWork(QObject *parent = nullptr) 6 { 7 // 任务执行完毕,该对象自动销毁 8 setAutoDelete(true); 9 } 10 ~MyWork(); 11 12 void run() override{} 13} QThreadPool Qt中的QThreadPool类管理了一组QThreads, 里边还维护了一个任务队列。QThreadPool管理和回收各个QThread对象，以帮助减少使用线程的程序中的线程创建成本。每个Qt应用程序都有一个全局QThreadPool对象，可以通过调用globalInstance() 来访问它。也可以单独创建一个QThreadPool 对象使用。 线程池常用函数：
1// 获取和设置线程中的最大线程个数 2int maxThreadCount() const; 3void setMaxThreadCount(int maxThreadCount); 4 5// 给线程池添加任务, 任务是一个 QRunnable 类型的对象 6// 如果线程池中没有空闲的线程了, 任务会放到任务队列中, 等待线程处理 7void QThreadPool::start(QRunnable * runnable, int priority = 0); 8// 如果线程池中没有空闲的线程了, 直接返回值, 任务添加失败, 任务不会添加到任务队列中 9bool QThreadPool::tryStart(QRunnable * runnable); 10 11// 线程池中被激活的线程的个数(正在工作的线程个数) 12int QThreadPool::activeThreadCount() const; 13 14// 尝试性的将某一个任务从线程池的任务队列中删除, 如果任务已经开始执行就无法删除了 15bool QThreadPool::tryTake(QRunnable *runnable); 16// 将线程池中的任务队列里边没有开始处理的所有任务删除, 如果已经开始处理了就无法通过该函数删除了 17void QThreadPool::clear(); 18 19// 在每个Qt应用程序中都有一个全局的线程池对象, 通过这个函数直接访问这个对象 20static QThreadPool * QThreadPool::globalInstance(); 得到线程池对象之后，调用start() 方法就可以将一个任务添加到线程池中，这个任务就可以被线程池内部的线程池处理掉了，使用线程池比自己创建线程的这种多种多线程方式更加简单和易于维护。
具体的使用方式如下：
1int main() 2{ 3 ...省略 4 // 线程池初始化，设置最大线程池数 5 QThreadPool::globalInstance()-&gt;setMaxThreadCount(4); 6 // 添加任务 7 MyWork* task = new MyWork; 8 QThreadPool::globalInstance()-&gt;start(task); 9} ]]></content>
  </entry>
  
  <entry>
    <title>Qt右键菜单</title>
    <url>/yfmff/yfmff.github.io.git/post/qt/qtqmen/</url>
    <categories><category>qt</category>
    </categories>
    <tags>
    </tags>
    <content type="html"><![CDATA[
想要在某一窗口中显示右键菜单，其处理方式大体上有两种，分别为基于鼠标事件实现和基于窗口的菜单策略实现。其中第二种方式中又有三种不同的实现方式，因此如果想要在窗口中显示一个右键菜单一共四种实现方式。
基于鼠标事件实现 原理 使用这种方式实现右键菜单的显示需要使用事件处理器函数 , 在Qt中这类函数都是回调函数，并且在自定义窗口类中我们还可以自定义事件处理器函数的行为（因为子类继承了父类的这个方法并且这类函数是虚函数）。 实现步骤如下：在当前窗口类中重写鼠标操作相关的的事件处理器函数，有两个可以选择： 1// 以下两个事件二选一即可, 只是事件函数被调用的时机不同罢了 2// 这个时机对右键菜单的显示没有任何影响 3[virtual protected] void QWidget::mousePressEvent(QMouseEvent *event); 4[virtual protected] void QWidget::mouseReleaseEvent(QMouseEvent *event); 在数据表事件处理器函数内部判断是否按下了鼠标右键。 如果按下了鼠标右键创建菜单对象 (也可以提前先创建处理), 并将其显示出来。 1// 关于QMenu类型的菜单显示需要调用的 API 2// 参数 p 就是右键菜单需要显示的位置, 这个坐标需要使用屏幕坐标 3// 该位置坐标一般通过调用 QCursor::pos() 直接就可以得到了 4QAction *QMenu::exec(const QPoint &amp;p, QAction *action = nullptr); 具体代码 在头文件中添加要重写的鼠标事件处理器函数声明，这里使用的是mousePressEvent()。1// mainwindow.h 2#include &lt;QMainWindow&gt; 3 4namespace Ui { 5class MainWindow; 6} 7 8class MainWindow : public QMainWindow 9{ 10 Q_OBJECT 11 12public: 13 explicit MainWindow(QWidget *parent = 0); 14 ~MainWindow(); 15 16protected: 17 // 鼠标按下, 该函数被Qt框架调用, 需要重写该函数 18 void mousePressEvent(QMouseEvent *event); 19 20private: 21 Ui::MainWindow *ui; 22}; 在源文件中重写从父类继承的虚函数mousePressEvent()。1// mainwindow.cpp 2void MainWindow::mousePressEvent(QMouseEvent *event) 3{ 4 // 判断用户按下的是哪一个鼠标键 5 if(event-&gt;button() == Qt::RightButton) 6 { 7 // 弹出一个菜单, 菜单项是 QAction 类型 8 QMenu menu; 9 QAction* act = menu.addAction(&#34;C++&#34;); 10 connect(act, &amp;QAction::triggered, this, [=]() 11 { 12 QMessageBox::information(this, &#34;title&#34;, &#34;您选择的是C++...&#34;); 13 }); 14 menu.addAction(&#34;Java&#34;); 15 menu.addAction(&#34;Python&#34;); 16 menu.exec(QCursor::pos()); // 右键菜单被模态显示出来了 17 } 18} 基于窗口的菜单策略实现 这种方式是使用Qt中QWidget类中的右键菜单函数QWidget::setContextMenuPolicy(Qt::ContextMenuPolicy policy) 来实现，因为这个函数的参数可以指定不同的值，因此不同参数对应的具体的实现方式也不同。 这个函数的函数原型如下：1// 函数原型: 2void QWidget::setContextMenuPolicy(Qt::ContextMenuPolicy policy); 3参数: 4 - Qt::NoContextMenu	--&gt; 不能实现右键菜单 5 - Qt::PreventContextMenu --&gt; 不能实现右键菜单 6 - Qt::DefaultContextMenu --&gt; 基于事件处理器函数 QWidget::contextMenuEvent() 实现 7 - Qt::ActionsContextMenu --&gt; 添加到当前窗口中所有 QAction 都会作为右键菜单项显示出来 8 - Qt::CustomContextMenu --&gt; 基于 QWidget::customContextMenuRequested() 信号实现 Qt::DefaultContextMenu 使用这个策略实现右键菜单，需要借助窗口类从父类继承的虚函数QWidget::contextMenuEvent() 并重写它来实现。 要做的第一步是在窗口类的头文件中添加这个函数的声明。1// mainwindow.h 2#include &lt;QMainWindow&gt; 3 4namespace Ui { 5class MainWindow; 6} 7 8class MainWindow : public QMainWindow 9{ 10 Q_OBJECT 11 12public: 13 explicit MainWindow(QWidget *parent = 0); 14 ~MainWindow(); 15 16protected: 17 // 如果窗口设置了 Qt::DefaultContextMenu 策略, 18 // 点击鼠标右键该函数被Qt框架调用 19 void contextMenuEvent(QContextMenuEvent *event); 20 21private: 22 Ui::MainWindow *ui; 23}; 第二步在这个窗口类的构造函数设置右键菜单策略。1// mainwindow.cpp 2MainWindow::MainWindow(QWidget *parent) : 3 QMainWindow(parent), 4 ui(new Ui::MainWindow) 5{ 6 ui-&gt;setupUi(this); 7 8 // 给窗口设置策略: Qt::DefaultContextMenu 9 // 在窗口中按下鼠标右键, 这个事件处理器函数被qt框架调用 QWidget::contextMenuEvent() 10 setContextMenuPolicy(Qt::DefaultContextMenu); 11} 第三步在这个窗口类的源文件中重写事件处理器函数contextMenuEvent()。1// mainwindow.cpp 2void MainWindow::contextMenuEvent(QContextMenuEvent *event) 3{ 4 // 弹出一个菜单, 菜单项是 QAction 类型 5 QMenu menu; 6 QAction* act = menu.addAction(&#34;C++&#34;); 7 connect(act, &amp;QAction::triggered, this, [=]() 8 { 9 QMessageBox::information(this, &#34;title&#34;, &#34;您选择的是C++...&#34;); 10 }); 11 menu.addAction(&#34;Java&#34;); 12 menu.addAction(&#34;Python&#34;); 13 menu.exec(QCursor::pos());	// 右键菜单被模态显示出来了 14} Qt::ActionsContextMenu 使用这个策略实现右键菜单，是最简单的一种，我们只需要创建一些QAction类型的对象并且将他们添加到当前的窗口中，当我们在窗口中点击鼠标右键这些QAction类型的菜单项就可以显示出来了。 虽然这种方法比较简单，但是它有一定的局限性，就是在一个窗口中不能根据不同的需求制作不同的右键菜单，这种方式只能得到一个唯一的右键菜单。 相关的处理代码如下：1// mainwindow.cpp 2MainWindow::MainWindow(QWidget *parent) : 3 QMainWindow(parent), 4 ui(new Ui::MainWindow) 5{ 6 ui-&gt;setupUi(this); 7 8 // 只要将某个QAction添加给对应的窗口, 这个action就是这个窗口右键菜单中的一个菜单项了 9 // 在窗口中点击鼠标右键, 就可以显示这个菜单 10 setContextMenuPolicy(Qt::ActionsContextMenu); 11 // 给当前窗口添加QAction对象 12 QAction* act1 = new QAction(&#34;C++&#34;); 13 QAction* act2 = new QAction(&#34;Java&#34;); 14 QAction* act3 = new QAction(&#34;Python&#34;); 15 this-&gt;addAction(act1); 16 this-&gt;addAction(act2); 17 this-&gt;addAction(act3); 18 connect(act1, &amp;QAction::triggered, this, [=]() 19 { 20 QMessageBox::information(this, &#34;title&#34;, &#34;您选择的是C++...&#34;); 21 }); 22} Qt::CustomContextMenu 使用这个策略实现右键菜单，当点击鼠标右键，窗口会产生一个QWidget::customContextMenuRequested() 信号，注意仅仅只是发射信号，意味着要自己写显示右键菜单的槽函数（slot），这个信号是QWidget 唯一与右键菜单有关的信号。 我们先来看一下这个信号的函数原型:1// 注意: 信号中的参数pos为当前窗口的坐标，并非屏幕坐标，右键菜单显示需要使用屏幕坐标 2[signal] void QWidget::customContextMenuRequested(const QPoint &amp;pos) 代码实现也比较简单，如下所示:1// mainwindow.cpp 2MainWindow::MainWindow(QWidget *parent) : 3 QMainWindow(parent), 4 ui(new Ui::MainWindow) 5{ 6 ui-&gt;setupUi(this); 7 8 // 策略 Qt::CustomContextMenu 9 // 当在窗口中点击鼠标右键, 窗口会发出一个信号: QWidget::customContextMenuRequested() 10 // 对应发射出的这个信号, 需要添加一个槽函数, 用来显示右键菜单 11 this-&gt;setContextMenuPolicy(Qt::CustomContextMenu); 12 connect(this, &amp;MainWindow::customContextMenuRequested, this, [=](const QPoint &amp;pos) 13 { 14 // 参数 pos 是鼠标按下的位置, 但是不能直接使用, 这个坐标不是屏幕坐标, 是当前窗口的坐标 15 // 如果要使用这个坐标需要将其转换为屏幕坐标 16 QMenu menu; 17 QAction* act = menu.addAction(&#34;C++&#34;); 18 connect(act, &amp;QAction::triggered, this, [=]() 19 { 20 QMessageBox::information(this, &#34;title&#34;, &#34;您选择的是C++...&#34;); 21 }); 22 menu.addAction(&#34;Java&#34;); 23 menu.addAction(&#34;Python&#34;); 24 // menu.exec(QCursor::pos()); 25 // 将窗口坐标转换为屏幕坐标 26 QPoint newpt = this-&gt;mapToGlobal(pos); 27 menu.exec(newpt); 28 }); 29} 在上边的程序中，我们通过窗口发射的信号得到了一个坐标类型的参数，大家一定要注意这个坐标是当前窗口的窗口坐标, 不是屏幕坐标, 显示右键菜单需要使用屏幕坐标。 对应这个坐标的处理可以有两种方式：弃用，选择使用QCursor::pos() 得到光标在屏幕的坐标位置 坐标转换，将窗口坐标转换为屏幕坐标，这里用到了一个函数mapToGlobal 1// 参数是当前窗口坐标, 返回值为屏幕坐标 2QPoint QWidget::mapToGlobal(const QPoint &amp;pos) const; 最后如果想要让自己的右键菜单项显示图标，可以调用这个函数1// 只显示文本字符串 2QAction *QMenu::addAction(const QString &amp;text); 3// 可以显示图标 + 文本字符串 4QAction *QMenu::addAction(const QIcon &amp;icon, const QString &amp;text); ]]></content>
  </entry>
  
  <entry>
    <title>Qt中的计时器</title>
    <url>/yfmff/yfmff.github.io.git/post/qt/qttimer/</url>
    <categories><category>qt</category>
    </categories>
    <tags>
    </tags>
    <content type="html"><![CDATA[Qt中提供了两种定时器方式，本节主要介绍一下Qt中的定时器类QTimer的使用方法。
要使用它，只需创建一个 QTimer 类对象，然后调用其start() 函数开启定时器，此后QTimer对象就会周期性的发出timeout() 信号。我们先来了解一下这个类的相关API。
成员函数和槽 1// 构造函数 2// 如果指定了父对象, 创建的堆内存可以自动析构 3QTimer::QTimer(QObject *parent = nullptr); 4 5// 设置定时器时间间隔为 msec 毫秒 6// 默认值是0，一旦窗口系统事件队列中的所有事件都已经被处理完，一个时间间隔为0的QTimer就会触发 7void QTimer::setInterval(int msec); 8// 获取定时器的时间间隔, 返回值单位: 毫秒 9int QTimer::interval() const; 10 11// 根据指定的时间间隔启动或者重启定时器, 需要调用 setInterval() 设置时间间隔 12[slot] void QTimer::start(); 13// 启动或重新启动定时器，超时间隔为msec毫秒。 14[slot] void QTimer::start(int msec); 15// 停止定时器。 16[slot] void QTimer::stop(); 17 18// 设置定时器精度 19/* 20参数: 21 - Qt::PreciseTimer -&gt; 精确的精度, 毫秒级 22 - Qt::CoarseTimer -&gt; 粗糙的精度, 和1毫秒的误差在5%的范围内, 默认精度 23 - Qt::VeryCoarseTimer -&gt; 非常粗糙的精度, 精度在1秒左右 24*/ 25void QTimer::setTimerType(Qt::TimerType atype); 26Qt::TimerType QTimer::timerType() const;	// 获取当前定时器的精度 27 28// 如果定时器正在运行，返回true; 否则返回false。 29bool QTimer::isActive() const; 30 31// 判断定时器是否只触发一次 32bool QTimer::isSingleShot() const; 33// 设置定时器是否只触发一次, 参数为true定时器只触发一次, 为false定时器重复触发, 默认为false 34void QTimer::setSingleShot(bool singleShot); 信号 这个类的信号只有一个，当定时器超时时，该信号就会被发射出来。给这个信号通过conect() 关联一个槽函数，就可以在槽函数中处理超时事件了。
1[signal] void QTimer::timeout(); 静态成员函数 1// 其他同名重载函数可以自己查阅帮助文档 2/* 3功能: 在msec毫秒后发射一次信号, 并且只发射一次 4参数: 5	- msec: 在msec毫秒后发射信号 6	- receiver: 接收信号的对象地址 7	- method: 槽函数地址 8*/ 9[static] void QTimer::singleShot( 10 int msec, const QObject *receiver, 11 PointerToMemberFunction method); 定时器使用案例 周期性定时器 1// 创建定时器对象 2QTimer* timer = new QTimer(this); 3 4// 修改定时器对象的精度 5timer-&gt;setTimerType(Qt::PreciseTimer); 6 7// 按钮 loopBtn 的点击事件 8// 点击按钮启动或者关闭定时器, 定时器启动, 周期性得到当前时间 9connect(ui-&gt;loopBtn, &amp;QPushButton::clicked, this, [=]() 10{ 11 // 启动定时器 12 if(timer-&gt;isActive()) 13 { 14 timer-&gt;stop(); // 关闭定时器 15 ui-&gt;loopBtn-&gt;setText(&#34;开始&#34;); 16 } 17 else 18 { 19 ui-&gt;loopBtn-&gt;setText(&#34;关闭&#34;); 20 timer-&gt;start(1000); // 1000ms == 1s 21 } 22}); 23 24connect(timer, &amp;QTimer::timeout, this, [=]() 25{ 26 QTime tm = QTime::currentTime(); 27 // 格式化当前得到的系统时间 28 QString tmstr = tm.toString(&#34;hh:mm:ss.zzz&#34;); 29 // 设置要显示的时间 30 ui-&gt;curTime-&gt;setText(tmstr); 31}); 一次性定时器 1// 点击按钮 onceBtn 只发射一次信号 2// 点击按钮一次, 发射一个信号, 得到某一个时间点的时间 3connect(ui-&gt;onceBtn, &amp;QPushButton::clicked, this, [=]() 4{ 5 // 获取2s以后的系统时间, 不创建定时器对象, 直接使用类的静态方法 6 QTimer::singleShot(2000, this, [=](){ 7 QTime tm = QTime::currentTime(); 8 // 格式化当前得到的系统时间 9 QString tmstr = tm.toString(&#34;hh:mm:ss.zzz&#34;); 10 // 设置要显示的时间 11 ui-&gt;onceTime-&gt;setText(tmstr); 12 }); 13}); ]]></content>
  </entry>
  
  <entry>
    <title>常见算法</title>
    <url>/yfmff/yfmff.github.io.git/post/cpp/sortalgorithm/</url>
    <categories><category>cpp</category>
    </categories>
    <tags>
    </tags>
    <content type="html"><![CDATA[
1// 辅助函数 2void swap(int &amp;i,int &amp;j) 3{ 4 int tmp=-1; 5 tmp=i; 6 i=j; 7 j=tmp; 8} 冒泡排序 1void bubble_sort(vector&lt;int&gt; &amp;need_sort) 2{ 3 if(need_sort.empty()) return; 4 5 for(int i=0;i&lt;need_sort.size()-1;++i) 6 { 7 for(int j=0;j&lt;need_sort.size()-i-1;++j) 8 { 9 if(need_sort[j]&gt;need_sort[j+1]) 10 { 11 swap(need_sort[j],need_sort[j+1]); 12 } 13 } 14 } 15} 插入排序 1void insert_sort(vector&lt;int&gt; &amp;ns) 2{ 3 if(ns.empty()) return; 4 5 for(int i=1;i&lt;ns.size();++i) 6 { 7 int key=ns[i]; // 要插入的元素 8 int j=i-1; // 插入的位置，暂时定为前一个 9 while(j&gt;=0 &amp;&amp; ns[j]&gt;key) // 如果前一个元素值比要插入的元素值大，则后移这个元素 10 { 11 ns[j+1]=ns[j]; 12 j--; 13 } 14 ns[j+1]=key; 15 } 16} 选择排序 1void chose_sort(vector&lt;int&gt; &amp;ns) 2{ 3 for(int i=0;i&lt;ns.size()-1;++i) 4 { 5 int min=i; 6 for(int j=i+1; j&lt;ns.size();++j) 7 { 8 if(ns[j]&lt;ns[min]) 9 min=j; 10 } 11 swap(ns[i],ns[min]); 12 } 13} 希尔排序 1// 希尔排序(插入排序的一种更高效的改进版本) 2void shell_sort(vector&lt;int&gt; &amp;ns) 3{ 4 // 方法1： 5// int step=1; 6// while(step&lt;ns.size()/3) 7// { 8// step=3*step+1; 9// } 10 11// while(step&gt;=1) 12// { 13// for(int i=0;i&lt;ns.size();++i) 14// { 15// for(int j=i; j&gt;=step&amp;&amp;ns[j]&lt;ns[j-step]; j-= step) 16// { 17// swap(ns[j],ns[j-step]); 18// } 19// } 20// step=step/3; 21// } 22 23 // 方法2 24 int i,j,inc,key; 25 for(inc=ns.size()/2;inc&gt;0;inc /=2) 26 { 27 for(i =inc;i&lt;ns.size();++i) 28 { 29 key=ns[i]; 30 for(j=i;j&gt;=inc&amp;&amp; key&lt;ns[j-inc];j -=inc) 31 { 32 ns[j]=ns[j-inc]; 33 } 34 ns[j]=key; 35 } 36 } 37} 归并排序 1// 归并排序(分治和递归思想) 2void gui_sort(vector&lt;int&gt; &amp;ns,int left,int right) 3{ 4 if(left &gt;= right) return; //开头和结尾一样则不用排了 5 6 // 划分 7 int mid=(left+right)/2; 8 gui_sort(ns,left,mid); 9 gui_sort(ns,mid+1,right); 10 11 // 合并 12 vector&lt;int&gt; tmp_vec; 13 tmp_vec.resize(ns.size()); 14 int l_pos=left; 15 int r_pos=mid+1; 16 int pos=left; 17 while(l_pos&lt;=mid &amp;&amp; r_pos&lt;=right) 18 { 19 if(ns[l_pos]&lt;=ns[r_pos]) 20 tmp_vec[pos++]=ns[l_pos++]; 21 else 22 tmp_vec[pos++]=ns[r_pos++]; 23 } 24 25 while(l_pos&lt;=mid) 26 tmp_vec[pos++]=ns[l_pos++]; 27 while(r_pos&lt;=right) 28 tmp_vec[pos++]=ns[r_pos++]; 29 30 while(left&lt;=right) 31 { 32 ns[left]=tmp_vec[left]; 33 left++; 34 } 35} 快速排序 1// 快速排序(找一个数作为基准) 2void quick_sort(vector&lt;int&gt; &amp;ns,int left,int right) 3{ 4 // 递归划分 5 if(left&gt;=right) return; 6 7 int pivot=ns[right]; 8 int i=left; 9 for(int j=left;j&lt;right;++j) 10 { 11 if(ns[j]&lt;pivot) 12 swap(ns[j],ns[i++]); 13 } 14 swap(ns[right],ns[left]); 15 quick_sort(ns,left,i); 16 quick_sort(ns,i+1,right); 17} 堆排序 1// 堆排序 2//此函数维护堆，n为需要维护的总元素个数，i 为待维护的节点下标 3void heapify(vector&lt;int&gt; &amp;ns,int n,int i) 4{ 5 // 维护堆的性质，以大顶堆为例 6 int largest=i; 7 int l_son=i*2+1; 8 int r_son=2*i+2; 9 10 if(l_son&lt;n&amp;&amp;ns[l_son]&gt;ns[largest]) 11 largest=l_son; 12 if(r_son&lt;n&amp;&amp;ns[largest]&lt;ns[r_son]) 13 largest=r_son; 14 15 if(largest !=i) 16 { 17 swap(ns[largest],ns[i]); 18 heapify(ns,n,largest); 19 } 20} 21 22// 建堆 23void heap_sort(vector&lt;int&gt; &amp;ns) 24{ 25 // 建堆 26 int n=ns.size(); 27 for(int i=(n-2)/2;i&gt;=0;--i) 28 { 29 heapify(ns,n,i); 30 } 31 32 // 排序 33 for(int i=n-1;i&gt;0;--i) 34 { 35 swap(ns[i],ns[0]); 36 heapify(ns,i,0); 37 } 38} ]]></content>
  </entry>
  
  <entry>
    <title>Hexo的butterfly主题使用注意事项</title>
    <url>/yfmff/yfmff.github.io.git/post/others/hexobutterfly/</url>
    <categories>
    </categories>
    <tags>
      <tag>hexo</tag>
    </tags>
    <content type="html"><![CDATA[
butterfly官方教程，此处仅补充一些事项。
配置文件的位置 进入下载的主题文件中，找到 _config.yml，复制出一份(不要删除源文件！)，并重命名为 _config.butterfly.yml，将此文件放到根目录下即可。 自定义顶部导航栏 默认的顶部导航栏是没有分级的。 但是，如果我们想要这种效果，需要怎么做呢？ 配置 _config.butterfly.yml 假设我们需要增加二级菜单，要下拉显示QT笔记、Linux笔记、C++笔记三个板块。 如图所示，打开 _config.butterfly.yml，在menu菜单下，新增红框部分代码，其中 ||之前的部分，表示这个分类在点击后会跳转到哪个文章（如点击了QT笔记，会跳转到根目录source/QT文件夹中，读取index.md文件来显示），而||之后的代码则是这个下拉的菜单每项的图标。 一定要注意文件中空格，否则会导致编译失败！建立对应的页面 这里以新建QT笔记对应的页面为例： 运行以下代码：
1hexo new page QT # 此处最好和在_config.butterfly.yml中 **||**前写的内容相同 执行完后会在source文件夹中生成QT文件夹，QT文件夹中有一个index.md，如图： 编辑index.md，一定要将type定义成 _config.butterfly.yml中||前写的内容！！！ 补充 主题设置中常用到一些图标资源： 社交图标主题美化]]></content>
  </entry>
  
  <entry>
    <title>Hexo主题使用教程</title>
    <url>/yfmff/yfmff.github.io.git/post/others/hexotheme/</url>
    <categories>
    </categories>
    <tags>
      <tag>hexo</tag>
    </tags>
    <content type="html"><![CDATA[
我们可以在网上看到很多的个人博客，其中不乏很多布局大气美观的。这是因为他们配置了主题。 我们刚搭建好hexo博客时，默认的页面是这样的： 而hexo官方有很多主题供我们选择，点击进入hexo主题页下载主题 选择一款主题，进入作者的主题页，可以得到主题库的地址，接下来就可以安装了。 如果你的hexo是5.0以上版本，可执行：
1npm i 主题名 主题会安装到博客的node_modules文件夹下。 或者，你也可以通过：
1git clone -b 分支 主题github地址 themes/自定义名称 2# 克隆master分支下的主题文件到我本地的themes文件夹的custom子文件夹中 3git clone -b master https:\\aaaaa.git themes/custom 应用 在我们存博客的文件夹中，根目录下有一个后缀为 .yml的文件，名为 _config.yml，打开它，将其中的theme冒号后面的字符串重命名为你下载的那个主题名（也就是你自定义的哪个文件夹名，本例子是theme:custom），保存。然后在git命令窗口输入hexo s即可预览。
]]></content>
  </entry>
  
  <entry>
    <title>Hexo搭建博客教程</title>
    <url>/yfmff/yfmff.github.io.git/post/others/hexoblog/</url>
    <categories>
    </categories>
    <tags>
      <tag>hexo</tag>
    </tags>
    <content type="html"><![CDATA[
哪个男孩不想有个自己的博客呢？本人搭建此博客，是用来记录自己的日常生活和编程学习过程中的心得体会以及踩的一些坑。关于hexo博客搭建，网上教程很多，此处仅就我个人搭建过程进行总结。 本教程是将博客搭建到github上，因此需要github账号，如果没有，点击注册写博客需要用到markdown语法，可提前了解。准备工作 采用HEXO搭建博客不需要你有任何的编程能力，照着教程一步一步的往下做就行啦。不过，工欲善其事必先利其器，我们首先需要安装一些工具。
安装node.js和git node.js下载地址node.js配置教程安装git安装很简单，下载好安装包后，基本上都是选好安装位置，一路下一步即可。安装好后，测验相关工具是否可用： 随便找一个文件夹，右键菜单，选择git bash here，输入以下代码： 1node -v 2npm -v # 测试包管理器 3git -v 如果看到和下图相似的内容，则安装成功： 安装hexo 在git命令提示窗口，输入以下代码： 1npm install hexo-cli -g # -g表示全局安装 安装完成后你会看到和下图相似的内容： 至此，准备工作已经完成。
创建github仓库 登陆你的github，点击头像，找到your repositories,得到以下页面： 输入你的仓库名: 注意，仓库名必须是你注册github的用户名.github.io！我这里因为已经创建过了，所以报了重名错误。
生成SSHkEY 1ssh-keygen -t rsa -C &#34;youxiang@xx.com&#34; # 邮箱地址 指令执行完后，会在C\user文件夹下生成 .ssh文件夹，打开得到id_rsa.pub文件，打开并原样复制。 打开github或者gitlab的账号设置，将刚刚复制得到的密钥复制并保存。 本地生成博客内容 至此，一切均已准备就绪，找一个空文件夹作为你的博客数据存放点。进入此文件夹，右键git bash here，打开git命令行窗口，输入以下命令：
1hexo init # 初始化hexo 执行完毕后，文件夹生成如下文件： 有时，会初始化失败、报错，不用担心，github是国外的网站，有时候访问速度太慢会报错，也有可能由于node.js与git安装目录没有管理员权限。运行以下代码，开启本地网站服务：
1hexo s 你将看到如下代码： 在浏览器输入http://localhost:4000/，即可看到你新建的本地博客！ 要结束本地服务，就在git命令行窗口同时按 CTRL 和 C
发布到gitee/github/服务器 现在搭建的博客只能本地访问，别人无法通过网络访问到你的博客。需要将博客资源（图、文章）等上传到gitee/github/服务器。
编辑配置文件 打开初始化hexo时的文件夹，找到 _config.yml这个文件。 在配置文件最后，按照图示更改： 别忘记把Url项改为你的gitee/github地址！安装hexo自动布置工具 在你博客资源文件夹，打开git命令窗口，输入以下命令：
1# 安装hexo-deployer-git工具 2npm install hexo-deployer-git --save 安装完成后，git命令行输入
1hexo clean # 清空临时文件 2hexo g # 重新生成 生成后，输入：
1hexo d # 部署到github 第一次部署，会让你输入用户名和密码。注意，这时候的密码并不是我们注册github账号时的密码，而是git令牌！，我们需要首先去github设置我们的令牌。 通过头像找到设置settings，页面拉到底，找到DeveloperSettings,点击进入后，找到PersonalAccessTokens，如下图所示： 我这里由于之前已经设置了，就没有显示令牌码，你新建后会给你一个限时的令牌码，务必保存好！！！ 复制新生成的令牌码，作为密码输入，接下来等着它部署完成就好。
进入你的github的仓库界面，就能发现你的仓库不空了。 当然，每个人博客内容不一样，仓库的东西也不一样。 要访问你的博客，直接在浏览器地址栏输入上图箭头部分的字符串（我的是yfmff.github.io)，即可访问。至此博客搭建完成。
]]></content>
  </entry>
  
  <entry>
    <title>站点示例</title>
    <url>/yfmff/yfmff.github.io.git/flinks.html</url>
    <categories>
    </categories>
    <tags>
    </tags>
    <content type="html"><![CDATA[如想交换本站友情链接，请在评论区留下你的站点信息，格式参考如下：
1- name: Hugo-NexT 2 desc: Hugo NexT 官方预览网站。 3 avatar: https://hugo-next.eu.org/imgs/hugo_next_avatar.png 4 link: https://hugo-next.eu.org ]]></content>
  </entry>
  
</search>